#LyX 1.3 created this file. For more info see http://www.lyx.org/
\lyxformat 221
\textclass book
\begin_preamble
\usepackage{a4wide}
\usepackage{indentfirst}
\end_preamble
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize 12
\spacing single 
\papersize Default
\paperpackage a4
\use_geometry 0
\use_amsmath 0
\use_natbib 0
\use_numerical_citations 0
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\quotes_times 2
\papercolumns 1
\papersides 2
\paperpagestyle default

\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\backslash 
titulo{Estudo sobre APIs de linguagens de script}
\layout Standard


\backslash 
autor{Hisham H.
 Muhammad}
\layout Standard


\backslash 
autorR{Muhammad, Hisham H.}
\layout Standard


\backslash 
orientador{Roberto Ierusalimschy}
\layout Standard


\backslash 
orientadorR{Ierusalimschy, Roberto}
\layout Standard


\backslash 
dia{11} 
\backslash 
mes{Junho} 
\backslash 
ano{2006}
\layout Standard


\backslash 
cidade{Rio de Janeiro}
\layout Standard


\backslash 
departamento{Informática}
\layout Standard


\backslash 
programa{Informática}
\layout Standard


\backslash 
centro{Centro Técnico Científico} 
\end_inset 


\layout Title

A study on scripting language APIs
\layout Author
\added_space_bottom bigskip 
Hisham H.
 Muhammad
\newline 

\newline 

\newline 

\size normal 
Advisor: Roberto Ierusalimschy
\newline 

\newline 

\newline 

\newline 
Pontifícia Universidade Católica do Rio de Janeiro
\newline 
Centro Técnico Científico
\newline 
Departamento de Informática
\layout Standard
\pagebreak_top 
\SpecialChar ~

\begin_inset ERT
status Open

\layout Standard

\backslash 
thispagestyle{empty}
\end_inset 


\layout Standard
\added_space_bottom bigskip \pagebreak_top \align center 

\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
setcounter{page}{1}
\end_inset 

Abstract
\layout Standard

Applications written in two programming languages, in order to optimize
 parts where performance is critical or to obtain extensibility through
 user-written scripts, are commonplace nowadays.
 There are several ways to obtain this kind of interoperability; ideally,
 however, a language should provide a foreign language interface (FLI),
 allowing the programmer to send and receive both data and function calls
 to the external language.
 
\layout Standard

This work discusses the main issues involving the design of APIs for the
 integration of language environments within C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as a scripting
 language and C\SpecialChar ~
code.
 We compare the approaches employed by five languages when handling communicatio
n between the data spaces of C and the embedded runtime environment and
 the consequences of these approaches in memory management, as well as sharing
 of code between the C\SpecialChar ~
application and that from the scripting language.
\layout Standard

We illustrate the differences of the APIs of those languages and their impact
 in the resulting code of a C\SpecialChar ~
application through a case study.
 Different scripting languages were embedded as plugins for a library, which
 on its turn exposes to client applications a generic scripting API.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures adopted by each language for function calls, registration
 of C\SpecialChar ~
functions and conversion of data between the environments.
\layout Standard


\begin_inset LatexCommand \tableofcontents{}

\end_inset 


\layout Chapter

Introduction
\layout Standard


\begin_inset Note
collapsed true

\layout Standard


\emph on 
\color red
[questões gerais: como padronizar o uso de itálicos?]
\layout Standard


\emph on 
\color red
[TODO: tem pouco aqui além do texto da proposta.
 estender a intro como um todo]
\end_inset 


\layout Standard

There are many situations in which it is necessary or interesting to have
 interaction between programs written in different languages.
 A typical case is the use of external libraries, such as graphic toolkits,
 APIs for database access, or even operating system calls.
 Another scenario involves applications developed using more than one programmin
g language, in order to optimize parts where performance is critical or
 to allow extensibility through scripts written by the end-user.
\layout Standard

Regardless of purpose, communication between programs written in different
 languages brings up a number of design issues, not only in the development
 of the applications, but in the languages themselves.
 There are many ways to obtain this kind of interoperability, from translation
 of code of a language to another to the use of a common virtual machine.
 Ideally, however, a language should provide a foreign language interface
 (FLI) that allows the programmer to send and receive both calls and data
 to the other language\SpecialChar ~

\begin_inset LatexCommand \cite{finne98haskellfli}

\end_inset 

.
 Among the factors that should be taken into account when developing such
 an interface are the differences between type systems, memory management
 issues (such as garbage collection and direct access to pointers) and concurren
cy models.
 Beyond dealing with semantic differences, the design of an interface between
 languages involves pragmatic issues such as the balance between the safe
 isolation of the runtime environments, performance and the simplicity of
 the resulting API.
\layout Standard

We can observe in the existing implementations of FLIs a number of approaches
 to these problems.
 In fact, FLIs for different languages (or even different revisions of a
 single language) tend to be very different from each other.
 Still, it is possible to trace parallels among the various techniques employed,
 since the fundamental problems that they address are the same.
\layout Standard

Because of the popularity of the C\SpecialChar ~
language and the support it enjoys in
 the most popular operating systems, a considerable part of the implementations
 of foreign language interfaces are, in practice, C APIs.
 Besides, an interaction model for programming languages that has become
 especially relevant nowadays is that between statically typed compiled
 languages, such as C, and dynamically typed interpreted languages, as proposed
 by Ousterhout\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

.
 These two classes of languages have fundamentally different goals.
 Statically typed languages are usually implemented with high performance
 in mind and focus on lower level programming.
 In contrast, scripting languages tend to be implemented as interpreters
 or virtual machines, and make extensive use of high level constructs, such
 as lists and hashes, as basic types.
 These complementary features have made the two-language programming model
 popular, in which a lower level language is used for the development of
 components, which are then connected through a higher level language.
\layout Section

Objectives
\layout Standard

This work discusses the main issues involving the design of APIs for integration
 of runtime environments of scripting languages in C\SpecialChar ~
applications.
 We present the main problems faced in the interaction between code executed
 in an environment with inherently dynamic characteristics such as that
 from a scripting language with C\SpecialChar ~
code.
 Besides being currently the most popular class of languges for multi-language
 development, typical features of scripting languages such as garbage collection
 and dynamic typing illustrate well the problems that arise in the communication
 between different programming environment, since these features are absent
 in\SpecialChar ~
C.
 Languages with static typic may present similar needs for type conversion,
 but the problem tends to be simplified by the definition of equivalent
 types in the API and compile-time inference (as can be observed in the
 C APIs for Ada and Fortran).
 Functional languages have additional concerns related to side effects in
 C code, but this is equivalent to the paradigm break problem caused by
 the handling of I/O commonly faced by those languages.
\layout Standard

This study consists of two parts.
 In the first part, we performed an in-depth analysis of a set of C\SpecialChar ~
APIs
 provided by four scripting languages -- namely, Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06ref}

\end_inset 

, Perl\SpecialChar ~

\begin_inset LatexCommand \cite{wall00perl}

\end_inset 

, Ruby\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

, Lua\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 -- as well as the API provided by the Java language\SpecialChar ~

\begin_inset LatexCommand \cite{gosling00java}

\end_inset 

.
 Unlike the others, Java uses static typing, but like them it is based on
 a virtual machine model, features automatic memory management and allows
 dynamic loading of code.
 This allows us to observe how typing affects the design of the API.
\layout Standard

In the second part, we illustrate the differences of the APIs of those langages
 and the impact of those in the resulting code of a C application through
 a case study.
 We performed a comparison between the scripting language APIs through a
 concrete example, in order to present implementations in each of the studied
 languages side by side.
 The example consists of a generic scripting library, called LibScript,
 and a series of plugins that interface to the different languages.
 This way, the code of each plugin allows us to observe in a clear and isolated
 way the procedures used in each language for function calls, registration
 of C\SpecialChar ~
functions and data conversion between environments.
 
\layout Section

Text structure
\layout Standard

This work is structured as follows.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Interação-entre-linguagens}

\end_inset 

, we discuss the various approaches for interaction between code written
 in different programming languages.
 Starting from an overview, the focus will then concentrate on the most
 commonly used foreign language interface: interfaces with the C\SpecialChar ~
language.
 We will discuss the problems commonly presented in the communication with
 C code and the programming models that appeared with its popularization
 in the integration with scripting languages.
 In Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:APIs-de-Máquinas}

\end_inset 

, we present in detail C\SpecialChar ~
APIs for a set of scripting languages.
 When discussing these interfaces, the different solutions employed for
 the main problems involving interaction between C and dynamic environments
 are brought up.
 Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

 exercises these APIs through a case study: a plugin-based library that
 offers a simplified, uniform interface for scripting languages.
 By examining the implementation of each plugin, we can compare the APIs
 for each language performing equivalent operations.
 Finally, in Chapter\SpecialChar ~

\begin_inset LatexCommand \ref{cha:Considerações-Finais}

\end_inset 

 the conclusions reached through this work are presented, as well as possible
 directions for future work.
\layout Chapter


\begin_inset LatexCommand \label{cha:Interação-entre-linguagens}

\end_inset 

Interaction between programming languages
\layout Standard

The approaches applied to the interaction of different programming languages
 vary considerably, but it is possible to identify some of the more typical
 techniques: language translation, from one language to the other or of
 both to a third; communication through an intermediate protocol or language;
 sharing a common execution environment, be it a virtual machine or through
 call conventions; and foreign language interfaces.
\layout Section

Code translation
\layout Standard

Allowing the use of two languages in a program through the translation of
 the code of one of them to the other minimizes the problem of communication
 between the parts of program written in different languages, since the
 final program will use a single data space.
 On the other hand, by having to describe a language in terms of the other,
 the semantic differences of their constructs may become a problem.
 If the target language does not have constructs offered by the source language,
 simulating them may be costly.
\layout Standard

A typical example of this problem is the complexity added by the simulation
 of higher-order functions and tail recursion when translating code from
 functional languages to one that does not have those features.
 Tarditi et al.\SpecialChar ~

\begin_inset LatexCommand \cite{tarditi92mlc}

\end_inset 

 describe the development of a translator of Standard ML to ANSI C.
 Their measurements have exposed the cost of adapting the features of ML
 to C, resulting in code that is in average 2 times slower than the that
 generated by the native ML compiler.
 In 
\begin_inset LatexCommand \cite{tolmach98mlada}

\end_inset 

, similar challenges are discussed in the translation of ML to Ada: in the
 adopted approach, the process has an intermediate step where the higher-order
 constructs are 
\begin_inset Quotes eld
\end_inset 

flattened
\begin_inset Quotes erd
\end_inset 

 to first-order constructs using records, so that they could be represented
 in Ada.
\layout Standard

Besides problems such as this, differences in the representation of data
 is also something to be handled when translating one language to another.
 In the particular case of\SpecialChar ~
C, its lower-level facilities for memory manipulation
 allow the description of data structures for higher-level languages without
 too much trouble.
 This makes\SpecialChar ~
C a frequent candidate for use as a portable low-level representation
 of code.
 The Glasgow Haskell Compiler offers, as an alternative to the generation
 of native code, generation of C code for use with GCC\SpecialChar ~

\begin_inset LatexCommand \cite{jones93glasgow}

\end_inset 

.
 One of the advantages of this feature is to allow the bootstrapping of
 the compiler in new architecture, given that GHC itself is written in Haskell.
 In fact, the ubiquity of C compilers has prompted the use of this language
 as a 
\emph on 
lingua franca
\emph default 
 between different languages, as we will see in Section\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Linguagens-intermediárias}

\end_inset 

.
\layout Section

Sharing virtual machines
\layout Standard

Another approach for the interaction between languages involves the use
 of a common execution environment, such as a virtual machine.
 The code of different languages is compiled to produce compatible representatio
ns, according to the data types provided by the execution environment.
 Many implementations use the Java Virtual Machine\SpecialChar ~

\begin_inset LatexCommand \cite{lindholm99jvm}

\end_inset 

 for this end.
 Jython\SpecialChar ~

\begin_inset LatexCommand \cite{hugunin97python}

\end_inset 

 is an implementation of the Python language that produces Java bytecodes.
 SMLj\SpecialChar ~

\begin_inset LatexCommand \cite{benton99interlanguage}

\end_inset 

 is a Standard ML compiler that generates Java bytecodes and provides access
 to Java classes and methods to ML structures and vice versa.
 The fact that the Java Virtual Machine was not designed to support different
 programming languages, however, shows in the limitations presented by these
 projects.
 SMLj defines extensions to the ML language to allow access to constructs
 that are specific to Java; Jython poses limitations to the interface between
 Python and the Java APIs for reflection and dynamic class loading.
 Besides, the instruction set of the virtual machine focuses on operations
 that match Java's semantics, which makes, for example, the implementation
 of arrays with different semantics less efficient.
\layout Standard

The .NET Framework\SpecialChar ~

\begin_inset LatexCommand \cite{box02net}

\end_inset 

 is a runtime environment based on virtual machine that is being presented
 by Microsoft as their programming platform of choice in Windows system.
 Although the C#\SpecialChar ~
language 
\begin_inset LatexCommand \cite{csharp06spec}

\end_inset 

 has been introduced specifically for it, this environment has as one of
 its goals multi-language support -- evidenced by the very name of its Common
 Language Runtime (CLR) -- contrasting with the limitations imposed by the
 Java enviroment to those who try to use it with other languages.
 Hovewer, adaptations to the languages remain necessary in the .NET environment:
 the .NET version of Visual Basic includes changes to the language to make
 its semantics match those from C#; a new dialect of C++, C++/CLI, was introduce
d adapting its memory management model to that from the CLR\SpecialChar ~

\begin_inset LatexCommand \cite{cppcli05spec}

\end_inset 

; similarly, a new dialect of ML called F# was developed, to, among other
 reasons, provide better integration with .NET components written in other
 languages\SpecialChar ~

\begin_inset LatexCommand \cite{syme06fsharp}

\end_inset 

.
\layout Standard

Another implementation of a virtual machine for multiple languagens is being
 pursued by the Parrot project\SpecialChar ~

\begin_inset LatexCommand \cite{randal04perl6}

\end_inset 

.
 The scope of this project is narrower, aiming to serve as a common back-end
 for dynamic languages such as Perl and Python.
 The focus of the project, however, is currently on the implementation of
 Perl 6.
\layout Standard

A kind of communication that can also be considered the use of a common
 runtime environment is the communication between executables and native
 libraries through call conventions: rules for passing parameters in the
 runtime stack, use of registers and name mangling.
 This can be considered the lowest-level method method for interaction between
 code in different languages.
 Calling conventions, however, are a limited form of communication, as they
 assume data types with identical memory representation in both languages.
 Such compatibility is hardly the case, unless one of the languages explicitly
 considers this kind of interaction in its definition: the Ada standard,
 for example, requires its implementations to be compatible with the calling
 conventions of C, COBOL and Fortran\SpecialChar ~

\begin_inset LatexCommand \cite{ada95manual}

\end_inset 

.
 Likewise, C++ allows to specify functions with C-compatible linkage, through
 the 
\family typewriter 
extern "C"
\family default 
 directive.
\layout Section


\begin_inset LatexCommand \label{sub:Modelos-de-objetos}

\end_inset 

Language-independent object models
\layout Standard

Adopting a language-independent type model is another way to handle the
 issues of data interoperability between languages.
 This way, in the definition of the data for an application, their interfaces
 are described in a neutral way, typically using some language designed
 specifically for this end (an Interface Description Language, IDL), while
 the implementations are made using the specific languages.
 The CORBA (Common Object Request Broker Architecture) architecture\SpecialChar ~

\begin_inset LatexCommand \cite{omg02corba}

\end_inset 

 is one of the main examples of this model.
 The central motivation for the development of CORBA was to allow the developmen
t of distributed applications in heterogeneous environments; language heterogene
ity was one of the aspects taken into consideration.
\layout Standard

The challanges existing when designing a 
\begin_inset Quotes eld
\end_inset 

language independent
\begin_inset Quotes erd
\end_inset 

 model for data or objects, however, are similar to those in the design
 of an interface between any two languages, since this model too describes
 a type system.
 When implementing bindings for any of those object models, it is necessary
 to define a correspondence between the types defined by the model and those
 offered by the target language, and provide an API for interaction with
 the runtime environment -- in the case of CORBA, with the ORB (Object Request
 Broker).
\layout Standard

If on one hand the task may be easier since the model has been designed
 with language interaction in mind (unlike, for example, the C\SpecialChar ~
type system),
 on the other one would usually expect a higher level of transparency in
 the representation of data.
 For example, while in an application intergrating\SpecialChar ~
C++ and Python the distinction
 between C++\SpecialChar ~
objects and Python objects is clear and the Python API defines
 the limits between these two universes, in an application developed using
 CORBA one would expect, in both languages, the manipulation of objects
 to be the same whether they were implemented in C++ or in Python.
 For that, the common solution is to use 
\emph on 
stubs
\emph default 
, objects that give a uniform native appearance to data, regardless of the
 language in which they were implemented, and in the case of distributed
 models such as CORBA, of the location of the objects in the network.
 The correspondence between the lifecycles of the stubs and that of the
 objects they represent is another factor that should be taken into account.
 In the Java bindings, for instance, this is done with the help of the language'
s own garbage collector.
 In languages such as C++ the control of references is explicit.
\layout Standard

Other higher-level approaches have been proposed for the integration of
 applications developed in multiple languages.
 Coordination languages such as Linda\SpecialChar ~

\begin_inset LatexCommand \cite{gelernter85linda}

\end_inset 

 and Opus\SpecialChar ~

\begin_inset LatexCommand \cite{chapman97opus}

\end_inset 

 define mechanisms for message passing and a restricted set of constructs
 to indicate the flow of those between agents implemented in other languages.
\layout Section


\begin_inset LatexCommand \label{sub:Linguagens-intermediárias}

\end_inset 

C as an intermediate language
\layout Standard

The wish for a universal intermediate language is an old one in the world
 of computing.
 Several proposals have surfaced through the years, from the UNCOL project\SpecialChar ~

\begin_inset LatexCommand \cite{conway58uncol}

\end_inset 

 to the languages with extensible syntax of the 70s\SpecialChar ~

\begin_inset LatexCommand \cite{metzner79extensible}

\end_inset 

 to the most recent virtual machine environments such as .NET.
 In practice, the needs that these projects aimed to fulfill are being handled
 through the years in a more pragmatic, if less than ideal, way by using
 C.
 Two reasons make C a common choice as an intermediate language.
 First, its 
\begin_inset Quotes eld
\end_inset 

medium-level
\begin_inset Quotes erd
\end_inset 

 nature, by providing at the same time hardware independence and direct
 manipulation of memory.
 Second, the large availability of C\SpecialChar ~
compilers, leveraged by the proliferation
 of Unix systems in the most varied architectures.
 So, as time went by, to offer an interface for interoperability with other
 languages gradually became synonymous with offering an interface for communicat
ion with C\SpecialChar ~
code.
 This is especially true for dynamic languages that offer features for applicati
on extensibility.
 Not surprisingly, these languages are typically implemented in C.
 
\layout Standard

The availability of C APIs provided by different languages also causes C
 to be widely used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

.
 The integration between Python and Fortran takes place through a Python
 module written in C that accesses a Fortran library, which on its turn
 exposes functions using a call convention compatible with C\SpecialChar ~

\begin_inset LatexCommand \cite{peterson01fortranpy}

\end_inset 

.
 LunaticPython\SpecialChar ~

\begin_inset LatexCommand \cite{niemeyer06lunaticpython}

\end_inset 

 offers bridges from Lua to Python and from Python to Lua, implemented through
 a pair of extension modules for each source language written in\SpecialChar ~
C.
\layout Standard

However, generic intermediate languages continue to be proposed as alternatives
 to C.
 C-
\begin_inset ERT
status Collapsed

\layout Standard

\backslash 
hspace{1pt}
\end_inset 

-\SpecialChar ~

\begin_inset LatexCommand \cite{jones99cminusminus}

\end_inset 

 is a project that attempts to overcome the limitations of C as an intermediate
 language making the memory representation of data types more explicit and
 adding support to constructs that are not easily represented in C, such
 as tail recursion.
 Recent versions of the GCC compiler suite have standardized an intermediate
 language for communication between its various back-ends and front-ends\SpecialChar ~

\begin_inset LatexCommand \cite{dvorak05gcc}

\end_inset 

.
\layout Section


\begin_inset LatexCommand \label{cha:Interfaces-com-C}

\end_inset 

Interfaces to C
\layout Standard

The C language has, nowadays, a special role in the world of programming
 languages.
 Besides being widely used in the implementation of compilers, interpreters
 and virtual machines (the main implementations of Perl, Python, Ruby and
 Lua are just some examples), it is also used in compilers as an output
 format in the generation of portable code (two notable examples are the
 GHC and SmartEiffel\SpecialChar ~

\begin_inset LatexCommand \cite{collin97smalleiffel}

\end_inset 

 compilers, which generate C from Haskell and Eiffel, respectively).
 This pravelence of C makes the C API a convenient format for a foreign
 language interface.
\layout Standard

In the vast majority of cases, the internal representation of code produced
 by compilers for other languages is not compatible with C, be it because
 of differences in call or name conventions, or because they produce code
 for execution in virtual machines.
 This way, to allow a C program to access this code, the language has to
 expose a library of C functions that will perform the necessary translations.
 In virtual machine environments, this library is normally generic, offering
 facilities for communication with the virtual machine itself.
 For static languages, it is usually necessary to create a specific library
 to perform the conversion of calls, as it happens in interfaces that expose
 C++ libraries to C.
 An example of this is QtC\SpecialChar ~

\begin_inset LatexCommand \cite{kdebindings}

\end_inset 

, a library of C bindings to the Qt graphic toolkit, which is implemented
 in C++.
\layout Standard

For non-imperative languages, there is still the problem of C code potentially
 generating side effects.
 Some feature for isolating calls has to be offered.
 In GHC, the construction for C calls, 
\family typewriter 
_ccall_
\family default 
, is defined in the IO monad; in the addendum for the Haskell 98 standard,
 the 
\family typewriter 
ccall
\family default 
 directive was integrated, but the use of the monad is optional, requiring
 the programmer to ensure that the functions that use it are not pure
\begin_inset Foot
collapsed true

\layout Standard

A number of additional convention calls are defined (
\family typewriter 
stdcall
\family default 
, 
\family typewriter 
cplusplus
\family default 
, 
\family typewriter 
jvm
\family default 
, 
\family typewriter 
dotnet
\family default 
), but 
\family typewriter 
ccall
\family default 
 is the only one declared mandatory by the document.
\end_inset 

.
\layout Standard

Another possible source of incompatibility between languages that has to
 be handled when they interact is the difference between concurrency models.
 C, in particular, does not define any concurrency constructs; they are
 implemented through libraries.
 At the same time that it brings great flexibility to the language, this
 also imposes portability problems for languages that depend on the availability
 of concurrency mechanisms in C that are compatible with the models they
 use.
\layout Standard

For example, APIs between C and Java must take into account the preemptive
 multithreading model adopted by Java.
 The JNI (Java Native Interface)\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

 defines functions to control mutual exclusion between data shared between
 the two languages.
 The programmer must take care to strike a balance between time spent blocking
 the virtual machine accessing shared data and time spent copying data between
 the environments to reduce sharing.
 Another situation in which the concurrency model of the language demands
 special care when integrating with C happens in the use of co-routines
 in Lua.
 The combination of two features of Lua, cooperative multitasking with multiple
 execution stacks and the ability to alternate between calls to C and Lua
 functions in a single stack, brings a limitation: a co-routine cannot execute
 a 
\emph on 
yield
\emph default 
 operation in case there is a C function in its stack, as there is no portable
 way to alternate between multiple stacks in C\SpecialChar ~

\begin_inset LatexCommand \cite{moura04colua}

\end_inset 

.
\layout Standard

One of the most frequent motivations in the integration with C code is the
 use of external libraries.
 Exposing a C library through the FLI for access by another language may
 incur in the registration of hundreds of functions.
 It is also usual to define data types that give to structures defined by
 the library a more native appearance, such as, for example, converting
 C functions that register callbacks into Ruby methods that accept code
 blocks as a parameter.
 These initializations and adaptations are usually defined as a bindings
 library, that serves as a bridge between the language and the C library
 encapsulating the interaction with the FLI.
\layout Standard

The patterns that arise when producing bindings are so common that they
 motivated the development of programs that attempt to automate the process.
 These bindings generators tend to work using some representation prepared
 for their use, since analyzing raw C headers may show itself to be insufficient
: for example, often the program wouldn't be able to interpret the intention
 of a construct such as 
\family typewriter 
int**
\family default 
.
 SWIG\SpecialChar ~

\begin_inset LatexCommand \cite{beazley96swig}

\end_inset 

 is a popular multi-language tool for generation of bindings for C and C++
 libraries which defines its own format for description of interfaces.
 FLIs may as well use stubs generators to save the programmer from having
 to write repetitive or non-portable C\SpecialChar ~
code.
 Java features a generator for C headeres containing prototypes for native
 methods to be implemented.
 Pyrex\SpecialChar ~

\begin_inset LatexCommand \cite{ewing06pyrex}

\end_inset 

 is a generator for C modules for Python from a syntax based on the Python
 language itself.
 Another example is toLua++\SpecialChar ~

\begin_inset LatexCommand \cite{manzur06tolua}

\end_inset 

, a tool for integrating C and C++ code to Lua, which generates stubs from
 C headers prepared for use by the program, which may contain special annotation
 to help in the conversion process.
\layout Section

Scripting languages
\layout Standard

A model for interaction between languages that has shown to be especially
 relevant nowadays is that between statically typed compiled languages,
 such as C and C++, and dynamically typed interpreted languages, such as
 Perl and Python.
 In\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout98scripting}

\end_inset 

, Ousterhout categorizes these two groups as 
\emph on 
systems programming languages
\emph default 
 and 
\emph on 
scripting languages
\emph default 
.
\layout Standard

These two categories of languages have fundamentally different goals.
 Systems programming languages emerged as an alternative to assembly in
 the development of applications, having as main features static typing,
 which eases the understanding of data structures in large systems, and
 the implemantation as compilers, due to concerns with performance.
 In contrast, scripting languages are dynamically typed and are implemented
 as interpreters or virtual machines.
 Dynamic typing and the extensive use of higher level constructs as basic
 types, such as lists and hashes, brings greater flexibility in the interaction
 between components; in static languages, the type system imposes restrictions
 to those interactions, often requiring the programmer to write adaptation
 interfaces, which makes the reuse of components harder.
\layout Standard

Ousterhouts points out that, in a model integrating these two kinds of languages
, the tendency is that systems programming languages will no longer be used
 to write whole applications, but will instead be used in the implementation
 of components, which are then connected through code written with scripting
 languages.
 The convenience offered by high-level interpreted languages allows rapid
 prototyping and encourages the reuse of components.
\layout Standard

The integration of programs developed in systems programming languages coordinat
ed through scripting languages has been common practice for a long time
 now.
 Shell scripting in Unix systems is probably the most notable example, where
 constructs such as pipes (which connect the output of a process to the
 input of another one) allow one to perform tasks combining a series of
 programs implemented in different languages, or even other scripts.
 With the introduction of Tcl\SpecialChar ~

\begin_inset LatexCommand \cite{ousterhout94tcl}

\end_inset 

, this kind of coordination of components through scripting languages started
 to take place 
\emph on 
within
\emph default 
 applications.
 In this model, the scripting language is implemented as a library and is
 embedded in an application written in a lower-level language, such as C.
 Data structures of the application are exposed to the scripting environment
 as objects; conversely, the application can launch functions in the scripting
 language and access its data.
 Programmable applications have existed long before that, typically using
 little languages created specifically for each application, but the concept
 introduced by Tcl of implementing scripting languages as C libraries has
 propelled strongly the development of extensible applications.
\layout Standard

The development model based in two languages does not limit itself to applicatio
ns that provide customization through scripts written by the end-user.
 In many scenarios, there is a clear distinction between a lower-level layer
 where performance is a critical factor and a higher-level layer comprised
 by coordination operations between elements of the lower layer.
 Typical examples are graphic applications where the interface is described
 by scripting languages controlling components implemented in C and games
 where the logic is described in scripts and the rendering engine is implemented
 in lower-level languages.
 This greater prominence of scripting languages, where they stop being just
 an application extension mechanism and start having a more central role
 in the coordination of the execution of the program, has also promoted
 an inverted model of interaction between languages, where the application
 itself is written using the scripting language and libraries written in
 lower-level languages are loaded as extension modules.
\layout Chapter


\begin_inset LatexCommand \label{cha:APIs-de-Máquinas}

\end_inset 

Scripting language APIs
\layout Standard

Interfaces provided by scripting languages are usually understood as 
\begin_inset Quotes eld
\end_inset 

extension APIs
\begin_inset Quotes erd
\end_inset 

: they extend the virtual machine with features not originally offered by
 it, or alternatively, they extend an external application with the features
 offered by the runtime environment of the language, embedding it to the
 application.
 The first scenario is the one used in the programming model where the high-leve
l coordination is made by an interpreted language and modules written in
 languages such as C and C++ are used to access external libraries or to
 implement performance-critical parts.
 The second scenario, in general, will also encompass the first one, when
 exposing to the embedded virtual machine extensions that will allow it
 to talk to the host application.
\layout Standard

Both scenarios involve the same general problems: data transfer between
 the two languages, including how to allow the scripting language to manipulate
 structures declared in C and vice-versa; handling the difference between
 the memory management models, more specifically the interaction between
 garbage collection in the virtual machine and explicit deallocation in
 C; calling functions declared by the scripting language from C; and the
 registration of C functions so that they can be invoked by scripts.
 The following sections discuss the main issues involved in the communication
 between C code and scripting languages, and present the approaches employed
 by the Python, Ruby, Java, Lua and Perl APIs when handling these issues.
 Each section concludes with a comparison where the different designs presented
 in the exposition of each language are reviewed side by side and thus put
 into perspective.
\layout Section

Data transfer
\begin_inset LatexCommand \label{sec:Dados}

\end_inset 


\layout Standard

The main complexity in the interaction between programming languages is
 not the differences in syntax or semantics from their control flow structures,
 but in their data representations.
 In the communication between code written in two different languages, data
 flow in various forms: as parameters, object attributes, elements in data
 structures, etc.
\layout Standard

Often, the format how these data are represented differ.
 In those cases, there are three alternatives to perform data transfer between
 the languages.
 The simplest is to expose the data to the target language as an opaque
 entity.
 The target language receives only some kind of handle that allows it to
 identify the datum uniquely in operations requested later.
 This approach is useful, for example, if a language is just storing data
 for the other one, in order to make use of higher-level data structures
 offered by the language.
\layout Standard

Another approach involves perform some conversion to the data from the type
 system of one language to that of the other.
 The duplication that takes place in this conversion limits the applicability
 of this method, restricting its use typically to numeric types and, in
 minor scale, strings.
 Finally, the source language may explicitly offer facilities in the target
 language to manipulate these data, that is, one language would offer an
 API for the other.
 The difference between this approach and the first one is that, while in
 the former the contents of the data remain opaque, here the API defines
 some means to manipulate their contents.
\layout Standard

Because of its focus on the manipulation of pointers and structures, C provides
 a small set of basic types.
 Besides, C is very liberal with regard to the internal representation of
 its structured types, with each different platform having to define its
 own application binary interface (ABI).
 So, even in cases where it is possible to link C code directly using compatible
 basic types and appropriate calling conventions (such as in Free Pascal
 or several Fortran compilers), bindings libraries are still usually needed
 to make the manipulation of complex types more convenient.
\layout Standard

Even in the fundamental numeric types, there are several precautions that
 must be taken.
 Some languages, like Smalltalk and Ruby, perform automatic conversion of
 integers to 
\begin_inset Quotes eld
\end_inset 

big integers
\begin_inset Quotes erd
\end_inset 

 (
\emph on 
bignums
\emph default 
).
 In Ruby, in particular, primitive integers have 1 bit less of precision
 than the machine's word size.
 There may also be the need to handle conversion of endianness and format
 of floating point numbers.
\layout Standard

For types such as strings, the size of values brings also concerns with
 performance.
 In many cases the internal representation used for strings is the same
 as used in C, so an option is to simply pass to the C code a pointer to
 the address where the string is stored, which avoids copying of data, under
 risk of allowing the C code to modify the contents of the string.
 Exposing to the C code pointers to memory areas within the runtime environment
 of the other language may also bring concurrency problems, in case the
 environment uses multiple threads.
\layout Standard

When exposing to the C code data of structured types, the conversion to
 a native C type, in many cases, is not an option.
 Besides the issue of quantity of data to be converted, structured types
 in C are defined statically, therefore not serving to represent conveniently
 data of dynamic structures, such as objects that may gain or lose attributes
 or even change class during runtime.
 Even in languages with static types, like Java, the copy of objects is
 not usually an interesting option due to the volume of data.
 The copy of structured objects tends to be restricted to specific operations
 like the manipulation of arrays of primitive types.
\layout Standard

The alternative to allow C code to operate over structured data, thus, is
 to provide to it an API that exposes as functions the operations defined
 over those types.
 This also avoids the need to control the consistency between two copies
 of a given structure.
 Consistency problems, however, may occur if the API allows the C code to
 store pointers to objects from the language -- this makes it necessary
 for the programmer to manage explicitly the synchronicity between pointers
 and the lifecycles of objects that may be subject to garbage collection.
 Section\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

 discusses this issue in greater detail.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Dados-Python}

\end_inset 


\layout Standard

All values in the Python virtual machine are represented as objects, mapped
 to the C API as the 
\family typewriter 
PyObject
\family default 
\SpecialChar ~
structure 
\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 More specific types such as 
\family typewriter 
PyStringObject
\family default 
, 
\family typewriter 
PyBooleanObject
\family default 
 and 
\family typewriter 
PyListObject
\family default 
 are 
\family typewriter 
PyObject
\family default 
s by structural equivalence, that is, they can be converted through a C
 cast.
 Reflecting the dynamic typing model of Python, the API functions use 
\family typewriter 
PyObject*
\family default 
 as a type every time they refer to Python objects, even when they are designed
 to act on Python values of more specific types, such as for example the
 
\family typewriter 
PyString_Size
\family default 
, that returns the length of a string.
 Each specific type has a verification function in the API, such as 
\family typewriter 
PyNumber_Check
\family default 
 and 
\family typewriter 
PyDict_Check
\family default 
.
\layout Standard

Python is a strongly typed language: each object is tied to a type.
 Types are represented by 
\family typewriter 
PyTypeObject
\family default 
 structures, which are also structurally equivalent to 
\family typewriter 
PyObject
\family default 
.
 Each Python type has a predefined 
\family typewriter 
PyTypeObject
\family default 
 in the API, such as 
\family typewriter 
PyString_Type
\family default 
, 
\family typewriter 
PyBoolean_Type
\family default 
 and 
\family typewriter 
PyList_Type
\family default 
.
 
\family typewriter 
PyObject_TypeCheck
\family default 
 compares the type of a 
\family typewriter 
PyObject
\family default 
 to a 
\family typewriter 
PyTypeObject
\family default 
 passed as an argument.
\layout Standard

For the conversion of data from C to Python, the language offers a series
 of functions that receive values of primitive C types as an argument, such
 as 
\family typewriter 
PyString_FromString\SpecialChar \-
AndSize
\family default 
 and 
\family typewriter 
PyFloat_FromDouble
\family default 
.
 Each of those functions returns to the C code a pointer to a new 
\family typewriter 
PyObject
\family default 
.
 Strings passed are copied by Python.
 The following example illustrates the creation of a Python object through
 the conversion of a C value:
\layout LyX-Code


\size footnotesize 
PyObject* s = PyString_FromString("hello");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The two examples below are equivalent, and illustrate the verification of
 a type through the API, first through a convenience function, and then
 explicitly, comparing the type of a string Python with 
\family typewriter 
PyString_Type
\family default 
:
\layout LyX-Code


\size footnotesize 
if (PyString_Check(s)) printf("Yes.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
if (PyObject_TypeCheck(s, PyString_Type)) printf("Yes.
\backslash 
n");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For returning data from Python to C, a complementary set of functions is
 offered, mapping the basic types of Python back to C types.
 Some examples of those functions that take a 
\family typewriter 
PyObject
\family default 
 pointer as an argument and return the correspondent C datum are 
\family typewriter 
PyLong_\SpecialChar \-
AsUnsignedLong
\family default 
 and 
\family typewriter 
PyString_\SpecialChar \-
AsStringAndSize
\family default 
.
 Differently from the input functions, in these output functions no string
 copying takes place: the strings returned are pointers to memory stored
 internally by Python.
 The documentation recommends not to modify the content of the string except
 if the memory area was returned by a call to 
\family typewriter 
PyString_\SpecialChar \-
FromStringAndSize(NULL, 
\family default 
\emph on 
size
\family typewriter 
\emph default 
)
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
 This way, it is possible to allocate a string for storage in Python and
 fill its contents later through C code, as in the following example:
\layout LyX-Code


\size footnotesize 
\emph on 
/* allocating an uninitialized string in Python */
\layout LyX-Code


\size footnotesize 
PyObject* obj = PyString_FromStringAndSize(NULL, 51);
\layout LyX-Code


\size footnotesize 
\emph on 
/* obtaining the pointer to the string memory area */
\layout LyX-Code


\size footnotesize 
char* s = PyString_AsString(obj);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Now, we can fill the string in C.
 An example: */
\layout LyX-Code


\size footnotesize 
for (int i = 0; i < 5; i++, s+=10)
\layout LyX-Code


\size footnotesize 
   snprintf(s, 11, "[%-8d]", random());
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

For some of its basic types that do not have direct correspondence in ANSI
 C 89, Python defines equivalent C types: 
\family typewriter 
Py_UNICODE
\family default 
 and 
\family typewriter 
Py_complex
\family default 
.
 These types were added in order to expose the internal representation of
 data used by Python in numeric manipulation and Unicode text modules implemente
d in C, avoiding frequent conversions to and from 
\family typewriter 
PyObject
\family default 
.
 
\layout Standard

Python also offers some versions of its C conversion functions as macros
 without type checking, assuming that the given 
\family typewriter 
PyObject
\family default 
 will be compatible, offering better performance in expense of safety.
 These functions can be identified by their uppercase names.
 Among the conversion macros provided are 
\family typewriter 
PyString_\SpecialChar \-
AS_STRING
\family default 
, 
\family typewriter 
PyInt_\SpecialChar \-
AS_LONG
\family default 
 and 
\family typewriter 
PyUnicode_\SpecialChar \-
AS_\SpecialChar \-
UNICODE
\family default 
.
\layout Standard

Besides functions for type conversions between Python and C, the Python
 API also offers some conversion functions between Python types.
 These functions receive a 
\family typewriter 
PyObject
\family default 
 as an argument and return a new 
\family typewriter 
PyObject
\family default 
 with the result of the conversion, and are equivalent to Python functions
 that perform these conversions (actually calls to 
\family typewriter 
PyTypeObject
\family default 
 types that answer to the 
\family typewriter 
__call__
\family default 
 method).
 For example, the 
\family typewriter 
PyObject_Str
\family default 
 function is equivalent to the Python function 
\family typewriter 
str
\family default 
.
\layout Standard

In Python, objects are stored in modules, which are namespaces declared
 globally, or as attributes of objects.
 Variables are stored in an 
\emph on 
environment
\emph default 
, represented as a dictionary.
 Functions such as 
\family typewriter 
PyRun_File
\family default 
 receive, among their parameters, a dictionary of global variables and another
 of local variables.
 The set of global variables and functions is represented as the dictionary
 of the 
\family typewriter 
__main__
\family default 
 module.
 Built-in objects are accessible through the 
\family typewriter 
__builtin__
\family default 
 module.
 For example, to obtain the 
\family typewriter 
str
\family default 
 object, we will initially obtain a reference to the 
\family typewriter 
__builtin__
\family default 
 module using the 
\family typewriter 
PyImport_AddModule
\family default 
 function and then the module's dictionary with the 
\family typewriter 
PyModule_GetDict
\family default 
 function.
\layout LyX-Code


\size footnotesize 
PyObject* builtins_module = PyImport_AddModule("__builtin__");
\layout LyX-Code


\size footnotesize 
PyObject* builtins = PyModule_GetDict(builtins_module);
\layout LyX-Code


\size footnotesize 
PyObject* str = PyDict_GetItemString(builtins, "str");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Python, 
\family typewriter 
str
\family default 
 é um objeto chamável, que atua como a função de conversão para strings.
 Assim, uma vez que obtivemos uma referência para o 
\family typewriter 
PyObject
\family default 
 correspondente a 
\family typewriter 
str
\family default 
, a chamada seguinte equivale a chamar 
\family typewriter 
PyObject_Str
\family default 
 sobre um objeto Python qualquer 
\family typewriter 
obj
\family default 
:
\layout Standard

In Python, 
\family typewriter 
str
\family default 
 is a callable object, which acts as the string conversion function.
 So, once we obtained a reference to the PyObject equivalent to 
\family typewriter 
str
\family default 
, the following call is the same as calling 
\family typewriter 
PyObject_Str
\family default 
 on a given Python object 
\family typewriter 
obj
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* This is a vararg function that receives as additional arguments a
\layout LyX-Code


\size footnotesize 
\emph on 
   NULL-terminated list with PyObjects to be passed to the Python function
\layout LyX-Code


\size footnotesize 
\emph on 
   given in the first argument.
 */
\layout LyX-Code


\size footnotesize 
PyObject* result = PyObject_CallFunctionObjArgs(str, obj, NULL);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The storage of C data in the Python object space can be done in two ways.
 One way is to create an object of the 
\family typewriter 
CObject
\family default 
 type encapsulating a C pointer, building this way a value that will be
 opaque to Python.
 The allocation functions for objects of this type allow to associate to
 the datum a C function to be called when the 
\family typewriter 
CObject
\family default 
 is deallocated.
 According to the Python documentation, 
\family typewriter 
CObjects
\family default 
 have as their main goal to allow the passing of C data between extension
 modules\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06api}

\end_inset 

.
\layout Standard

The other way is to declare new Python types through C structures.
 In C, a Python type is described in two parts: a struct type, from which
 instances of the type will be produced, and an instance of the 
\family typewriter 
PyTypeObject
\family default 
 struct, which will describe the type to Python.
 The following example illustrates the creating of a new Python type in
 C.
 Initially, we have point, which will be the C type of the instances of
 objects:
\layout LyX-Code


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD
\layout LyX-Code


\size footnotesize 
   int x, y; 
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The 
\family typewriter 
PyObject_HEAD
\family default 
 macro ensures structural equivalence with 
\family typewriter 
PyObject
\family default 
.
 When functions return the object to C code as a 
\family typewriter 
PyObject*
\family default 
, this will be able to be converted back to 
\family typewriter 
point
\family default 
 through a cast, giving then access to the 
\family typewriter 
x
\family default 
 and 
\family typewriter 
y
\family default 
 attributes.
 We will also define a function that operates on objects of this type:
\layout LyX-Code


\size footnotesize 
PyObject* point_distance(point* p) {
\layout LyX-Code


\size footnotesize 
    return PyFloat_FromDouble( sqrt(p->x*p->x + p->y*p->y) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The function is defined with a 
\family typewriter 
PyObject
\family default 
* return type so that it can be registered in the Python virtual machine.
 To associate the function to the Python type, we will initially store it
 in an array of 
\family typewriter 
PyMethodDef
\family default 
 structures, which will lits the type's methods:
\layout LyX-Code


\size footnotesize 
static PyMethodDef point_methods[] = {
\layout LyX-Code


\size footnotesize 
   { "distance", (PyCFunction) point_distance, METH_NOARGS },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

To make the attributes of the type are visible from Python, we will have
 to implement an access routine, that receives the object and the name of
 the accessed attribute.
 Its implementation is given below:
\layout LyX-Code


\size footnotesize 
PyObject* point_getattr(PyObject* self, char* name) {
\layout LyX-Code


\size footnotesize 
   if (strcmp(name, "x") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->x);
\layout LyX-Code


\size footnotesize 
   else if (strcmp(name, "y") == 0)
\layout LyX-Code


\size footnotesize 
      return PyInt_FromLong(((point*)self)->y);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      return Py_FindMethod(point_methods, self, name); 
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Once it is registered in the type description, this function will be responsible
 for returning the type's attributes and methods.
 This way, we can expose to the Python environment attributes stored in
 the C struct.
 The 
\family typewriter 
Py_FindMethod
\family default 
 function locates a function in the array given as its parameter and returns
 it as a method
\begin_inset Foot
collapsed false

\layout Standard

Registration of Python functions will be discussed in detail in Section
 \SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

Finally, we will define 
\family typewriter 
point_type
\family default 
, which will be the 
\family typewriter 
PyTypeObject
\family default 
 that will describe the Python type relative to 
\family typewriter 
point
\family default 

\begin_inset Foot
collapsed false

\layout Standard

For brevity, we will present the example using the C99 syntax for structs,
 saving us from listing the elements that will be initialized with 
\family typewriter 
NULL
\family default 
, as the 
\family typewriter 
PyTypeObject
\family default 
 struct has 54 fields in total.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
static PyTypeObject point_type = {
\layout LyX-Code


\size footnotesize 
   PyObject_HEAD_INIT(NULL)
\layout LyX-Code


\size footnotesize 
   .tp_name = "point",             
\emph on 
/* The name of the class */
\layout LyX-Code


\size footnotesize 
   .tp_basicsize = sizeof(point),  
\emph on 
/* The size of the memory area to be allocated */
\layout LyX-Code


\size footnotesize 
   .tp_getattr = point_getattr,    
\emph on 
/* The attribute access function */
\layout LyX-Code


\size footnotesize 
   .tp_flags = Py_TPFLAGS_DEFAULT  
\emph on 
/* This class does not require special treatment */
\layout LyX-Code


\size footnotesize 
};
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Again, a macro was used at the top of the definition to ensure structural
 equivalence.
 
\family typewriter 
PyTypeObject
\family default 
 has many other fields, but we will keep them 
\family typewriter 
NULL
\family default 
 so that they will be filled with default values during the construction
 of the type at runtime.
 The 
\family typewriter 
PyTypeObject
\family default 
 type contains a number of fields that allow to describe the behavior of
 the declared type.
 In the 
\family typewriter 
tp_getattr
\family default 
 field of 
\family typewriter 
point_type
\family default 
, we specified that the C function to be used to handle access to attributes
 will be 
\family typewriter 
point_getattr
\family default 
.
 We specified 
\family typewriter 
Py_TPFLAGS_DEFAULT
\family default 
 in the flags field to indicate that this is a class with a default behavior,
 without the need for special treatements such as cycle checking during
 garbage collection.
\layout Standard

While the in-memory representation of 
\family typewriter 
Python
\family default 
 objects of the user-defined type are instances of 
\family typewriter 
point
\family default 
, to create a new object it is not enough to allocate an instance of 
\family typewriter 
point
\family default 
 and use it as a 
\family typewriter 
PyObject
\family default 
 through casting.
 It is necessary to initialize the object so that it is registered in the
 garbage collection mechanism and it has the fields of its 
\family typewriter 
PyObject
\family default 
 header properly initialized.
 The allocation in C of new objects of a user-defined type must be done
 through the 
\family typewriter 
PyObject_New
\family default 
 macro, which receives as arguments the type of the struct to be allocated
 and the 
\family typewriter 
PyTypeObject
\family default 
 that corresponds to the type.
 The documentation recommends assigning the default construction function,
 
\family typewriter 
PyType_GenericNew
\family default 
, during runtime for portability reasons\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

.
 Finally, the undefined fields of the struct are filled by the 
\family typewriter 
PyType_Ready
\family default 
 function.
\layout LyX-Code


\size footnotesize 
point_type.tp_new = PyType_GenericNew;
\layout LyX-Code


\size footnotesize 
if (PyType_Ready(&point_type) < 0) return;
\layout Standard

From there on, instances can be created with 
\family typewriter 
PyObject_New
\family default 
, as in the example below:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Creates an instance */
\layout LyX-Code


\size footnotesize 
point* a_point = PyObject_New(point, &point_type);
\layout LyX-Code


\size footnotesize 
a_point->x = 100; a_point->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Stores the instance in the Python global 'P',
\layout LyX-Code


\size footnotesize 
\emph on 
   assuming the globals dictionary was stored in 'globals'.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "P", (PyObject*) a_point);
\layout Standard

Once declared in C, this value can be used by Python code:
\layout LyX-Code


\size footnotesize 
print 'P.x = ' + str(P.x)
\layout LyX-Code


\size footnotesize 
print 'P.y = ' + str(P.y)
\layout LyX-Code


\size footnotesize 
print 'd   = ' + str(P.distance())
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

The Python API has a large number of functions for manipulation of predefined
 types in the language.
 
\emph on 
Tuples
\emph default 
 deserve a special mention with regard to data transfer between Python and
 C, as they are used in several contexts: when passing arguments to Python
 functions from C, when receiving input arguments in C functions and also
 when passing and receiving multiple return values, as we will see in Sections\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

 and\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Registro}

\end_inset 

.
\layout Standard

As tuples are frequently used as a 
\begin_inset Quotes eld
\end_inset 

bridge
\begin_inset Quotes erd
\end_inset 

 between Python and C, the API offers a convenience function, 
\family typewriter 
PyArg_ParseTuple
\family default 
, that saves the programmer from having to perform access and type checking
 of the tuple elements one by one.
 This is a vararg C function that receives as arguments the tuple, a string
 indicating the types of expected arguments and the addresses where the
 values, converted to C types, should be stored.
 The function defines a syntax for expected type identifiers in the given
 string and the correspondent C types.
 For example: 
\family typewriter 
"s#"
\family default 
 indicates that the tuple should contain a Python object of the 
\family typewriter 
string
\family default 
 or 
\family typewriter 
Unicode
\family default 
 type and that two parameters should be passed to the C function, with types
 
\family typewriter 
const char**
\family default 
 and 
\family typewriter 
int*
\family default 
, that will return the string pointer and its size, respectively.
 In a more elaborate example, 
\family typewriter 
"iiO!|(dd)"
\family default 
 indicates that the function expects two integer addresses (
\family typewriter 
"ii"
\family default 
), followed by the address of a 
\family typewriter 
PyObject
\family default 
 pointer
\family typewriter 
\SpecialChar ~

\family default 
(
\family typewriter 
"O"
\family default 
) and a PyTypeObject to be used when type checking the received object\SpecialChar ~
(
\family typewriter 
"!"
\family default 
) and optionally\SpecialChar ~
(
\family typewriter 
"|"
\family default 
), two addresses of 
\family typewriter 
double
\family default 
 values given to Python through another tuple\SpecialChar ~
(
\family typewriter 
"(dd)"
\family default 
).
\layout Standard

In a similar fashion, the Python API has the 
\family typewriter 
Py_BuildValue
\family default 
, which allows the construction of structured objects, such as tuples, lists
 and dictionaries, in a single call.
 This function is frequently used both in the construction of the argument
 tuple when calling functions and in the construction of return values.
 The syntax of the parameter string is similar to that of 
\family typewriter 
PyArg_ParseTuple
\family default 
, but it features a different set of type indicators, and allows to describe
 lists and dictionaries.
 For example, the following call creates a list containing an integer, a
 floating point number and a dictionary containing an element with a string
 key and an integer value:
\layout LyX-Code


\size footnotesize 
PyObject* list = Py_BuildValue("[id{si}]", 123, 12.30, "foo", 1234);
\layout Standard

This is equivalent to the following Python construct:
\layout LyX-Code


\size footnotesize 
list = [123, 12.30, {"foo": 1234}]
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-dados}

\end_inset 


\layout Standard

For the communication of data between Ruby and C, the Ruby API defines a
 C data type called 
\family typewriter 
VALUE
\family default 
, which represents a Ruby object.
 
\family typewriter 
VALUE
\family default 
 may represent both a reference to an object (that is, a pointer to the
 Ruby heap) as well as an immediate value.
 In particular, the constants 
\family typewriter 
Qtrue
\family default 
, 
\family typewriter 
Qfalse
\family default 
 and 
\family typewriter 
Qnil
\family default 
 are defined as immediate values, allowing them to be compared in C using
 the 
\family typewriter 
==
\family default 
 operator.
\layout Standard

Para a verificação de tipos, Ruby disponibiliza as macros 
\family typewriter 
Check_Type
\family default 
 e 
\family typewriter 
TYPE
\family default 
.
 
\family typewriter 
Check_Type
\family default 
 permite comparar o tipo de valores a constantes que descrevem os tipos
 básicos de Ruby como 
\family typewriter 
T_OBJECT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
.
 
\family typewriter 
TYPE
\family default 
 retorna a constante relativa ao tipo de um valor passado.
 Para a verificação da classe de um objeto, devemos usar 
\family typewriter 
rb_class_of
\family default 
.
\layout Standard

Para a transferência de valores numéricos, a conversão entre C e Ruby é
 feita através de macros como 
\family typewriter 
INT2NUM
\family default 
 e de funções como 
\family typewriter 
rb_float_new
\family default 
, que recebem ou retornam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard

Para a passagem de strings para Ruby a partir de C, são oferecidas as funções
 
\family typewriter 
rb_str_new
\family default 
, que recebe um ponteiro e um argumento numérico de tamanho, de modo a permitir
 a passagem de strings contendo caracteres nulos, e 
\family typewriter 
rb_str_new2
\family default 
, que assume uma string padrão de C, com o caracter nulo como terminador.
 Estas funções fazem uma cópia da string C para o espaço de Ruby.

\family typewriter 
 VALUE
\family default 
s que apontam para strings de Ruby permitem acessar e alterar o seu conteúdo
 através do 
\emph on 
cast
\emph default 
 
\family typewriter 
RSTRING(uma_string)->ptr
\family default 
.
 Todavia, a API recomenda o uso da macro 
\family typewriter 
StringValue
\family default 
, que retorna o próprio 
\family typewriter 
VALUE
\family default 
 passado caso este seja uma string, ou um novo 
\family typewriter 
VALUE
\family default 
 da classe 
\family typewriter 
String
\family default 
 produzido através do método de conversão 
\family typewriter 
to_s
\family default 
 aplicado ao objeto passado (ou ainda causa uma exceção 
\family typewriter 
TypeError
\family default 
 caso a conversão não seja possível).
\layout LyX-Code


\size footnotesize 
void mostra_valor(VALUE obj) {
\layout LyX-Code


\size footnotesize 
   const char* s;
\layout LyX-Code


\size footnotesize 
   if (TYPE(obj) == T_STRING) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Faria um acesso ilegal se TYPE(obj) != T_STRING */
\layout LyX-Code


\size footnotesize 
      s = RSTRING(obj)->ptr;
\layout LyX-Code


\size footnotesize 
   } else {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Funciona para qualquer tipo que aceite obj.to_s,
\layout LyX-Code


\size footnotesize 
\emph on 
         dispara uma exceção em caso contrário */
\layout LyX-Code


\size footnotesize 
      s = StringValue(obj);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   printf("Valor: %s
\backslash 
n", s);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Sob a justificativa de aumentar o desempenho no acesso, alguns outros tipos
 de Ruby como 
\family typewriter 
Array
\family default 
, 
\family typewriter 
Hash
\family default 
 e 
\family typewriter 
File
\family default 
 permitem acesso de baixo nível aos membros das estruturas utilizadas na
 implementação dos objetos.
 Por exemplo, 
\family typewriter 
RARRAY(um_array)->len
\family default 
 permite ler o tamanho de um array diretamente.
 A recomendação da API é utilizar este tipo de acesso somente para leitura,
 já que a alteração destes valores pode facilmente tornar o estado interno
 dos objetos inconsistente.
\layout Standard

Para o armazenamento de dados de C no espaço de objetos de Ruby, a API oferece
 uma macro, 
\family typewriter 
Data_Wrap_Struct
\family default 
, que recebe um ponteiro C e cria um objeto Ruby que encapsula este ponteiro.
 O ponteiro pode ser acessado a partir de código C usando 
\family typewriter 
Data_Get_Struct
\family default 
, mas não a partir de Ruby.
 Em 
\family typewriter 
Data_Wrap_Struct
\family default 
 é passada também uma função C a ser executada quando o objeto for coletado.
 Por exemplo, criemos uma classe 
\family typewriter 
Point
\family default 
, similar ao tipo definido em Python na seção anterior.
 Inicialmente definiremos um tipo\SpecialChar ~
C:
\layout LyX-Code


\begin_inset LatexCommand \label{struct-point}

\end_inset 


\size footnotesize 
typedef struct {
\layout LyX-Code


\size footnotesize 
   int x, y;
\layout LyX-Code


\size footnotesize 
} point;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Funções de alocação (
\family typewriter 
point_alloc
\family default 
) e desalocação (
\family typewriter 
point_free
\family default 
) para a classe 
\family typewriter 
Point
\family default 
 são dadas a seguir:
\layout LyX-Code


\size footnotesize 
void point_free(void* p) {
\layout LyX-Code


\size footnotesize 
   free(p);
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code

 
\newline 

\size footnotesize 
VALUE point_alloc(VALUE point_class) {
\layout LyX-Code


\size footnotesize 
   point* p = malloc(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O segundo corresponde à função de marcação para coleta de lixo
\layout LyX-Code


\size footnotesize 
\emph on 
      (NULL aqui pois o tipo não armazena VALUEs), cf.
 Seção 
\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

 */
\layout LyX-Code


\size footnotesize 
   return Data_Wrap_Struct(point_class, NULL, point_free, p);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que 
\family typewriter 
Data_Wrap_Struct
\family default 
 faz uso de um 
\family typewriter 
VALUE
\family default 
 que representa a classe 
\family typewriter 
Point
\family default 
 em Ruby.
 Classes são criadas em C com a função 
\family typewriter 
rb_define_class
\family default 
.
 Esta função recebe uma string C com o nome da nova classe e um 
\family typewriter 
VALUE
\family default 
 a ser usado como superclasse (como por exemplo a constante 
\family typewriter 
rb_cObject
\family default 
, que representa a classe Ruby 
\family typewriter 
Object
\family default 
) e retorna um 
\family typewriter 
VALUE
\family default 
 representando a nova classe.
 Para classes como 
\family typewriter 
Point
\family default 
, cujas instâncias irão conter dados de C, é possível registrar uma função
 C responsável por realizar a alocação de memória das instâncias usando
 a função 
\family typewriter 
rb_define_alloc_func
\family default 
.
 A criação da classe e o registro da função de alocação, então, se dão da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
VALUE point_class = rb_define_class("Point", rb_cObject);
\layout LyX-Code


\size footnotesize 
rb_define_alloc_func(point_class, point_alloc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como em código Ruby, a declaração de atributos de objetos é feita no método
 
\family typewriter 
initialize
\family default 
, que pode ser implementado em C:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize(VALUE self, VALUE x, VALUE y) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   p->x = NUM2INT(x);
\layout LyX-Code


\size footnotesize 
   p->y = NUM2INT(y);
\layout LyX-Code


\size footnotesize 
   return self;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O método é registrado na classe em tempo de execução com a função 
\family typewriter 
rb_define_method
\family default 
 (o registro de funções C em Ruby será discutido em detalhe na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize", point_initialize, 2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para que a cópia de objetos através dos métodos Ruby 
\family typewriter 
dup
\family default 
 e 
\family typewriter 
clone
\family default 
 trate corretamente os dados armazenados via C, é preciso ainda registrar
 o método 
\family typewriter 
initialize_copy
\family default 
.
 Uma possível implementação em C é dada abaixo:
\layout LyX-Code


\size footnotesize 
VALUE point_initialize_copy(VALUE copy, VALUE orig) {
\layout LyX-Code


\size footnotesize 
   point* p_copy;
\layout LyX-Code


\size footnotesize 
   point* p_orig;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Ruby pode chamar esta função com o mesmo objeto nos dois parâmetros;
\layout LyX-Code


\size footnotesize 
\emph on 
      nesse caso, ignore a chamada e retorne o objeto */
\layout LyX-Code


\size footnotesize 
   if (copy == orig) return copy;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter os ponteiros armazenados nos objetos */
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(orig, point, p_orig);
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(copy, point, p_copy);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cópia da 
\begin_inset Quotes eld
\end_inset 

parte C
\begin_inset Quotes erd
\end_inset 

 do objeto */
\layout LyX-Code


\size footnotesize 
   p_copy->x = p_orig->x;
\layout LyX-Code


\size footnotesize 
   p_copy->y = p_orig->y;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna a cópia */
\layout LyX-Code


\size footnotesize 
   return copy;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Completemos o exemplo implementando uma função C implementando o método
 
\family typewriter 
distance
\family default 
 como feito na seção anterior para Python:
\layout LyX-Code


\size footnotesize 
VALUE point_distance(VALUE self) {
\layout LyX-Code


\size footnotesize 
   point* p;
\layout LyX-Code


\size footnotesize 
   Data_Get_Struct(self, point, p);
\layout LyX-Code


\size footnotesize 
   return rb_float_new( sqrt(p->x*p->x + p->y*p->y)) ); 
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Estas funções também são registradas como métodos de 
\family typewriter 
Point
\family default 
:
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "initialize_copy", point_initialize_copy,
 1);
\layout LyX-Code


\size footnotesize 
rb_define_method(point_class, "distance", point_distance, 0);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
rb_class_new_instance
\family default 
 produz novos objetos Ruby que são instâncias da classe, recebendo um array
 C de 
\family typewriter 
VALUE
\family default 
s a ser passados na inicialização e o 
\family typewriter 
VALUE
\family default 
 da classe.
 
\layout Standard

O acesso a variáveis Ruby se dá através da família de funções 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_get
\family default 
, que retornam os 
\family typewriter 
VALUE
\family default 
s relativos a atributos de objetos ou classes, variáveis globais e constantes.
 Para cada uma destas há uma função 
\family typewriter 
rb_
\family default 
*
\family typewriter 
_set
\family default 
 análoga
\begin_inset Foot
collapsed true

\layout Standard

Constantes podem ser criadas com o valor 
\family typewriter 
Qundef
\family default 
 e terem o seu valor definido posteriormente com 
\family typewriter 
rb_const_set
\family default 
, porém uma única vez.
\end_inset 

.
 As funções 
\family typewriter 
rb_iv_get
\family default 
 e 
\family typewriter 
rb_ivar_get
\family default 
, por exemplo, obtêm atributos de objetos (
\emph on 
instance variables
\emph default 
).
 A primeira forma usa strings C como nomes, a segunda usa 
\family typewriter 
ID
\family default 
s, identificadores que substituem strings internalizadas na tabela de símbolos
 de Ruby, que podem ser obtidos usando a função 
\family typewriter 
rb_intern
\family default 
.
 De fato, 
\family typewriter 
ID
\family default 
s correspondem ao tipo 
\emph on 
símbolo
\emph default 
 de Ruby, que na prática são strings imutáveis.
 O seguinte exemplo obtém o valor de uma variável global 
\family typewriter 
x
\family default 
 e a atribui ao campo 
\family typewriter 
x
\family default 
 de um objeto, e depois altera o valor da variável global para zero:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém variável global */
\layout LyX-Code


\size footnotesize 
VALUE x = rb_gv_get("x");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui ao campo x do objeto obj */
\layout LyX-Code


\size footnotesize 
VALUE obj = rb_gv_get("obj");
\layout LyX-Code


\size footnotesize 
rb_iv_set(obj, "x", x);
\emph on 
 /* Equivale a: rb_ivar_set(obj, rb_intern("x"), x); */
\layout LyX-Code


\size footnotesize 
\emph on 
/* Zera a variável global */
\layout LyX-Code


\size footnotesize 
rb_gv_set("x", INT2NUM(0));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard


\family typewriter 
ID
\family default 
s nunca são coletados: observamos que a tabela de símbolos não é zerada
 mesmo com 
\family typewriter 
ruby_finalize
\family default 
.
 Assim, uma aplicação C que oferece uma interface para scripting criando
 ambientes supostamente isolados, com 
\family typewriter 
ruby_init
\family default 
 e 
\family typewriter 
ruby_finalize
\family default 
 cercando cada execução de script, pode ter o seu consumo de memória aumentado
 indefinidamente à medida que os scripts criam símbolos.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Dados-Java}

\end_inset 


\layout Standard

A JNI define no cabeçalho 
\family typewriter 
jni.h
\family default 
 tipos em C equivalentes a cada um dos tipos primitivos de Java (
\family typewriter 
jint
\family default 
 para 
\family typewriter 
int
\family default 
, 
\family typewriter 
jfloat
\family default 
 para 
\family typewriter 
float
\family default 
, e assim por diante).
 Os 
\begin_inset Quotes eld
\end_inset 

tipos de referências
\begin_inset Quotes erd
\end_inset 

, como classes e objetos, são expostos a C como referências opacas, instâncias
 de 
\family typewriter 
jobject
\family default 
.
 Strings e arrays também são objetos em Java e são portanto expostos como
 instâncias de
\family typewriter 
 jobject
\family default 
.
 Entretanto, a JNI define como conveniência alguns tipos em C que agem como
 
\begin_inset Quotes eld
\end_inset 

subtipos
\begin_inset Quotes erd
\end_inset 

 de 
\family typewriter 
jobject
\family default 
: 
\family typewriter 
jclass
\family default 
, 
\family typewriter 
jstring
\family default 
, 
\family typewriter 
jthrowable
\family default 
, 
\family typewriter 
jarray
\family default 
, 
\family typewriter 
jobjectArray
\family default 
, além de um tipo array para cada tipo primitivo (
\family typewriter 
jbooleanArray
\family default 
, 
\family typewriter 
jbyteArray
\family default 
, etc.).
 O tipo 
\family typewriter 
jvalue
\family default 
 é uma 
\emph on 
union
\emph default 
 dos tipos primitivos e de referências.
 O valor C 
\family typewriter 
NULL
\family default 
 equivale a 
\family typewriter 
null
\family default 
 em Java.
\layout Standard

Diferentes métodos são utilizados para a leitura de tipos primitivos, strings,
 arrays e outros objetos.
 A leitura do conteúdo de uma 
\family typewriter 
jstring
\family default 
 em C requer a conversão do formato interno usado por Java, UTF-16.
 A API oferece uma função utilitária que aloca uma string contendo a representaç
ão do texto em UTF-8 (formato compatível com ASCII), 
\family typewriter 
GetStringUTFChars
\family default 
.
 Esta string deve ser posteriormente desalocada com 
\family typewriter 
ReleaseString\SpecialChar \-
UTFChars
\family default 
.
 A função 
\family typewriter 
GetStringChars
\family default 
 permite acesso direto à string em formato UTF-16; ela possui um parâmetro
 de saída que indica se a string retornada é o 
\emph on 
buffer
\emph default 
 interno da JVM ou uma cópia.
 Ao mesmo tempo que isto permite ao código C evitar duplicação da string
 nos casos onde deseja-se modificá-la e a JVM tenha optado por retornar
 uma cópia, tal parâmetro expõe na API questões de baixo nível da gerência
 de strings na JVM.
 Alternativamente, as funções 
\family typewriter 
GetStringRegion
\family default 
 e 
\family typewriter 
GetStringUTFRegion
\family default 
 realizam a cópia da string para um buffer pré-alocado pelo programador.
 
\family typewriter 
GetStringCritical
\family default 
 permite obter o ponteiro para o buffer interno da JVM, mas isto envolve
 cuidados especiais em relação à coleta de lixo, discutidos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

.
\layout Standard

Arrays de elementos primitivos são tratados de forma similar a strings,
 diferentemente de arrays de objetos
\begin_inset Foot
collapsed true

\layout Standard

Arrays multi-dimensionais são considerados 
\begin_inset Quotes eld
\end_inset 

arrays de arrays
\begin_inset Quotes erd
\end_inset 

 e, portanto, são também arrays de objetos.
\end_inset 

.
 Há funções para realizar a cópia de arrays (
\family typewriter 
Get
\family default 
/
\family typewriter 
Set
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
\SpecialChar \-
ArrayRegion
\family default 
), funções que retornam ponteiros para o array podendo ou não realizar cópias,
 de forma similar a 
\family typewriter 
GetStringChars
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release
\family default 
\emph on 
<tipo
\emph default 
>
\family typewriter 
ArrayElements
\family default 
) e que podem acessar o buffer interno da JVM diretamente, como em 
\family typewriter 
GetStringCritical
\family default 
 (
\family typewriter 
Get
\family default 
/
\family typewriter 
Release\SpecialChar \-
PrimitiveArrayCritical
\family default 
).
 Para arrays de objetos, não é possível obter um ponteiro para o buffer
 interno do array, mas somente acessar e modificar os seus elementos um
 a um, sob forma de referências 
\family typewriter 
jobject
\family default 
, com 
\family typewriter 
Get
\family default 
/
\family typewriter 
SetObjectArrayElement
\family default 
.
\layout Standard

A obtenção de valores de atributos se dá através de métodos como 
\family typewriter 
GetObjectField
\family default 
 e 
\family typewriter 
GetStaticField
\family default 
, que retornam referências do tipo 
\family typewriter 
jobject
\family default 
.
 Para cada um dos tipos primitivos existe uma chamada equivalente, como
 
\family typewriter 
GetIntField
\family default 
 e 
\family typewriter 
GetStaticIntField
\family default 
.
 Assim como Ruby, a API de Java define um tipo\SpecialChar ~
C específico para evitar o
 uso freqüente de strings C na descrição de campos.
 Todavia, enquanto Ruby utiliza 
\family typewriter 
ID
\family default 
s que são simplesmente strings internalizadas, em Java os identificadores
 de campo, do tipo 
\family typewriter 
jfieldID
\family default 
, contêm informação de tipo e são específicos para o campo de uma determinada
 classe.
 Estes valores são obtidos com uma chamada a 
\family typewriter 
GetFieldID
\family default 
, que recebe entre seus parâmetros uma string chamada de 
\begin_inset Quotes eld
\end_inset 

descritor de campo JNI
\begin_inset Quotes erd
\end_inset 

 com uma sintaxe especial.
 Por exemplo, o tipo Java 
\family typewriter 
int[][]
\family default 
 é descrito com 
\family typewriter 
"[[I"
\family default 
 e o tipo 
\family typewriter 
java.lang.String
\family default 
 como 
\family typewriter 
"Ljava/lang/String;"
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Este é outro ponto onde detalhes da implementação transparecem na API.
 Não por coincidência, esta sintaxe é a mesma usada na representação interna
 de tipos em 
\emph on 
bytecodes
\emph default 
 da JVM.
\end_inset 

.
 É possível ainda obter um 
\family typewriter 
jfieldID
\family default 
 a partir de um objeto 
\family typewriter 
java.lang.reflect.Field
\family default 
 usando a função 
\family typewriter 
FromReflectedField
\family default 
.
\layout Standard

As chamadas à JNI têm o formato 
\family typewriter 
(*J)->
\family default 
\emph on 
função
\family typewriter 
\emph default 
(J,
\family default 
 ...
\family typewriter 
)
\family default 
: funções da JNI são acessadas através de ponteiros para função armazenados
 em uma tabela apontada pela estrutura 
\family typewriter 
JNIEnv
\family default 
, que por sua vez é propagada nas chamadas.
 O objetivo destes dois níveis de indireção é desacoplar a ligação das chamadas
 no código C e a biblioteca que implementa a JNI, permitindo ligar o código
 em tempo de execução a diferentes implementações da JVM\SpecialChar ~

\begin_inset LatexCommand \cite{stepanian05inliningjava}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
public class ExemploJNI {
\layout LyX-Code


\size footnotesize 
   private String[] elementos = { "Terra", "Ar", "Fogo", "Agua" };
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Declaração do método implementado externamente */
\layout LyX-Code


\size footnotesize 
   private native void segundoElemento();
\layout LyX-Code


\size tiny 
  
\layout LyX-Code


\size footnotesize 
   public static void main(String[] args) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Cria uma instância e invoca o método nativo */
\layout LyX-Code


\size footnotesize 
      new ExemploJNI().segundoElemento();
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Carrega o código externo na JVM que
\layout LyX-Code


\size footnotesize 
\emph on 
         implementará o método segundoElemento */
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("ExemploJNI");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Classe-Java}

\end_inset 

Classe Java contendo um método implementado externamente
\end_inset 


\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
#include "ExemploJNI.h"
\layout LyX-Code


\size tiny 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT void JNICALL
\layout LyX-Code


\size footnotesize 
Java_ExemploJNI_segundoElemento(JNIEnv* J, jobject this) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter a classe de this: ExemploJNI */
\layout LyX-Code


\size footnotesize 
   jclass classe = (*J)->GetObjectClass(J, this);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o campo ExemploJNI.elementos, de tipo String[] */
\layout LyX-Code


\size footnotesize 
   jfieldID elemsID = (*J)->GetFieldID(J, classe,
\layout LyX-Code


\size footnotesize 
      "elementos", "[Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obter o conteúdo do campo ExemploJNI.elementos */
\layout LyX-Code


\size footnotesize 
   jarray elems = (*J)->GetObjectField(J, this, elemsID);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* elems_1 = elementos[1] */
\layout LyX-Code


\size footnotesize 
   jstring elems_1 = (*J)->GetObjectArrayElement(J, elems, 1);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* obter representação de elems_1 como uma string C */
\layout LyX-Code


\size footnotesize 
   const char* elems_1_c = (*J)->GetStringUTFChars(J, elems_1, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* exibir a string */
\layout LyX-Code


\size footnotesize 
   printf("%s
\backslash 
n", elems_1_c);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* liberar memória da string */
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, elems_1, elems_1_c);
\layout LyX-Code


\size footnotesize 
}
\layout Caption


\begin_inset LatexCommand \label{cap:Acesso-JNI}

\end_inset 

Código C implementando um método Java
\end_inset 


\layout Standard

O acesso a atributos Java em código C é ilustrado através do seguinte exemplo.
 Inicialmente, na Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Classe-Java}

\end_inset 

, é implementada uma classe Java que possui um atributo privado, o array
 
\family typewriter 
elementos
\family default 
, e define uma função, 
\family typewriter 
segundoElemento
\family default 
, a ser implementada em C
\begin_inset Foot
collapsed true

\layout Standard

Os detalhes sobre a declaração e registro de funções implementadas em C
 serão discutidos na Seção 
\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

.
\end_inset 

.
\layout Standard

A implementação de 
\family typewriter 
segundoElemento
\family default 
 é mostrada na Fig.\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Acesso-JNI}

\end_inset 

, mostrando a seqüência de chamadas até obter em C o elemento do array Java.
 Para acessar o atributo 
\family typewriter 
elementos
\family default 
, a função deve obter o identificador do campo.
 Para tal, devemos inicialmente obter uma referência da classe atual com
 
\family typewriter 
GetObjectClass
\family default 
 a partir da referência ao objeto (
\family typewriter 
this
\family default 
) passada como parâmetro à função.
 De posse da referência da classe (
\family typewriter 
classe
\family default 
), obtemos o identificador do campo com 
\family typewriter 
GetFieldID
\family default 
.
 O conteúdo do campo é então obtido com 
\family typewriter 
GetObjectField
\family default 
: uma referência para o array.
 Com este, o elemento do array é obtido com 
\family typewriter 
GetObjectArrayElement
\family default 
.
 Uma cópia do elemento, convertido para uma string C codificada em UTF-8,
 é retornada com 
\family typewriter 
GetStringUTFChars
\family default 
.
 Como discutido anteriormente, após o uso, a string deve ser liberada com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard

A manipulação de objetos do tipo 
\family typewriter 
Class
\family default 
 também é feita através de funções específicas.
 Não é possível criar classes Java através da API C, mas é possível carregar
 classes em tempo de execução usando a função 
\family typewriter 
DefineClass
\family default 
, que recebe um buffer contendo a representação de uma classe Java pré-compilada.
 Referências do tipo 
\family typewriter 
jclass
\family default 
 podem ser obtidas através do nome da classe usando 
\family typewriter 
FindClass
\family default 
, que utiliza uma sintaxe de descritores de classe similar à de descritor
 de campos usada por 
\family typewriter 
GetFieldID
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Tanto em descritores de classe como de campo, 
\family typewriter 
"[Ljava/lang/String;"
\family default 
 representam 
\family typewriter 
String[]
\family default 
.
 Para o tipo 
\family typewriter 
String
\family default 
, entretanto, 
\family typewriter 
"Ljava/lang/String;"
\family default 
 é o descritor de campo e 
\family typewriter 
"java/lang/String"
\family default 
 o de classe.
\end_inset 

.
\layout Standard

Para a atribuição de valores de C que podem ser convertidos para tipos primitivo
s de Java, a JNI possui funções como 
\family typewriter 
SetIntField
\family default 
 e 
\family typewriter 
SetFloatArrayRegion
\family default 
.
 Para os demais tipos, não há uma provisão específica para o armazenamento
 de dados de C no espaço de objetos de Java.
 Nestes casos, a documentação sugere o armazenamento de ponteiros em tipos
 numéricos\SpecialChar ~

\begin_inset LatexCommand \cite{liang99jni}

\end_inset 

, apesar dos problemas de portabilidade em que tal abordagem incorre.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-dados}

\end_inset 


\layout Standard

A API de Lua define uma abordagem diferente para a manipulação de dados
 em C: não são expostos ao código C ponteiros ou 
\emph on 
handles
\emph default 
 para objetos Lua.
 As operações são definidas em termos de índices de uma pilha virtual.
 Assim, a transferência de dados de C para Lua se dá através de funções
 que recebem tipos de C, os convertem para valores Lua e os empilham, como
 
\family typewriter 
lua_pushboolean
\family default 
, 
\family typewriter 
lua_pushinteger
\family default 
 e 
\family typewriter 
lua_pushlstring
\family default 
.
 Diversas operações da API operam sobre o valor no topo da pilha, como por
 exemplo 
\family typewriter 
lua_setglobal
\family default 

\begin_inset Foot
collapsed true

\layout Standard

Funções da API que operam sobre um estado de execução Lua recebem um parâmetro
 inicial (nos exemplos, chamado de 
\family typewriter 
L
\family default 
) indicando o estado a que se referem.
 Isto será discutido mais adiante, na Seção 
\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
\end_inset 

:
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 123);       
\emph on 
/* Insere o número 123 na pilha */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "foo");       
\emph on 
/* Atribui o número 123 na global 
\emph default 
foo
\emph on 
 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A maioria das funções de consulta, entretanto, permitem especificar um índice
 qualquer da pilha (com valores positivos para indexação a partir da base
 e negativos para índices a partir do topo).
\layout Standard

A conversão de dados de Lua para C é feita através de funções como 
\family typewriter 
lua_tonumber
\family default 
 e 
\family typewriter 
lua_tolstring
\family default 
, que recebem um índice da pilha, convertem o valor no índice para o tipo
 Lua especificado se necessário, e retornam o valor convertido para o tipo\SpecialChar ~
C
 equivalente.
 Números têm o tipo\SpecialChar ~
C 
\family typewriter 
lua_Number
\family default 
, que corresponde a 
\family typewriter 
double
\family default 
 por padrão mas é um parâmetro na compilação de Lua.
 Strings, em particular, são objetos imutáveis e têm sua representação internali
zada: duas strings de conteúdo idêntico compartilham a mesma representação
 interna.
\layout Standard

Assim, diferentemente de linguagens como Python e Ruby, não é possível modificar
 o conteúdo de uma string Lua através de C via a sua representação em memória
 como um 
\family typewriter 
char*
\family default 
.
 Para tornar mais eficiente a construção em etapas de strings Lua a partir
 de C, a biblioteca auxiliar define um tipo\SpecialChar ~
C 
\family typewriter 
luaL_Buffer
\family default 
 e funções como 
\family typewriter 
luaL_addstring
\family default 
 e 
\family typewriter 
luaL_addvalue
\family default 
, que permitem a construção de uma string em etapas até que ela possa ser
 finalmente convertida para uma string Lua com 
\family typewriter 
luaL_pushresult
\family default 
.
 Assim, evitam-se consecutivas operações de concatenação de string através
 da API de Lua.
\layout Standard

Lua define dois tipos de dados específicos para o armazenamento de dados
 para C, 
\emph on 
full userdata
\emph default 
 e 
\emph on 
light userdata
\emph default 
.
 
\emph on 
Full userdata
\emph default 
 descrevem blocos de memória gerenciados por Lua e utilizados por código
 C.
 Eles existem em Lua como objetos opacos, e são criados por 
\family typewriter 
lua_newuserdata
\family default 
, que insere o novo objeto na pilha de Lua e retorna a C um ponteiro com
 a área de memória do tamanho requisitado.
 Objetos do tipo 
\emph on 
light userdata
\emph default 
, criados através de 
\family typewriter 
lua_pushlightuserdata
\family default 
, permitem armazenar ponteiros de C em Lua; a alocação e gerência do bloco
 de memória ficam a cargo do código C.
 O seguinte exemplo ilustra o uso de userdata, assumindo a mesma struct
 
\family typewriter 
point
\family default 
 definida na página\SpecialChar ~

\begin_inset LatexCommand \pageref{struct-point}

\end_inset 

.
 O userdata é criado da seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o full userdata e o insere na pilha e retorna
\layout LyX-Code


\size footnotesize 
\emph on 
   o ponteiro para C.
 A memória é alocada por Lua.
 */
\layout LyX-Code


\size footnotesize 
point* full_p = (point*) lua_newuserdata(L, sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Utilizamos então o ponteiro em C...
 */
\layout LyX-Code


\size footnotesize 
full_p->x = 100; full_p->y = 200;
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o objeto à variável global Lua 
\emph default 
PontoFull
\emph on 
 */
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "Ponto");
\layout Standard

A seguir, o acesso:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Empilha a global Ponto */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Ponto");
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro C do userdata no topo da pilha (posição -1) */
\layout LyX-Code


\size footnotesize 
point* p = (point*) lua_touserdata(L, -1);
\layout LyX-Code


\size footnotesize 
printf("(%d,%d)
\backslash 
n", p->x, p->y);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Restaura a pilha à posição original, removendo o item.
\layout LyX-Code


\size footnotesize 
\emph on 
   Ele não será coletado pois está associado à variável global.
 */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumindo que a global 
\family typewriter 
Ponto
\family default 
 é a única referência para este bloco, para liberá-lo basta sobrescrevermos
 
\family typewriter 
Ponto
\family default 
, por exemplo, com 
\family typewriter 
nil
\family default 
; a memória do full userdata poderá então ser liberada pelo coletor de lixo,
 como a de qualquer valor Lua sem referências.
\layout LyX-Code


\size footnotesize 
lua_pushnil(L);
\layout LyX-Code


\size footnotesize 
lua_setglobal(L, "PontoFull");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A área de armazenamento da pilha não se ajusta dinamicamente e as funções
 da API não realizam controle de 
\emph on 
overflow
\emph default 
.
 Assim, o programador é responsável por controlar o tamanho da pilha, através
 da função 
\family typewriter 
lua_checkstack
\family default 
.
 Na prática, o tamanho da pilha só irá crescer na ocorrência de laços empilhando
 elementos, já que seqüências típicas de operações tendem a empilhar valores
 e desempilhá-los em seguida.
\layout Standard

Tabelas são o único tipo para construção de estruturas de dados em Lua.
 Lua oferece uma API completa para manipulação de tabelas a partir de C.
 Tabelas podem ser criadas com 
\family typewriter 
lua_newtable
\family default 
 ou 
\family typewriter 
lua_createtable
\family default 
; a segunda forma permite pré-alocar memória para os elementos da tabela.
 As funções 
\family typewriter 
lua_gettable
\family default 
 e 
\family typewriter 
lua_settable
\family default 
 implementam a semântica de leitura e atribuição de campos em uma tabela
 em Lua, incluindo a possível chamada a metamétodos; para chamadas sem a
 invocação de metamétodos existem as funções 
\family typewriter 
lua_rawget
\family default 
 e 
\family typewriter 
lua_rawset
\family default 
, equivalentes a 
\family typewriter 
rawget
\family default 
 e 
\family typewriter 
rawset
\family default 
 em Lua (além das variantes 
\family typewriter 
lua_rawgeti
\family default 
 e 
\family typewriter 
lua_rawseti
\family default 
 para conveniência).
 Há ainda a função 
\family typewriter 
lua_next
\family default 
, equivalente à função Lua 
\family typewriter 
next
\family default 
, que permite percorrer os elementos de uma tabela.
 Um exemplo de manipulação de tabelas é dado a seguir:
\layout LyX-Code


\size footnotesize 
\emph on 
/* tabela["chave"] = 12345, em C: */
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "tabela");
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "chave");
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 12345);
\layout LyX-Code


\size footnotesize 
\emph on 
/* lua_settable insere na tabela especificada como argumento
\layout LyX-Code


\size footnotesize 
\emph on 
   o item localizado no topo da pilha,
\layout LyX-Code


\size footnotesize 
\emph on 
   usando como chave o elemento logo abaixo do topo: */
\layout LyX-Code


\size footnotesize 
lua_settable(L, -3);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Diversos conceitos de Lua são representados através de tabelas -- ambiente
 global, metatabelas, registro -- e são assim tratados em C usando as funções
 da API para manipulação de tabelas.
 A tabela do ambiente global da 
\emph on 
thread
\emph default 
 em execução pode ser acessada através de um índice especial da pilha virtual,
 
\family typewriter 
LUA_GLOBALSINDEX
\family default 
.
 Pode-se ainda definir uma tabela de ambiente da função, indexada em 
\family typewriter 
LUA_ENVIRONINDEX
\family default 
, para isolar dados a serem compartilhados internamente em funções de módulos
 escritos em C.
 Exemplificando, o ambiente global pode ser manipulado como uma tabela desta
 forma:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "Ponto");
\layout LyX-Code


\size footnotesize 
lua_gettable(L, LUA_GLOBALSINDEX);
\layout Standard

Isto é equivalente a:
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "Ponto");
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-Dados}

\end_inset 


\layout Standard

Os processos de estender e embutir Perl são bastante distintos.
 Para extensões, Perl oferece uma linguagem para descrição de interfaces
 chamada XS.
 Ao invés de isolar o acesso às estruturas internas de Perl através de uma
 API pública, a abordagem proposta é encapsular o processo de geração de
 código 
\emph on 
wrapper
\emph default 
 para a comunicação entre funções escritas em C e as estruturas internas
 de Perl usando interfaces escritas em XS.
 Arquivos 
\family typewriter 
.xs
\family default 
 contêm código C acompanhado de anotações que simplificam o tratamento dos
 parâmetros de entrada e saída.
 Estes são alimentados ao pré-processador 
\family typewriter 
xsubpp
\family default 
, que geram então o código usando a API oferecida pela biblioteca de Perl.
 Esta biblioteca oferece acesso de baixo nível ao funcionamento do interpretador
, permitindo, por exemplo, manipular o ponteiro da sua pilha interna.
 O objetivo de XS é ocultar ao desenvolvedor de extensões estes detalhes.
\layout Standard

Para embutir o interpretador Perl em uma aplicação, a biblioteca que a implement
a oferece algumas funções que permitem disparar um interpretador.
 Na API de mais alto nível, pode-se construir um array de parâmetros a serem
 passados para o interpretador de forma equivalente às opções do interpretador
 Perl de linha de comando, inclusive usando a opção 
\family typewriter 
"-e"
\family default 
 para executar trechos de código.
\layout Standard

Os tipos de variáveis Perl são mapeados para structs em C: 
\family typewriter 
SV
\family default 
 para escalares, 
\family typewriter 
AV
\family default 
 para arrays, 
\family typewriter 
HV
\family default 
 para hashes.
 Estes valores C são melhor entendidos como 
\emph on 
containers
\emph default 
 para valores Perl: uma variável escalar em Perl tem um 
\family typewriter 
SV
\family default 
 associado a si; todavia, pode-se criar em C um 
\family typewriter 
SV
\family default 
 que não esteja associado a nenhum nome de variável Perl.
\layout Standard

Os 
\emph on 
typedefs
\emph default 
 
\family typewriter 
IV
\family default 
, 
\family typewriter 
UV
\family default 
, 
\family typewriter 
NV
\family default 
 e 
\family typewriter 
PV
\family default 
 representam valores C correspondentes aos tipos primitivos de Perl, e correspon
dem, respectivamente, a inteiros com e sem sinal, valores de ponto flutuante
 e strings.
 Estes valores podem ser copiados para 
\family typewriter 
SV
\family default 
s.
 Referências Perl são representadas como 
\family typewriter 
RV
\family default 
, e também são um tipo de 
\family typewriter 
SV
\family default 
.
 Há ainda o tipo 
\family typewriter 
GV
\family default 
, capaz de referenciar qualquer tipo representável em uma variável Perl.
\layout Standard

Variáveis do espaço de Perl são acessadas com 
\family typewriter 
get_sv
\family default 
, 
\family typewriter 
get_av
\family default 
 e 
\family typewriter 
get_hv
\family default 
.
 Estas funções recebem uma string C com o nome da variável (possivelmente
 qualificado da forma 
\family typewriter 
"pacote::variavel"
\family default 
).
 O conteúdo de valores escalares é convertido de volta para um tipo\SpecialChar ~
C com
 as macros 
\family typewriter 
Sv
\family default 
*: 
\family typewriter 
SvIV
\family default 
 retorna um inteiro, 
\family typewriter 
SvPV
\family default 
 retorna um 
\family typewriter 
char*
\family default 
 e o comprimento da string no segundo parâmetro, etc.
 O seguinte código C exibe o conteúdo da variável Perl 
\family typewriter 
$a
\family default 
, assumindo que ela contenha um valor inteiro:
\layout LyX-Code


\size footnotesize 
printf("a = %d
\backslash 
n", SvIV(get_sv("a", FALSE)));
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A flag passada como segundo parâmetro de 
\family typewriter 
get_sv
\family default 
/
\family typewriter 
av
\family default 
/
\family typewriter 
hv
\family default 
 indica se a variável deve ser criada se o nome passado não corresponder
 a uma variável existente.
 Passar um nome inexistente e usar 
\family typewriter 
TRUE
\family default 
 no segundo parâmetro é uma forma conveniente de criar uma nova variável
 acessível no espaço de C já realizando o 
\emph on 
binding
\emph default 
 desta no espaço de Perl.
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria uma variável do tipo array,
\layout LyX-Code


\size footnotesize 
\emph on 
   acessível em Perl como a global @arr e em C como o AV* arr */
\layout LyX-Code


\size footnotesize 
AV* arr = get_av("arr", TRUE);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Um 
\family typewriter 
SV
\family default 
 pode ser criado em C com as funções 
\family typewriter 
newSV
\family default 
*: 
\family typewriter 
newSViv
\family default 
 gera um novo 
\family typewriter 
SV
\family default 
 armazenando um inteiro com sinal; 
\family typewriter 
newSVpv
\family default 
 a partir de uma string, e assim por diante.
 A função 
\family typewriter 
newSV
\family default 
 permite criar um 
\family typewriter 
SV
\family default 
 com área de memória não inicializada, acessível através da função 
\family typewriter 
SvPVX
\family default 
, permitindo assim criar escalares com valores arbitrários gerenciados por
 código C.
 Usando o mesmo exemplo da struct 
\family typewriter 
point
\family default 
 das seções anteriores, podemos armazenar um objeto C em um valor Perl da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Aloca um SV não inicializado do tamanho de um 
\emph default 
point
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* v = newSV(sizeof(point));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o ponteiro para a área de memória do 
\emph default 
SV
\emph on 
 */
\layout LyX-Code


\size footnotesize 
point* p = (point*) SvPVX(v);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Manipula o 
\emph default 
point
\emph on 
 em C.
 Quando v for retornado para Perl,
\layout LyX-Code


\size footnotesize 
\emph on 
ele será uma variável opaca (seu conteúdo não será acessível via Perl).
 */
\layout LyX-Code


\size footnotesize 
p->x = 100; p->y = 200;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Valores são atribuídos a 
\family typewriter 
SV
\family default 
s usando as funções 
\family typewriter 
sv_set
\family default 
*: 
\family typewriter 
sv_setiv
\family default 
, 
\family typewriter 
sv_setpv
\family default 
, etc.
 As funções para manipulação de strings possuem variantes como 
\family typewriter 
newSVpvn
\family default 
 e 
\family typewriter 
sv_setpvf
\family default 
, que permitem especificar o comprimento da string ou realizar formatação
 como em 
\family typewriter 
sprintf
\family default 
.
 Para strings, há ainda funções 
\family typewriter 
sv_cat
\family default 
*, que atuam como 
\family typewriter 
sv_set
\family default 
* mas concatenam o valor dado ao conteúdo atual da string ao invés de substituí-
lo.
 A função 
\family typewriter 
sv_setsv
\family default 
 copia o valor de um 
\family typewriter 
SV
\family default 
 para outro.
 O 
\family typewriter 
SV
\family default 
 criado no exemplo anterior pode ser atribuído para uma variável global
 da seguinte forma:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o SV da variável global 
\emph default 
$ponto
\emph on 
 */
\layout LyX-Code


\size footnotesize 
SV* ponto = get_sv("ponto", TRUE);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o valor de v para ponto */
\layout LyX-Code


\size footnotesize 
sv_setsv(ponto, v);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O tipo dos dados armazenados em 
\family typewriter 
SV
\family default 
s é verificado com as macros 
\family typewriter 
SvIOK
\family default 
 para inteiros, 
\family typewriter 
SvNOK
\family default 
 para valores de ponto flutuante e 
\family typewriter 
SvPOK
\family default 
 para strings.
 Estas funções retornam sucesso se o escalar é conversível para o tipo especific
ado -- as variantes 
\family typewriter 
SvIOKp
\family default 
, 
\family typewriter 
SvNOKp
\family default 
, 
\family typewriter 
SvPOKp
\family default 
 verificam se o valor armazenado no 
\family typewriter 
SV
\family default 
 é realmente do tipo.
\layout Standard

Arrays e hashes são criados com 
\family typewriter 
newAV
\family default 
 e 
\family typewriter 
newHV
\family default 
.
 Arrays podem ser populados com um array C de ponteiros para 
\family typewriter 
SV
\family default 
 através de 
\family typewriter 
av_make
\family default 
.
 Operações como 
\family typewriter 
av_fetch
\family default 
, 
\family typewriter 
av_pop
\family default 
, 
\family typewriter 
hv_fetch
\family default 
 e 
\family typewriter 
hv_exists
\family default 
 permitem operar sobre elementos das estruturas.
 Em 
\family typewriter 
av_fetch
\family default 
 e 
\family typewriter 
hv_fetch
\family default 
, o tipo de retorno é 
\family typewriter 
SV**
\family default 
, para diferenciar o retorno de um elemento existente que aponta para 
\family typewriter 
NULL
\family default 
 de um elemento não encontrado.
 No exemplo a seguir, criaremos um array Perl contendo os 10 primeiros elementos
 da série de Fibonacci:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria um novo array.
 */
\layout LyX-Code


\size footnotesize 
AV* a = newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
/* Armazena dois valores, 0 e 1, nas primeiras posições do array.
 */
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(0));
\layout LyX-Code


\size footnotesize 
av_push(a, newSViv(1));
\layout LyX-Code


\size footnotesize 
for (int i = 2; i < 10; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obviamente seria mais eficiente armazenar os valores em variáveis
\layout LyX-Code


\size footnotesize 
\emph on 
      temporárias em C, mas obtenhamos os dois últimos valores da
\layout LyX-Code


\size footnotesize 
\emph on 
      seqüência de volta do array Perl para fins de ilustração: */
\layout LyX-Code


\size footnotesize 
   SV** penultimo_sv = av_fetch(a, i-2, FALSE);
\layout LyX-Code


\size footnotesize 
   SV** ultimo_sv = av_fetch(a, i-1, FALSE);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém os inteiros armazenados nos SVs */
\layout LyX-Code


\size footnotesize 
   int penultimo = SvIV(*penultimo_sv);
\layout LyX-Code


\size footnotesize 
   int ultimo = SvIV(*ultimo_sv);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um novo SV e o insere no final do array */
\layout LyX-Code


\size footnotesize 
   av_push(a, newSViv( penultimo + ultimo ) );
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Uma vez criado este 
\family typewriter 
AV
\family default 
, entretanto, não há uma forma de associá-lo a uma variável Perl.
 Seu conteúdo deve ser copiado item a item.
 Para que este seja acessível a partir de Perl, deveríamos tê-lo criado
 com 
\family typewriter 
get_av
\family default 
, e não 
\family typewriter 
newAV
\family default 
.
 A utilidade de 
\family typewriter 
AV
\family default 
s não associados a variáveis está na passagem de parâmetros na chamada de
 funções e como valores de retorno.
\layout Standard

Algumas funções para manipulação de hashes expõem os pares chave/valor como
 ponteiros 
\family typewriter 
HE
\family default 
.
 As macros 
\family typewriter 
HeSVKEY
\family default 
 e 
\family typewriter 
HeVAL
\family default 
 permitem extrair a chave e valor de um 
\family typewriter 
HE
\family default 
.
 A seguinte função exibe em C os elementos de uma hash Perl:
\layout LyX-Code


\size footnotesize 
void imprime_hash(HV* hash) {
\layout LyX-Code


\size footnotesize 
   HE* item;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cada HV mantém o seu controle interno de iteração */
\layout LyX-Code


\size footnotesize 
   hv_iterinit(hash);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Obtém o próximo par chave/valor da iteração */
\layout LyX-Code


\size footnotesize 
   while ( (item = hv_iternext(hash)) ) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém a representação string dos escalares
\layout LyX-Code


\size footnotesize 
\emph on 
         representando chave e valor do item */
\layout LyX-Code


\size footnotesize 
      char* chave = SvPV_nolen(HeSVKEY(item));
\layout LyX-Code


\size footnotesize 
      char* valor = SvPV_nolen(HeVAL(item));
\layout LyX-Code


\size footnotesize 
      printf("%s => %s
\backslash 
n", chave, valor);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Cuidados especiais devem ser tomados ao utilizar os valores 
\family typewriter 
undef
\family default 
, 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em arrays e hashes, embora Perl exponha estas constantes na API de C (
\family typewriter 
PL_sv_undef
\family default 
, 
\family typewriter 
PL_sv_true
\family default 
, 
\family typewriter 
PL_sv_false
\family default 
).
 A constante 
\family typewriter 
PL_sv_undef
\family default 
 é usada internamente na implementação de 
\family typewriter 
AV
\family default 
s e 
\family typewriter 
HV
\family default 
s, e a atualização de valores em 
\family typewriter 
HV
\family default 
s ocorre 
\emph on 
in-place
\emph default 
, o que gera problemas ao atualizar elementos contendo estas constantes.
 A documentação recomenda gerar cópias destes valores ao usá-los em estruturas
 
\family typewriter 
AV
\family default 
 e 
\family typewriter 
HV
\family default 
\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlguts}

\end_inset 

.
\layout Standard

Referências Perl são criadas com 
\family typewriter 
newRV_inc
\family default 
 e 
\family typewriter 
newRV_noinc
\family default 
, que recebem um ponteiro para 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 como parâmetro (as duas funções diferem entre si no que tange à contagem
 de referências, que será abordada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-GC}

\end_inset 

).
 O valor apontado por uma referência é obtido com 
\family typewriter 
SvRV
\family default 
.
 O retorno desta macro deve ser convertido via 
\emph on 
cast
\emph default 
 para o tipo apropriado (
\family typewriter 
IV
\family default 
, 
\family typewriter 
PV
\family default 
, 
\family typewriter 
AV
\family default 
, etc.), que pode ser verificado com 
\family typewriter 
SvTYPE
\family default 
.
 
\layout Standard

Diversas funções da API têm tipo de parâmetros ou retorno declarados como
 
\family typewriter 
SV
\family default 
 quando na verdade aceitam 
\family typewriter 
AV
\family default 
s ou 
\family typewriter 
HV
\family default 
s; isto é análogo ao conceito de 
\emph on 
contextos
\emph default 
 de Perl, onde um mesmo valor pode ser tratado como lista (array ou hash)
 ou escalar dependendo da expressão onde ele é inserido\SpecialChar ~

\begin_inset LatexCommand \cite{marquess06perlcall}

\end_inset 

.
 Em código Perl, o contexto em que uma função está executando pode ser verificad
o com 
\family typewriter 
wantarray
\family default 
.
 Em\SpecialChar ~
C, o contexto pode ser verificado com a macro 
\family typewriter 
GIMME_V
\family default 
, que retorna 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 ou 
\family typewriter 
G_ARRAY
\family default 
.
\layout Subsection

Comparação
\layout Standard

O conjunto básico de funções para manipulação de dados nas cinco linguagens
 discutidas é similar: todas elas possuem funções para converter valores
 da linguagem para tipos básicos de C e vice-versa.
 Todas oferecem ainda funções para a manipulação dos seus tipos estruturados
 fundamentais (tabelas em Lua, arrays em Java, arrays e hashes em Ruby e
 Perl, listas e dicionários em Python).
 Python, em particular, define uma API extensa de funções para operações
 sobre as suas classes 
\emph on 
built-in
\emph default 
; a maioria destas operações poderia ser realizada usando a API genérica
 de invocação de métodos, mas é oferecida diretamente em C como conveniência.
\layout Standard

Lua ganha destaque por possuir, com o seu modelo de pilha, a API para manipulaçã
o de dados mais simples e ortogonal dentre as estudadas.
 Entretanto, muitas vezes o código resultante perde em legibilidade quando
 os índices da pilha são pouco óbvios.
 É comum ver código C usando a API de Lua comentado linha a linha, para
 evitar que o programador tenha que simular mentalmente o funcionamento
 da pilha ao ler o programa.
\layout Standard

Em Java, a tipagem estática reduz muito a necessidade de conversões de dados
 explícitas no código C.
 Por outro lado, o tratamento de 
\emph on 
multi-threading
\emph default 
 complica o acesso a tipos como strings e arrays.
\layout Standard

Um ponto negativo na API de Ruby é a exposição de detalhes de implementação
 dos campos da struct que implementam o seu tipo fundamental 
\family typewriter 
VALUE
\family default 
.
 Isto restringe a flexibilidade da implementação da linguagem e é uma prática
 de programação pouco segura.
 Perl também expõe grande parte de suas estruturas internas; não de forma
 tão direta quanto Ruby, mas através de macros.
 Tais macros, entretanto, assumem a aderência a protocolos tão estritos
 de uso que na prática também limitam largamente as possiblidades de alterações
 na implementação (um exemplo é a seqüência para chamada de funções, que
 será apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

).
\layout Standard

A criação de dados que contêm estruturas C armazenados pela linguagem de
 script é uma tarefa fácil em Perl, Ruby e Lua: Perl permite criar 
\family typewriter 
SV
\family default 
s contendo blocos de memória arbitrários para uso em C; Ruby disponibiliza
 a macro 
\family typewriter 
Data_Wrap_Struct
\family default 
 que gera um objeto Ruby que encapsula uma estrutura C; Lua define um tipo
 básico na linguagem especialmente para este fim.
 Já em Python, o processo é trabalhoso.
 Criar uma classe Python a partir de C envolve declarar partes dela estaticament
e e outras partes dinamicamente, sendo usualmente necessário definir três
 estruturas C diferentes.
 Em Java, não é possível criar novos tipos a partir de C, apenas carregar
 classes.
\layout Standard

Outra tarefa comum ao interagir com C é a necessidade de armazenar ponteiros
 no espaço de dados da linguagem de script.
 Python, Lua e Perl oferecem recursos para fazer isto de forma direta: criando
 um objeto 
\family typewriter 
PyCObject
\family default 
 em Python; um light userdata em Lua; ou armazenando o ponteiro na área
 de dados de um 
\family typewriter 
SV
\family default 
 em Perl.
 Em Java e Ruby, a alternativa é converter os ponteiros e armazená-los como
 números.
 De fato, isto ocorre internamente na implementação de Ruby, e as limitações
 de portabilidade desta abordagem são evidenciados pelo fato de que a compilação
 de Ruby falha se 
\family typewriter 
sizeof(void*) != sizeof(long)
\family default 
.
\layout Standard

Outro aspecto que merece nota é a preocupação em não poluir o espaço de
 nomes de\SpecialChar ~
C.
 Python, Java e Lua definem todas as suas funções e tipos C com prefixos
 que visam evitar conflitos com nomes definidos pela aplicação.
 Já Perl e Ruby definem nomes de forma desorganizada, o que ocasionalmente
 causa problemas
\begin_inset Foot
collapsed true

\layout Standard

Por exemplo, conflitos deste tipo ocorreram nos bindings Ruby do sistema
 de controle de versão Subversion em plataformas Win32 (
\begin_inset LatexCommand \url{http://svn.haxx.se/dev/archive-2005-04/1789.shtml}

\end_inset 

).
\end_inset 

.
 Perl possui opções para desabilitar uma série de macros e forçar um prefixo
 comum em suas funções, mas este recurso é incompleto e usá-lo prejudica
 a funcionalidade dos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

No estudo de caso apresentado no Capítulo 
\begin_inset LatexCommand \ref{cha:Estudo-de-caso:}

\end_inset 

, ao utilizar a API de Perl procuramos utilizar somente as versões com prefixo
 
\family typewriter 
Perl_
\family default 
 das funções da API, mas diversas macros só estão disponíveis nas versões
 sem o prefixo.
\end_inset 

.
\layout Section

Coleta de lixo
\begin_inset LatexCommand \label{sec:Coleta-de-lixo}

\end_inset 


\layout Standard

A partir do momento em que código C ganha acesso a referências a dados armazenad
os no espaço de armazenamento de outra linguagem, sejam ponteiros ou identificad
ores, o programador deve levar em consideração as diferenças entre os modelos
 de gerência de memória envolvidos, já que código executado na outra linguagem
 pode liberar o dado.
 Por exemplo, o programa C pode desalocar o objeto referenciado em um dado
 da linguagem de script, ou a linguagem de script pode remover um elemento
 de uma estrutura fazendo com que ele seja coletado.
 Em princípio, esta tarefa de manter a consistência entre os dois ambientes
 não é diferente da gerência de memória realizada normalmente pelo programador
 em C.
 Entretanto, a interação com algumas linguagens adiciona um complicador:
 os mecanismos de coleta de lixo realizam liberação de dados da memória
 de forma implícita.
 O princípio fundamental da coleta de lixo dita que um objeto não é coletado
 caso haja algum elemento (variável, estrutura de dados) apontando para
 ele.
 Todavia, o mesmo não vale para o ambiente C: a presença de um ponteiro
 apontando para um objeto não garante que ele não será coletado, uma vez
 que o coletor de lixo não gerencia os ponteiros do código\SpecialChar ~
C.
\layout Standard

É preciso, então, indicar a partir do código\SpecialChar ~
C que os dados que continuam
 acessíveis por ele não devem ser coletados.
 De forma complementar, ao transferir o controle de objetos\SpecialChar ~
C para o domínio
 da outra linguagem -- por exemplo, para armazená-los em uma estrutura de
 dados desta -- é necessário indicar à linguagem como desalocar a memória
 da estrutura quando o coletor de lixo detectar que ela não está mais em
 uso.
 A forma como a API irá fornecer estas funcionalidades depende não só do
 projeto da API para C, mas também do modelo de coleta de lixo empregado
 pela implementação da linguagem.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-GC}

\end_inset 


\layout Standard

A máquina virtual de Python possui um coletor de lixo baseado em contagem
 de referências.
 Como a API de Python retorna ao código C ponteiros a 
\family typewriter 
PyObject
\family default 
s, o programador deve ter o cuidado de garantir que eles se mantenham válidos.
 Para isto, é necessário incrementar e decrementar o contador de referências
 do objeto apontado conforme deseja-se manter a validade dos ponteiros em
 código C.
\layout Standard

De maneira geral, uma vez que código C deseja reter um 
\family typewriter 
PyObject*
\family default 
, ele deve utilizar a macro 
\family typewriter 
Py_INCREF
\family default 
 para incrementar a sua contagem de referências e assim impedi-lo de ser
 coletado.
 Uma vez que o valor não seja mais necessário, decrementa-se a contagem
 similarmente com 
\family typewriter 
Py_DECREF
\family default 
.
 Python trabalha com o conceito de 
\emph on 

\begin_inset Quotes eld
\end_inset 

propriedade de referências
\begin_inset Quotes erd
\end_inset 


\emph default 
 para definir quando o programador deve incrementar ou decrementar o contador
 de referências retornadas pelas funções da API.
 A maior parte das funções da API que retornam ponteiros a 
\family typewriter 
PyObject
\family default 
s 
\emph on 
transferem
\emph default 
 referências para o chamador; a referência passa então a ser sua responsabilidad
e -- ele pode passá-la adiante ou terá o dever de decrementá-la com 
\family typewriter 
Py_DECREF
\family default 
 assim que não precisar mais usá-la (o código C pode guardar referências
 que sejam de sua propriedade em suas estruturas de dados; elas continuarão
 válidas mesmo após o retorno da função, até serem explicitamente decrementadas).
 Outras funções 
\emph on 
emprestam
\emph default 
 referências; o código que recebe uma referência deste tipo não precisa
 decrementá-la ao terminar de utilizá-la, mas a validade do objeto está
 atrelada à validade da referência no objeto que a retornou ao código C.
 Por exemplo, 
\family typewriter 
PyList_GetItem
\family default 
 empresta uma referência a um elemento da lista.
 O ponteiro retornado continuará válido enquanto este item continuar contido
 na lista.
 Pode-se obter a 
\begin_inset Quotes eld
\end_inset 

propriedade
\begin_inset Quotes erd
\end_inset 

 de uma referência emprestada incrementando a contagem do objeto com 
\family typewriter 
Py_INCREF
\family default 
: a validade do ponteiro passa a ser independente do objeto 
\emph on 
container
\emph default 
 que o retornou, mas o código C passa a ser responsável por decrementar
 a referência posteriormente com 
\family typewriter 
Py_DECREF
\family default 
.
\layout Standard

Para referências de objetos passadas de código C de volta para Python, há
 dois casos na API em que funções 
\emph on 

\begin_inset Quotes eld
\end_inset 

roubam
\begin_inset Quotes erd
\end_inset 


\emph default 
 referências, isto é, em que a referência deixa de pertencer à função C
 chamadora: 
\family typewriter 
PyList_SetItem
\family default 
 e 
\family typewriter 
PyTuple_SetItem
\family default 
.
 A referência passada, que deve pertencer ao chamador, passa então a ser
 uma referência emprestada após a chamada.
 O objetivo disto é permitir chamadas de função aninhadas onde, por exemplo,
 o parâmetro de 
\family typewriter 
PyList_SetItem
\family default 
 é uma chamada que gera um novo objeto a ser armazenado na lista.
 Assim, evita-se que o programador tenha que armazenar um ponteiro para
 o objeto apenas para decrementar a sua referência posteriormente.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
void bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0); /* BUG! */
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\series bold 
\size footnotesize 
(a) 
\series default 
Acesso possivelmente inválido em 
\family typewriter 
PyObject_Print
\layout LyX-Code


\size footnotesize 
void no_bug(PyObject* list) {
\layout LyX-Code


\size footnotesize 
   PyObject* item = PyList_GetItem(list, 0);
\layout LyX-Code


\size footnotesize 
   if (!item) return;
\layout LyX-Code


\size footnotesize 
   Py_INCREF(item);
\layout LyX-Code


\size footnotesize 
   PyList_SetItem(list, 1, PyInt_FromLong(0L));
\layout LyX-Code


\size footnotesize 
   PyObject_Print(item, stdout, 0);
\layout LyX-Code


\size footnotesize 
   Py_DECREF(item);
\layout LyX-Code


\size footnotesize 
}
\layout Standard
\align center 

\size footnotesize 
(b) 
\family typewriter 
item
\family default 
 é garantidamente válido em 
\family typewriter 
PyObject_Print
\family default 
 
\layout Caption


\begin_inset LatexCommand \label{cap:python-gc}

\end_inset 

Acesso possivelmente inválido a uma referência a um 
\family typewriter 
PyObject
\family default 
 em código C
\end_inset 


\layout Standard

A interação com o contador de referências pode ser bastante sutil.
 O exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:python-gc}

\end_inset 

, extraído da documentação de Python\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy}

\end_inset 

, demonstra que uma referência pode ser invalidada por código aparentemente
 não relacionado
\begin_inset Foot
collapsed false

\layout Standard

De fato, a documentação informa que versões antigas de Python continham
 variantes deste 
\emph on 
bug
\emph default 
 em alguns de seus módulos.
\end_inset 

.
 À primeira vista, a inclusão de um elemento em 
\family typewriter 
list[1]
\family default 
 parece não afetar a referência 
\family typewriter 
item
\family default 
, que corresponde a 
\family typewriter 
list[0]
\family default 
.
 Todavia, a inclusão de 
\family typewriter 
list[1]
\family default 
 pode haver removido da lista um elemento que se encontrava nesta posição.
 Caso a lista fosse a última referência válida para o elemento, este poderia
 ser coletado.
 A coleta do objeto pode invocar o seu método finalizador 
\family typewriter 
__del__
\family default 
, que pode rodar código Python arbitrário.
 Se este código remove o elemento da posição 0 de 
\family typewriter 
list
\family default 
 e isto causar a sua coleta, a referência 
\family typewriter 
item
\family default 
 passa a ser inválida, porque 
\family typewriter 
PyList_GetItem
\family default 
 retorna uma referência emprestada.
\layout Standard

Ao implementar funções em C que retornam referências a 
\family typewriter 
PyObject
\family default 
s, o mesmo cuidado de definir a política de tempo de vida da referência
 deve ser tomado.
 Para retornar uma referência nova, pode ser necessário incrementar a contagem
 do objeto.
 Isto se manifesta, por exemplo, na forma correta de uma função C retornar
 o valor 
\family typewriter 
None
\family default 
, que envolve chamar 
\family typewriter 
Py_INCREF(Py_none)
\family default 

\begin_inset Foot
collapsed false

\layout Standard

Este padrão é tão comum que a seqüência 
\family typewriter 
Py_INCREF(Py_none); return Py_none;
\family default 
 foi encapsulada na macro 
\family typewriter 
Py_RETURN_NONE
\family default 
.
\end_inset 

.
 Mesmo objetos Python representando números devem ter a sua contagem de
 referências controlada pelo programador C.
 
\layout Standard

Para que o código C possa realizar operações de finalização sobre os dados
 armazenados em um tipo Python definido em C, é possível definir uma função
 de desalocação no campo 
\family typewriter 
tp_dealloc
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 que descreve o tipo.
 Esta função é normalmente responsável por liberar recursos alocados via
 código C (arquivos abertos, ponteiros para áreas de memória não acessíveis
 por Python, etc.) e decrementar referências a outros objetos Python mantidas
 pelo objeto.
\layout Standard

Ao desalocar estruturas de dados como listas pode-se provocar uma cadeia
 arbitrariamente grande de desalocações, à medida que cada elemento desencadeia
 a desalocação do próximo elemento da estrutura.
 Isto dispara a função de desalocação recursivamente e poderia facilmente
 causar estouro da pilha de C.
 Para contornar este problema, Python inclui um par de macros, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 e 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, que controla o número de níveis de recursão aceitos.
 A cada execução de 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 um contador interno é incrementado.
 Enquanto este contador não atingir o valor limite definido na constante
 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 (50 por padrão), a função executa normalmente.
 Quando o limite é atingido, 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
 armazena o objeto em uma lista interna e salta diretamente para 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
, evitando desalocar o objeto e entrar em recursão novamente.
 Ao final de cada nível da recursão, a macro 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 decrementa o contador.
 Quando o contador chega a zero, 
\family typewriter 
Py_TRASHCAN_SAFE_END
\family default 
 dispara novamente 
\family typewriter 
tp_dealloc
\family default 
 sobre os elementos armazenados na lista interna, reiniciando assim a recursão
 sobre a estrutura.
 Assim, uma cadeia de 
\begin_inset Formula $n$
\end_inset 

 desalocações é quebrada em 
\begin_inset Formula $n/$
\end_inset 


\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 cadeias, nenhuma excedendo 
\family typewriter 
PyTrash_UNWIND_LEVEL
\family default 
 níveis de recursão na pilha de C.
 As implementações dos principais tipos estruturados de Python, como listas,
 tuplas e dicionários, fazem uso deste mecanismo.
\layout Standard

O modelo de coleta de lixo utilizando contagem de referências traz consigo
 preocupações sobre referências circulares: uma cadeia de objetos que mantêm
 referências entre si mantém a contagem de cada um dos seus elementos acima
 de zero, mesmo que eles não sejam alcançáveis a partir de nenhum outro
 objeto.
 Python inclui um detector de ciclos, mas cuidados especiais devem ser tomadas
 para que tipos implementados em C se comportem corretamente caso possam
 gerar ciclos.
 Deve-se implementar uma função para percorrer referências contidas no objeto
 e uma função que decremente a contagem destas referências.
 Estas funções devem ser registradas nos campos 
\family typewriter 
tp_traverse
\family default 
 e 
\family typewriter 
tp_clear
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
.
 A função 
\family typewriter 
tp_clear
\family default 
 deve ter o cuidado de zerar o valor de seus campos 
\family typewriter 
PyObject*
\family default 
 para 
\family typewriter 
NULL
\family default 
 antes de decrementar cada referência, uma vez que a operação de decremento
 pode iniciar a desalocação do objeto e disparar uma chamada a 
\family typewriter 
tp_traverse
\family default 
 que, devido ao ciclo, retorne ao objeto anterior.
 O tipo deve ser, então, identificado com a flag 
\family typewriter 
Py_TPFLAGS_HAVE_GC
\family default 
 no campo 
\family typewriter 
tp_flags
\family default 
 de
\family typewriter 
 PyTypeObject
\family default 
.
\layout Standard

Além disso, a implementação de objetos Python que suportem coleta cíclica
 em C implica ainda em outros cuidados.
 Objetos devem ser alocados com 
\family typewriter 
PyObject_GC_New
\family default 
 ou 
\family typewriter 
PyObject_GC_NewVar
\family default 
 ao invés da funções usuais 
\family typewriter 
PyObject_New
\family default 
 e 
\family typewriter 
PyObject_NewVar
\family default 
.
 Durante a construção do objeto, após os campos a serem visitados por tp_travers
e terem sido preenchidos, é necessário ainda chamar uma função de notificação
 
\family typewriter 
PyObject_GC_Track
\family default 
 e durante a desalocação, antes de invalidar os campos do objeto, chamar
 
\family typewriter 
PyObject_GC_UnTrack
\family default 
.
 Para objetos que necessitem do mecanismo de 
\emph on 

\begin_inset Quotes eld
\end_inset 

trashcan
\begin_inset Quotes erd
\end_inset 


\emph default 
 para evitar estouro de pilha, é ainda preciso tomar o cuidado de desmarcar
 o objeto com 
\family typewriter 
PyObject_GC_UnTrack
\family default 
 antes de entrar no bloco 
\family typewriter 
Py_TRASHCAN_SAFE_BEGIN
\family default 
/
\family typewriter 
END
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Um longo comentário em typeobject.c descreve cuidados adicionais e um cenário
 de bug que pode ser causado pela interação incorreta entre Track/Untrack
 e a trashcan.
 
\end_inset 


\layout Standard

Apesar de oferecer um mecanismo de detecção de ciclos, Python é incapaz
 de coletar ciclos cujos objetos contenham finalizadores implementados em
 Python (métodos 
\family typewriter 
__del__
\family default 
); a única forma de acessar estes objetos é então através da lista 
\family typewriter 
garbage
\family default 
 no módulo 
\family typewriter 
gc
\family default 
.
 Este módulo (acessível a partir de C através de chamadas de função Python
 via API) oferece uma interface com o coletor de lixo, incluindo funções
 como 
\family typewriter 
enable
\family default 
 e 
\family typewriter 
disable
\family default 
, para ativar e desativar o coletor de lixo; 
\family typewriter 
collect
\family default 
 para executar uma coleta; 
\family typewriter 
get_objects
\family default 
, que retorna uma lista contendo todos os objetos controlados pelo coletor
 (exceto a própria lista); 
\family typewriter 
get_referrers
\family default 
 e 
\family typewriter 
get_referents
\family default 
, que retornam a lista de objetos que referenciam ou são referenciados por
 um dado objeto -- estas listas são obtidas percorrendo objetos com a função
 
\family typewriter 
tp_traverse
\family default 
, o que pode não apontar para todos os objetos realmente alcançáveis, ou
 ainda retornar objetos em estado inválido (como objetos em ciclos ainda
 não coletados ou objetos ainda não totalmente construídos) e assim devem
 ser usadas apenas para fins de depuração.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-GC}

\end_inset 


\layout Standard

Ruby utiliza um coletor de lixo 
\emph on 
mark-and-sweep
\emph default 
\SpecialChar ~

\begin_inset LatexCommand \cite{wilson92gc}

\end_inset 

.
 Esta técnica evita o problema de referências cíclicas enfrentado por Python,
 bastando que os objetos válidos possam ser corretamente indicados como
 alcançáveis.
\layout Standard

Objetos alcançáveis a partir do espaço de objetos de Ruby -- atribuídos
 a uma variável global Ruby ou inseridos em alguma estrutura de dados alcançável
 em Ruby -- não estarão sujeitos à coleta de lixo.
 Além destes, temos ainda os objetos retornados por Ruby para o espaço de
 C, já que muitas funções de API retornam 
\family typewriter 
VALUE
\family default 
s.
 A documentação alerta que, para armazenar objetos Ruby em C, seja em variáveis
 globais ou estruturas de dados, é necessário notificar à máquina virtual
 que o 
\family typewriter 
VALUE
\family default 
 não deve ser coletado usando 
\family typewriter 
rb_global_variable
\family default 
 (Embora a documentação não informe, é possível desmarcar um valor global
 com 
\family typewriter 
rb_gc_unregister_address
\family default 
)\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

.
\layout Standard

Objetos de escopo local a uma função C, entretanto, não precisam ser notificados.
 A forma como Ruby garante a validade de 
\family typewriter 
VALUE
\family default 
s locais é bastante peculiar: ao realizar a fase de marcação, o coletor
 de lixo varre a pilha de C em busca de valores que se pareçam com endereços
 de 
\family typewriter 
VALUE
\family default 
s, isto é, seqüências numéricas que correspondam a endereços de 
\family typewriter 
VALUE
\family default 
s válidos.
 Estes endereços podem ser identificados pois objetos são sempre alocados
 dentro de 
\emph on 
heaps
\emph default 
 mantidas pelo interpretador Ruby.
 Cada 
\family typewriter 
VALUE
\family default 
 encontrado na pilha é então marcado.
 Isto garante que nenhum 
\family typewriter 
VALUE
\family default 
 localmente alcançável por código C seja invalidado, mas pode gerar 
\begin_inset Quotes eld
\end_inset 

falsos positivos
\begin_inset Quotes erd
\end_inset 

 evitando que dados que poderiam ser coletados o sejam.
\layout Standard

Apesar da conveniência para o programador, tal abortagem é extremamente
 não-portável.
 A implementação do coletor de lixo em Ruby 1.8.2 possui 
\family typewriter 
#ifdef
\family default 
s para IA-64, DJGPP, FreeBSD, Win32, Cygwin, GCC, Atari ST, AIX, MS-DOS,
 Human68k, Windows CE, SPARC e Motorola 68000.
 Além disso, o coletor força a descarga dos registradores para a pilha usando
 
\family typewriter 
setjmp
\family default 
, para evitar que variáveis do tipo 
\family typewriter 
VALUE
\family default 
 que tenham sido otimizadas pelo compilador deixem de ser verificadas.
\layout Standard

Conforme visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-dados}

\end_inset 

, objetos Ruby criados com 
\family typewriter 
Data_Wrap_Struct
\family default 
 contêm structs C, que podem conter referências a 
\family typewriter 
VALUE
\family default 
s Ruby.
 A struct encapsulada, entretanto, é opaca para o universo Ruby.
 Então, para garantir que estes 
\family typewriter 
VALUE
\family default 
s sejam marcados como alcançáveis durante a coleta de lixo é necessário
 fazer isto via código C.
 
\family typewriter 
Data_Wrap_Struct
\family default 
 recebe, além da struct a encapsular, dois ponteiros, um para uma função
 de marcação e outra para uma função de desalocação.
 Quando o coletor de lixo visita o objeto na fase de marcação, ele invoca
 a função registrada, que deve chamar 
\family typewriter 
rb_gc_mark
\family default 
 em cada um dos 
\family typewriter 
VALUE
\family default 
s armazenados na 
\emph on 
struct
\emph default 
 do objeto, informando assim que os objetos são alcançáveis.
 Quando um objeto encapsulado via 
\family typewriter 
Data_
\family default 
*
\family typewriter 
_Struct
\family default 
 for dado como não alcançável, a função de desalocação registrada é chamada.
 Para estruturas que não armazenam outros 
\family typewriter 
VALUE
\family default 
s, pode-se definir a função de marcação como 
\family typewriter 
NULL
\family default 
 e a de desalocação como 
\family typewriter 
free
\family default 
.
\layout Standard

Ruby possui um módulo 
\family typewriter 
GC
\family default 
 que disponibiliza funções para ativar e desativar o coletor (
\family typewriter 
GC.enable
\family default 
 e 
\family typewriter 
GC.disable
\family default 
), bem como disparar uma coleta imediatamente (
\family typewriter 
GC.start
\family default 
).
 Na API em C há funções equivalentes: 
\family typewriter 
rb_gc_enable
\family default 
, 
\family typewriter 
rb_gc_disable
\family default 
 e 
\family typewriter 
rb_gc_start
\family default 
.
 A API de C inclui ainda uma função que insere um objeto imediatamente na
 lista de objetos a serem reciclados pelo alocador de memória de Ruby, 
\family typewriter 
rb_gc_force_recycle
\family default 
.
 Esta função deve ser usada com cuidado, já que se houverem outras referências
 apontando ao objeto elas passarão a apontar para outro objeto quando a
 área de memória for reutilizada pelo alocador de Ruby.
\layout Standard

Ruby oferece ainda como conveniência para o programador C alguns 
\emph on 
wrappers
\emph default 
 para as funções 
\family typewriter 
malloc
\family default 
 e 
\family typewriter 
realloc
\family default 
 que interagem com o coletor de lixo, forçando a execução do coletor durante
 alocações grandes
\begin_inset Foot
collapsed false

\layout Standard

O limite para definir 
\begin_inset Quotes eld
\end_inset 

grande
\begin_inset Quotes erd
\end_inset 

 se ajusta de acordo com o funcionamento do coletor e com as alocações realizada
s anteriormente.
\end_inset 

 ou em situações de pouca memória disponível.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Coleta-Java}

\end_inset 


\layout Standard

Assim como Python e Ruby, a API de Java retorna referências a objetos da
 máquina virtual que podem ser armazenados em variáveis C.
 A JNI define três tipos de referências, 
\emph on 
locais
\emph default 
, 
\emph on 
globais
\emph default 
 e 
\emph on 
globais fracas
\emph default 
, para auxiliar no controle do tempo de vida destas e a sua interação com
 o coletor de lixo.
\layout Standard

Referências locais são retornadas pela maioria das funções da JNI e são
 válidas até o retorno da função C que a obteve.
 Não é necessário desalocar explicitamente uma referência local: durante
 a execução de uma função C, a JVM mantém uma lista de referências locais
 passadas à função e libera todas elas quando o controle retorna à máquina
 virtual.
 Isto faz com que, de maneira geral, o programador não precise se preocupar
 com o coletor de lixo enquanto manipula valores retornados durante uma
 função.
 Por outro lado, em código que pode utilizar uma grande quantidade de referência
s locais é mais eficiente desalocar referências locais explicitamente, usando
 
\family typewriter 
DeleteLocalRef
\family default 
.
 A partir da versão 1.2 de Java, funções foram adicionadas para permitir
 a gerência de referências locais em blocos.
 
\family typewriter 
PushLocalFrame
\family default 
 e 
\family typewriter 
PopLocalFrame
\family default 
 permitem criar escopos aninhados de referências locais, que são desalocados
 de uma só vez.
 
\family typewriter 
PushLocalFrame
\family default 
 recebe ainda um parâmetro indicando um número de 
\emph on 
slots
\emph default 
 a serem pré-alocados, como otimização.
 Esse valor pode ser configurado também com 
\family typewriter 
EnsureLocalCapacity
\family default 
.
\layout Standard

Referências globais são geradas a partir de referências locais usando 
\family typewriter 
NewGlobalRef
\family default 
.
 Referências deste tipo mantêm-se válidas até serem explicitamente desalocadas
 com 
\family typewriter 
Delete\SpecialChar \-
GlobalRef
\family default 
.
 Uma referência global impede o objeto de ser coletado, podendo assim, ser
 utilizada para armazenar objetos Java no espaço de C além da duração de
 uma função, por exemplo, em variáveis globais ou estáticas.
\layout Standard

A Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

 mostra um exemplo do tipo de gerência de referências necessário quando
 se tem um laço criando referências temporárias sobre um número arbitrário
 de objetos.
\layout Standard

No exemplo, a função 
\family typewriter 
Java_Exemplo_concatArray
\family default 
 (equivalente, portanto, ao método 
\family typewriter 
concatArray
\family default 
 de uma classe 
\family typewriter 
Exemplo
\family default 
) converte os elementos de um array para strings usando 
\family typewriter 
Object.toString
\family default 
 e os concatena usando 
\family typewriter 
String.concat
\family default 
.
 Note que, como o número de vezes que o laço executa depende do tamanho
 do array passado, deve-se evitar que o número de referências cresça em
 cada iteração.
 Para isso, as opções seriam ou usar 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
, ou destruir as referências uma a uma com 
\family typewriter 
DeleteLocalRef
\family default 
.
 Se usássemos 
\family typewriter 
Push
\family default 
/
\family typewriter 
PopLocalFrame
\family default 
 no exemplo, teríamos que manter a string concatenada até o momento em uma
 referência global.
 Além disso, esta referência teria que ser destruída e recriada a cada iteração,
 já que strings são imutáveis em Java.
 Como o número de locais é pequeno, é mais conveniente neste caso controlá-las
 explicitamente com 
\family typewriter 
DeleteLocalRef
\family default 
 do que recorrer a referências globais.
 
\layout Standard


\family typewriter 
PopLocalFrame
\family default 
 permite, através de um parâmetro adicional, transferir uma referência local
 do conjunto que está sendo desempilhado para o escopo exterior de referências
 locais, criando assim uma nova referência.
 Para o exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:JNI-global-ref}

\end_inset 

, isto ainda não evitaria a necessidade de liberar referências locais explicitam
ente a cada iteração do laço, já que cada 
\family typewriter 
PopLocalFrame
\family default 
 criaria uma referência local nova.
\layout Standard


\begin_inset Float figure
placement tb
wide false
collapsed false

\layout LyX-Code


\size footnotesize 
static jmethodID concat = NULL, toString = NULL;
\layout LyX-Code

\layout LyX-Code


\size footnotesize 
\emph on 
/* Fazer o caching de jmethodIDs em código C é uma técnica comum.
\layout LyX-Code


\size footnotesize 
\emph on 
   Vale lembrar que jmethodIDs não são objetos Java, e portanto
\layout LyX-Code


\size footnotesize 
\emph on 
   não estão sujeitos a coleta de lixo.
 */
\layout LyX-Code


\size footnotesize 
void cache_ids(JNIEnv* J) {
\layout LyX-Code


\size footnotesize 
  jclass cls = (*J)->FindClass(J, "java/lang/String");
\layout LyX-Code


\size footnotesize 
  concat = (*J)->GetMethodID(J, cls, "concat",
\layout LyX-Code


\size footnotesize 
     "(Ljava/lang/String;)Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
  cls = (*J)->FindClass(J, "java/lang/Object");
\layout LyX-Code


\size footnotesize 
  toString = (*J)->GetMethodID(J, cls, "toString",
\layout LyX-Code


\size footnotesize 
     "()Ljava/lang/String;");
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\layout LyX-Code


\size footnotesize 
JNIEXPORT jstring JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_concatArray(JNIEnv* J, jobject this, jobjectArray a) {
\layout LyX-Code


\size footnotesize 
   if (!concat) cache_ids(J);
\layout LyX-Code


\size footnotesize 
   jstring s = (*J)->NewString(J, NULL, 0);     
\emph on 
/* s = "" */
\layout LyX-Code


\size footnotesize 
   int len = (*J)->GetArrayLength(J, a);     
\emph on 
   /* len = a.length */
\layout LyX-Code


\size footnotesize 
   for (int i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      jobject o = (*J)->GetObjectArrayElement(J, a, i);
\emph on 
      /* o = a[i] */
\layout LyX-Code


\size footnotesize 
      jstring os = (*J)->CallObjectMethod(J, o, toString);
\emph on 
   /* os = o.toString() */
\layout LyX-Code


\size footnotesize 
      jstring s2 = (*J)->CallObjectMethod(J, s, concat, os);
\emph on 
 /* s2 = s.concat(os) */
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, s);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, o);
\layout LyX-Code


\size footnotesize 
      (*J)->DeleteLocalRef(J, os);
\layout LyX-Code


\size footnotesize 
      s = s2;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return s; 
\layout LyX-Code


\size footnotesize 
} 
\layout Caption


\begin_inset LatexCommand \label{cap:JNI-global-ref}

\end_inset 

Rotina para concatenar os elementos de um array representados como strings.
\end_inset 


\layout Standard

A partir da versão 1.2, a JNI inclui referências globais fracas, com o objetivo
 de oferecer uma forma simplificada das referências fracas de Java (
\family typewriter 
java.lang.ref
\family default 
) -- um objeto que esteja sendo apontado apenas por referências globais
 fracas pode ser coletado.
 Originalmente, a API incluiu a função 
\family typewriter 
IsSameObject
\family default 
 como forma de verificar a validade de uma referência fraca, mas evidentemente
 este método é insuficiente: como Java é 
\emph on 
multi-threaded
\emph default 
, o coletor de lixo pode invalidar a referência entre o teste e a instrução
 seguinte no código\SpecialChar ~
C.
 A documentação revisada avisa sobre esta limitação e recomenda o uso de
 referências globais, além de alertar sobre comportamentos indefinidos nas
 relações entre referências globais fracas em C e os tipos de referências
 fracas definidos em Java\SpecialChar ~

\begin_inset LatexCommand \cite{jni1503spec}

\end_inset 

.
\layout Standard

Além desta, outras questões surgem a partir da combinação do modelo 
\emph on 
multi-threaded
\emph default 
 de Java com a exposição de referências a objetos da máquina virtual ao
 código C.
 Para reduzir o volume de cópia de dados entre Java e C, a JNI oferece algumas
 funções que retornam e liberam ponteiros para a representação interna de
 strings e arrays de tipos pri\SpecialChar \-
mi\SpecialChar \-
ti\SpecialChar \-
vos: 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleaseStringCritical
\family default 
 e 
\family typewriter 
Get
\family default 
/
\family typewriter 
ReleasePrimitiveArrayCritical
\family default 
.
 O uso destas funções, porém, possui importantes restrições.
 A API especifica que, uma vez obtido um ponteiro através destas funções,
 o código\SpecialChar ~
C não deve chamar outras funções da JNI ou realizar chamadas que
 possam bloquear a thread atual e fazer com que ela espere por outra thread
 Java, sob o risco de causar um 
\emph on 
deadlock
\emph default 
.
 Recomenda-se não manter blocos de memória bloqueados usando estas funções
 por muito tempo já que uma das técnicas possíveis para a implementação
 desta 
\begin_inset Quotes eld
\end_inset 

região crítica
\begin_inset Quotes erd
\end_inset 

 consiste em desabilitar o coletor de lixo da JVM.
 É importante notar ainda que referências locais e o ponteiro para o ambiente
 JNI passado para funções nativas são válidos apenas na thread onde foram
 criados; referências globais podem ser compartilhadas entre threads.
\layout Standard

Além do mecanismo de referências fracas fornecido pelas classes do pacote
 
\family typewriter 
java.lang.\SpecialChar \-
ref
\family default 
, a única forma oferecida por Java para interagir de maneira mais direta
 com o coletor de lixo é através da chamada 
\family typewriter 
System.gc()
\family default 
, que solicita à máquina virtual que dispare tão logo quanto possível a
 thread de coleta para que esta desaloque objetos não alcançáveis.
 Não há uma função C equivalente na JNI, mas este método pode ser invocado
 a partir de\SpecialChar ~
C com 
\family typewriter 
CallStaticVoidMethod
\family default 
.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-GC}

\end_inset 


\layout Standard

Por não retornar referências explícitas a objetos Lua ao código C, a interação
 do código nativo com o coletor de lixo é bastante simplificada.
 Operações sobre objetos Lua são sempre especificadas através de índices
 da pilha virtual.
 Assim, a máquina virtual mantém o controle sobre quais os objetos são acessívei
s a partir de C em qualquer dado momento.
 
\layout Standard

Embora ponteiros para objetos não sejam manipulados na API, algumas funções
 retornam ponteiros para estruturas gerenciadas por Lua: 
\family typewriter 
lua_newuserdata
\family default 
, 
\family typewriter 
lua_to
\family default 
*
\family typewriter 
string
\family default 
 e 
\family typewriter 
lua_touserdata
\family default 
.
 A validade dos ponteiros retornados por estas funções é dependente do tempo
 de vida do objeto correspondente a eles; para strings em particular, o
 ponteiro retornado só é garantidamente válido enquanto a string estiver
 na pilha.
 Lua oferece ainda a função 
\family typewriter 
lua_topointer
\family default 
, que permite obter ponteiros para alguns tipos de objetos (
\emph on 
userdata
\emph default 
, tabelas, 
\emph on 
threads
\emph default 
 e funções), mas somente com o objetivo de obter informação para depuração,
 já que não é possível converter o ponteiro de volta para um valor Lua.
 
\layout Standard

O conteúdo da pilha virtual é zerado quando a função C retorna o controle
 à máquina virtual de Lua.
 Dessa forma, não é possível reter ponteiros retornados por Lua para uso
 posterior em variáveis globais ou estruturas de C.
 Por outro lado, a API oferece um mecanismo para armazenar valores Lua em
 uma localização conhecida por código C que não pode ser alterada via código
 Lua: o 
\emph on 
registro
\emph default 
.
 O registro é uma tabela disponibilizada pela API de Lua para o armazenamento
 de valores Lua a partir de C; esta tabela não é normalmente acessível a
 partir de Lua.
 Como a tabela que implementa o registro é parte do 
\emph on 
root set
\emph default 
 do coletor de lixo, a inclusão de um objeto nesta tabela o impede de ser
 coletado, mantendo-o no registro até que seja explicitamente removido via
 código C.
\layout Standard

Usando o registro, uma forma possível de descrever dados do espaço de Lua
 em estruturas de dados em C é armazenar os dados no registro e armazenar
 os índices usados na estrutura C.
 A biblioteca auxiliar de Lua encapsula tal idioma através de duas funções,
 
\family typewriter 
luaL_ref
\family default 
 e 
\family typewriter 
luaL_unref
\family default 
.
 A função 
\family typewriter 
luaL_ref
\family default 
 associa o valor Lua passado a uma chave numérica inteira no registro, e
 retorna este número.
 Este valor então ser visto como um 
\emph on 
handle
\emph default 
 de alto nível para o objeto: o código C pode armazená-lo em variáveis ou
 estruturas e utilizá-lo para referenciar o objeto através do campo no registro.
 A função 
\family typewriter 
luaL_unref
\family default 
 remove o valor Lua do registro e libera o índice para reuso.
 Para o bom funcionamento deste mecanismo, chaves inteiras não devem ser
 utilizadas diretamente pelo programador para armazenar dados no registro.
\layout Standard

A API permite associar a objetos do tipo 
\emph on 
full userdata
\emph default 
 uma função de desalocação, 
\family typewriter 
__gc
\family default 
, na sua metatabela.
 Quando presente, esta função será tipicamente implementada em C, realizando
 a finalização de recursos.
 Por exemplo, o metamétodo 
\family typewriter 
__gc
\family default 
 de objetos retornados pela função Lua 
\family typewriter 
io.open
\family default 
 é uma função C que fecha o descritor de arquivo correspondente com a função
 C 
\family typewriter 
fclose
\family default 
.
 
\layout Standard

A princípio, o fato de que é possível obter e modificar a metatabela de
 um userdata via código Lua pode parecer problemático, já que pode-se substituir
 o seu finalizador em 
\family typewriter 
__gc
\family default 
.
 Entretanto, funções de coleta implementadas em C tipicamente validam o
 userdata recebido verificando o seu 
\begin_inset Quotes eld
\end_inset 

tipo
\begin_inset Quotes erd
\end_inset 

, identificado através da metatabela.
 Assim, mesmo que código Lua manipule a metatabela, uma função de coleta
 implementada em C que use 
\family typewriter 
luaL_checkudata
\family default 
 não será levada a operar sobre um 
\emph on 
userdata
\emph default 
 de tipo incorreto.
 Para impedir o código Lua de alterar a função de coleta de um objeto 
\emph on 
userdata
\emph default 
, pode-se atribuir um valor qualquer, como 
\family typewriter 
false
\family default 
, ao campo 
\family typewriter 
__metatable
\family default 
 da metatabela, que passa a ser retornado no lugar da metatabela, tornando
 a metatabela em si inacessível.
\layout Standard

Outro recurso relacionado à gerência de memória oferecido por Lua é a possibilid
ade de configurar, em tempo de execução, a função de alocação de memória
 a ser usada pela máquina virtual.
 Na criação de um novo estado Lua, passa-se como parâmetro uma função de
 alocação que deve oferecer funcionalidade similar às funções C 
\family typewriter 
free
\family default 
 e 
\family typewriter 
realloc
\family default 
, dependendo se o tamanho de bloco passado for igual ou maior do que zero.
 
\layout Standard

Lua oferece uma interface com o coletor de lixo através das funções 
\family typewriter 
lua_gc
\family default 
 em C e 
\family typewriter 
collectgarbage
\family default 
 em Lua.
 O coletor de Lua implementa 
\emph on 
mark-and-sweep
\emph default 
 incremental e permite ao programador configurar parâmetros relacionados
 aos intervalos de coleta, bem como ativar, desativar, disparar ciclos completos
 e executar passos do coletor.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-GC}

\end_inset 


\layout Standard

Como Python, Perl realiza coleta de lixo baseada em contagem de referências.
 A API provê funções para o controle explícito da contagem: 
\family typewriter 
SvREFCNT_inc
\family default 
 e 
\family typewriter 
SvREFCNT_dec
\family default 
 para incremento e decremento e um 
\emph on 
getter
\emph default 
, 
\family typewriter 
SvREFCNT
\family default 
.
 Outra forma de alterar a contagem de referências de um valor é atribuindo-o
 a uma referência Perl com 
\family typewriter 
newRV_inc
\family default 
.
 A contagem do valor referenciado será incrementada, fazendo com que --
 salvo tenha sua contagem alterada explicitamente -- este se mantenha válido
 enquanto for referenciado pelo 
\family typewriter 
RV
\family default 
.
 É importante notar, porém, que as funções da API que criam valores, como
 
\family typewriter 
newSViv
\family default 
, inicializam os seus contadores de referências com 1.
 Isto tem o efeito de que se um valor é criado em uma função C, armazenado
 em um 
\family typewriter 
RV
\family default 
 com 
\family typewriter 
newRV_inc
\family default 
 e esta referência é retornada a Perl, o valor nunca será coletado, pois
 o seu contador não retornará a 0 quando a referência for destruída.
 A forma correta, então, é usar 
\family typewriter 
newRV_noinc
\family default 
 para 
\family typewriter 
RV
\family default 
s contendo valores recém-criados e 
\family typewriter 
newRV_inc
\family default 
 quando um 
\family typewriter 
RV
\family default 
 deve manter válido um valor já existente.
\layout Standard

A inicialização da contagem de referências em 1 garante que valores criados
 continuarão válidos durante a execução de uma função C sem que seja necessário
 armazenar o valor no espaço de Perl.
 Estes valores podem também ser armazenados em variáveis globais e estruturas
 de dados de C e se manterão válidos até que a sua contagem de referências
 seja decrementada.
 Para valores cujo tempo de vida é restrito a uma função, a API de Perl
 define o conceito de valores 
\begin_inset Quotes eld
\end_inset 

mortais
\begin_inset Quotes erd
\end_inset 

 como uma forma de permitir desalocar todos os valores temporários de uma
 função de uma só vez.
 Um 
\family typewriter 
SV
\family default 
, 
\family typewriter 
AV
\family default 
 ou 
\family typewriter 
HV
\family default 
 pode ser criado com 
\family typewriter 
sv_newmortal
\family default 
 ou, mais comumente, convertido para mortal com 
\family typewriter 
sv_2mortal
\family default 
.
 Na prática, marcar um valor como mortal corresponde a indicar que ele deve
 ter a sua contagem de referências decrementada na chamada da macro 
\family typewriter 
FREETMPS
\family default 
 ao término da função, conforme será visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
 Algumas funções da API retornam valores mortais: por exemplo, 
\family typewriter 
hv_delete
\family default 
 remove um elemento de uma hash e, caso a flag 
\family typewriter 
G_DISCARD
\family default 
 não seja passada, retorna o elemento removido como um 
\family typewriter 
SV
\family default 
 mortal.
\layout Standard

A API de Perl não possui facilidades de interface com o coletor de lixo,
 mas possui algumas funções para auxílio em depuração que reportam informações
 sobre o estado da coleta de lixo.
 A função 
\family typewriter 
sv_report_used
\family default 
 exibe o conteúdo de todos os 
\family typewriter 
SV
\family default 
s do interpretador.
 O módulo 
\family typewriter 
Devel::Peek
\family default 
 permite examinar a partir de Perl o conteúdo de valores (contagem de referência
s, 
\emph on 
flags
\emph default 
, etc.) -- a partir de C, estas informações estão disponíveis diretamente
 já que as estruturas não são opacas.
\layout Subsection

Comparação
\layout Standard

Coleta de lixo tem por objetivo isolar, na medida do possível, o programador
 da gerência de memória.
 Desta forma, idealmente uma API deveria também ser tão independente quanto
 possível do algoritmo de coleta de lixo utilizado pela implementação da
 máquina virtual.
 Perl e Python realizam coleta de lixo baseada em contagem de referências,
 e isto transparece nas operações de incremento e decremento de referências
 freqüentemente necessárias durante o uso de suas APIs.
\layout Standard

Ruby utiliza um contador de referências baseado em mark-and-sweep.
 A sua API consegue abstrair bem este fato para a manipulação de objetos
 nativos Ruby, mas a implementação do contador é evidente na criação de
 tipos Ruby em C, onde precisamos declarar uma função de marcação quando
 temos estruturas C que guardam referências para objetos Ruby.
 A API de Lua vai além ao isolar-se da implementação do coletor de lixo
 utilizado: o único ponto da API onde o emprego de um coletor de lixo incrementa
l é aparente é na rotina de interação direta com o coletor, 
\family typewriter 
lua_gc
\family default 
, onde pode-se configurar parâmetros deste.
\layout Standard

Das cinco linguagens, a única cuja API abstrai totalmente a implementação
 do coletor de lixo é Java.
 A única operação de interface com o coletor que a linguagem provê, 
\family typewriter 
System.gc()
\family default 
, não recebe parâmetros e não especifica como ou quando a coleta deve ser
 feita
\begin_inset Foot
collapsed true

\layout Standard

A documentação é propositalmente vaga, dizendo apenas que este método 
\emph on 

\begin_inset Quotes eld
\end_inset 

suggests that the Java Virtual Machine expend effort toward recycling unused
 objects
\begin_inset Quotes erd
\end_inset 


\emph default 
 .
\end_inset 

.
 De fato, as várias implementações da JVM utilizam algoritmos diferentes
 para coleta de lixo.
\layout Standard

Na manipulação de dados através da API, Lua e Ruby são as linguagens que
 menos demandam do programador preocupações com gerência de referências.
 Ruby mantém o controle das referências retornadas a funções C varrendo
 a pilha de C durante a coleta de lixo, detectando a presença de referências
 armazenadas em variáveis locais.
 Lua evita o problema como um todo, mantendo seus objetos na pilha virtual
 e não retornando referências a eles ao código C.
\layout Standard

O problema de referências armazenadas em variáveis locais de uma função
 é tratado por Perl e Java de forma semelhante, definindo dois tipos de
 referências, globais e locais (referências locais são chamadas de 
\begin_inset Quotes eld
\end_inset 

variáveis mortais
\begin_inset Quotes erd
\end_inset 

 em Perl).
 Referências locais têm gerência implícita (salvo alguns casos, como discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Coleta-Java}

\end_inset 

).
 As funções da API de Java retornam referências locais por padrão, que podem
 ser convertidas para globais com 
\family typewriter 
NewGlobalRef
\family default 
.
 Em Perl ocorre o contrário, e as referências globais são convertidas para
 locais com 
\family typewriter 
sv_2mortal
\family default 
.
 O modelo de Java é mais interessante, pois normalmente são usadas mais
 variáveis de escopo local do que global.
 Valores armazenados globalmente têm sempre alguma forma de gerência explícita
 associada a si, mesmo em Ruby e Lua, através de 
\family typewriter 
rb_global_variable
\family default 
 e 
\family typewriter 
luaL_ref
\family default 
/
\family typewriter 
luaL_unref
\family default 
.
\layout Section

Chamada de funções a partir de C
\layout Standard

A API deve prover uma forma de invocar a partir de C funções a serem executadas
 pela linguagem de script.
 Isto envolve a passagem de dados entre estes dois 
\begin_inset Quotes eld
\end_inset 

espaços
\begin_inset Quotes erd
\end_inset 

, conforme visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Dados}

\end_inset 

 e as implicações que isto traz sobre o tempo de vida dos objetos, abordadas
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sec:Coleta-de-lixo}

\end_inset 

.
 Devido à tipagem estática de C, não é possível usar uma sintaxe transparente
 para chamada de funções registradas em tempo de execução.
 É necessário então que a API defina funções para realizar chamadas na linguagem
 de script.
\layout Standard

Nesta seção serão discutidas as facilidades oferecidas por cada API para
 a invocação de funções para execução na máquina virtual.
 As principais questões envolvidas são como referenciar a função a ser chamada,
 como passar argumentos a ela e como obter o valor de retorno, incluindo
 formas de notificação no caso de erros.
 Para fins de ilustração, será apresentado em cada linguagem um exemplo
 de chamada de uma função simples.
 Assume-se que tenha sido definida no espaço de cada linguagem de script
 uma função 
\family typewriter 
teste
\family default 
, que recebe um inteiro e uma string como parâmetros e retorna um inteiro
 como resultado.
 Para maior brevidade, a verificação de erros será omitida nos exemplos.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

Para chamar uma função Python a partir de C, deve-se inicialmente obter
 um ponteiro para o 
\family typewriter 
PyObject
\family default 
 correspondente à função, como visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

.
 Além de funções implementadas em Python e funções C registradas a partir
 da API, qualquer tipo de dado que implemente o método 
\family typewriter 
__call__
\family default 
 (ou declare uma função no campo 
\family typewriter 
tp_call
\family default 
 de sua estrutura 
\family typewriter 
PyTypeObject
\family default 
) pode ser chamado como uma função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções para chamar funções
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

A API de Python oferece diversas funções para realização de chamadas a partir
 de C.
 A função mais geral, 
\family typewriter 
PyObject_Call
\family default 
, recebe como parâmetros o objeto a ser chamado, uma tupla Python contendo
 os parâmetros a serem passados e opcionalmente um dicionário de argumentos
 
\emph on 
keyword
\emph default 
.
 Como conveniência, outras funções permitem passar os argumentos de outras
 formas.
 Por exemplo, 
\family typewriter 
PyObject_CallFunction
\family default 
 encapsula a chamada a 
\family typewriter 
Py_BuildValue
\family default 
 (vista na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

), aceitando diretamente a string de formato desta e os valores a serem
 convertidos diretamente.
 
\family typewriter 
PyObject_CallFunctionObjArgs
\family default 
 é uma função 
\emph on 
vararg
\emph default 
 que aceita uma seqüência de ponteiros para 
\family typewriter 
PyObject
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Existem também funções de conveniência para a invocação de métodos.
 A função 
\family typewriter 
PyObject_CallMethod
\family default 
 é uma variante de 
\family typewriter 
PyObject_CallFunction
\family default 
 que recebe como parâmetros um 
\family typewriter 
PyObject
\family default 
 e uma string C contendo o nome do método.
 Assim, por exemplo, as duas formas abaixo são equivalentes à chamada Python
\size footnotesize 
 
\family typewriter 
\size default 
ret = uma_string.split(" ")
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* "s" indica que o parâmetro seguinte é do tipo string.
 */
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallMethod(uma_string, "split", "s", " ");
\newline 
 
\newline 
PyObject* split = PyObject_GetAttrString(uma_string, "split");
\layout LyX-Code


\size footnotesize 
PyObject* ret = PyObject_CallFunction(split, "s", " ");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É interessante notar que quando um método é chamado como função, o argumento
 
\family typewriter 
self
\family default 
 não é passado explicitamente.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

O valor de retorno em todas as funções de chamada é um ponteiro para 
\family typewriter 
PyObject
\family default 
.
 Assim como ocorre em código Python, quando funções Python retornam múltiplos
 valores, estes são encapsulados em uma tupla.
 Para funções que não retornam valor, as funções\SpecialChar ~
C devem retornar 
\family typewriter 
Py_None
\family default 
.
 Em caso de erro na chamada, as funções retornam 
\family typewriter 
NULL
\family default 
.
 A ocorrência de exceções pode então ser verificada com a função 
\family typewriter 
PyErr_Occurred
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Uma forma típica para chamar uma função Python 
\family typewriter 
teste
\family default 
, incluindo a obtenção da função e a conversão dos valores de entrada e
 saída entre Python e C, é exibida a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
PyObject* teste = PyDict_GetItemString(globals, "teste");
\layout LyX-Code


\size footnotesize 
\emph on 
/* "si" indica que seguem parâmetros string e inteiro */
\layout LyX-Code


\size footnotesize 
PyObject* obj_result = PyObject_CallFunction(teste, "si", "entrada", 2);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Converte o valor para C */
\layout LyX-Code


\size footnotesize 
long result = PyInt_AsLong(obj_result);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Libera o PyObject temporário retornado.
 */
\layout LyX-Code


\size footnotesize 
Py_DECREF(obj_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Uma função global é obtida através do dicionário do módulo 
\family typewriter 
__main__
\family default 
.
 A conversão dos dados de entrada de C para Python é feita através da string
 de formato recebida por 
\family typewriter 
PyObject_CallFunction
\family default 
.
 Esta chamada equivale a 
\family typewriter 
obj_result = teste("entrada", 2)
\family default 
 em Python.
 O valor de retorno é retornado como uma nova referência a um objeto Python
 e, desta forma, precisa ter a contagem de referências decrementada após
 o seu uso.
 As funções 
\family typewriter 
PyImport_AddModule
\family default 
, 
\family typewriter 
PyModule_GetDict
\family default 
 e 
\family typewriter 
PyDict_GetItemString
\family default 
 retornam referências emprestadas, portanto a contagem de referências dos
 PyObjects retornados por elas não precisam ser decrementadas após o seu
 uso.
 Todavia, após a chamada da função Python, não há garantia de que os ponteiros
 globals e teste ainda apontem para objetos válidos -- precisaríamos ter
 incrementado a sua contagem de referências caso quiséssemos usá-los novamente.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções para chamar funções
\end_inset 


\layout Standard

Como métodos não são valores de primeira classe em Ruby, eles não são representa
dos como 
\family typewriter 
VALUE
\family default 
s na sua API de C.
 Para a chamada de métodos Ruby em C, a API oferece a função 
\family typewriter 
rb_funcall
\family default 
 e algumas variantes.
 Em comum, todas recebem como parâmetro o 
\family typewriter 
VALUE
\family default 
 referente ao objeto sobre o qual o método se refere, um 
\family typewriter 
ID
\family default 
 referente à string internalizada contendo o nome do método e um inteiro
 indicando o número de argumentos.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Valor de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

Como em Python, as funções da API para invocação de métodos diferem na forma
 como os argumentos são passados.
 Por exemplo, a função 
\family typewriter 
rb_funcall
\family default 
 recebe os argumentos na forma de 
\family typewriter 
VALUE
\family default 
s passados como varargs C; 
\family typewriter 
rb_funcall2
\family default 
 recebe um array C de 
\family typewriter 
VALUE
\family default 
s; 
\family typewriter 
rb_apply
\family default 
 recebe um 
\family typewriter 
VALUE
\family default 
 que deve ser um array Ruby contendo os parâmetros.
 Todas elas retornam um 
\family typewriter 
VALUE
\family default 
 como parâmetro.
 Assim como em código Ruby, múltiplos valores de retorno são representados
 como um array Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Todas as rotinas de chamada de função na API se referem a métodos, precisando
 assim especificar um objeto sobre o qual o método deve ser aplicado.
 Funções globais em Ruby são definidas como métodos do módulo 
\family typewriter 
Kernel
\family default 
, que é incluído pela classe 
\family typewriter 
Object
\family default 
 e são, assim, acessíveis a partir de qualquer objeto, incluindo 
\family typewriter 
nil
\family default 
.
 Desta forma, pode-se invocar funções globais passando a constante C 
\family typewriter 
Qnil
\family default 
 como o objeto alvo do método.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

A seguir, é apresentada a forma típica para chamar uma função global Ruby
 
\family typewriter 
teste
\family default 
, novamente incluindo a conversão dos valores de entrada e saída entre C
 e o interpretador.
\layout LyX-Code


\size footnotesize 
ID teste = rb_intern("teste");
\layout LyX-Code


\size footnotesize 
VALUE val_result = rb_funcall(Qnil, teste, 2, rb_str_new2("entrada"), INT2NUM(2)
);
\layout LyX-Code


\size footnotesize 
long result = NUM2LONG(val_result);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Diferentemente de Python, não é necessário obter uma referência para a função,
 bastando passar o nome desta na forma de 
\family typewriter 
ID
\family default 
 e o objeto a que ela se refere (no caso, 
\family typewriter 
Qnil
\family default 
, indicando uma função global).
 A conversão dos dados de entrada de C para Ruby é feita através da função
 
\family typewriter 
rb_str_new2
\family default 
 e da macro 
\family typewriter 
INT2NUM
\family default 
, que criam 
\family typewriter 
VALUE
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs.
 no exemplo
\end_inset 


\layout Standard

Conforme discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Ruby-GC}

\end_inset 

, o controle da validade de 
\family typewriter 
VALUE
\family default 
s é feito implicitamente.
 Assim, pode-se fazer a chamada de funções que criam 
\family typewriter 
VALUE
\family default 
s diretamente na passagem de parâmetros de 
\family typewriter 
rb_funcall
\family default 
.
 De fato, as três linhas acima poderiam ter sido condensadas, passando a
 chamada 
\family typewriter 
rb_funcall
\family default 
 como parâmetro para 
\family typewriter 
NUM2LONG
\family default 
 e a chamada 
\family typewriter 
rb_intern
\family default 
 como segundo parâmetro de 
\family typewriter 
rb_funcall
\family default 
, tendo sido separadas apenas para maior legibilidade.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: blocos Ruby
\end_inset 


\layout Standard

Um tipo de dados que possui um tratamento um tanto irregular em Ruby é o
 de blocos de código.
 A sintaxe em Ruby para a declaração de blocos é especial: blocos só podem
 ser definidos como o último argumento de uma chamada de método.
 Assim, eles não são valores de primeira classe, não podendo ser, por exemplo,
 declarados em uma atribuição a variável.
 Eles podem, no entanto, ser promovidos a valores de primeira classe, na
 forma de objetos da classe 
\family typewriter 
Proc
\family default 
.
 Isto pode ser feito de duas formas: explicitamente, passando um bloco para
 o método 
\family typewriter 
Proc.new
\family default 
, ou implicitamente, quando o bloco for passado para um método que declara
 um último parâmetro formal precedido de 
\family typewriter 
&
\family default 
.
 Esta variável conterá o bloco convertido para um 
\family typewriter 
Proc
\family default 
.
 Na chamada de funções que esperam blocos, 
\family typewriter 
&
\family default 
 converte o 
\family typewriter 
Proc
\family default 
 para um bloco.
 Objetos 
\family typewriter 
Proc
\family default 
 podem ser manipulados através da API de C como qualquer outro objeto Ruby,
 mas não há correspondente na API de C para a funcionalidade do operador
 
\family typewriter 
&
\family default 
 em chamadas de função.
\layout Standard

O status especial dos blocos de código complica a sua manipulação a partir
 de código\SpecialChar ~
C, e em particular a invocação de métodos que os esperam como
 parâmetro.
 Digamos que queremos invocar o seguinte método Ruby a partir de\SpecialChar ~
C:
\layout LyX-Code


\size footnotesize 
def uma_funcao_ruby()
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby vai invocar o bloco.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   yield
\layout LyX-Code


\size footnotesize 
   print("uma_funcao_ruby encerrou.
\backslash 
n")
\layout LyX-Code


\size footnotesize 
   return 42
\layout LyX-Code


\size footnotesize 
end
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função espera que um bloco de código seja passado para que seja invocado
 via o comando 
\family typewriter 
yield
\family default 
.
 Como vamos invocar a função a partir de C, queremos também passar código
 C como um bloco, representado na seguinte função: 
\layout LyX-Code


\size footnotesize 
VALUE um_bloco_C() {
\layout LyX-Code


\size footnotesize 
   fprintf(stderr, "um_bloco_C está rodando.
\backslash 
n");
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A conversão de objetos 
\family typewriter 
Proc
\family default 
 para blocos proporcionada pelo operador 
\family typewriter 
&
\family default 
 em Ruby não possui equivalente na API C.
 Assim, 
\family typewriter 
rb_funcall
\family default 
 não é capaz de passar 
\family typewriter 
Proc
\family default 
s para funções que aceitam blocos.
 A forma intuitiva de fazer a chamada de funções Ruby a partir de C, neste
 caso, então, não funciona:
\layout LyX-Code


\size footnotesize 
ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
\emph on 
/* O segundo parâmetro é um argumento adicional a ser
\layout LyX-Code


\size footnotesize 
\emph on 
   opcionalmente passado na invocação de um Proc */
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(a_C_block, Qnil);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Não funciona! Um Proc não é um bloco de código.
 */
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_funcall(Qnil, uma_funcao_ruby, 1, um_proc);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

As únicas formas de invocar um método Ruby passando um bloco de código são
 através de 
\family typewriter 
rb_eval_string
\family default 
 e 
\family typewriter 
rb_iterate
\family default 
.
 A primeira abordagem, além do custo de desempenho causado pelo 
\emph on 
parsing
\emph default 
 da string de código, tem a inconveniência de exigir o uso de variáveis
 temporárias para que se possa obter os valores de retorno de volta ao espaço
 de C.
 No modelo usando 
\family typewriter 
rb_eval_string
\family default 
, a função C que atuará como bloco deve ser declarada no espaço de Ruby.
 Há duas alternativas de como fazer isto: registrando o método em Ruby e
 invocando-o em um bloco 
\emph on 
wrapper
\emph default 
 declarado no texto da string Ruby:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Declara uma função global com 0 parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
rb_define_global_function("um_bloco_C", um_bloco_C, 0);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby { um_bloco_C() }");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard

Ou encapsulando a função em um objeto 
\family typewriter 
Proc
\family default 
 a partir de C com 
\family typewriter 
rb_proc_new
\family default 
 e então usando a notação 
\family typewriter 
&
\family default 
 na string de código Ruby avaliada:
\layout LyX-Code


\size footnotesize 
VALUE um_proc = rb_proc_new(um_bloco_C, Qnil);
\layout LyX-Code


\size footnotesize 
rb_gv_set("$um_proc", um_proc);
\layout LyX-Code


\size footnotesize 
rb_eval_string("$resultado = uma_funcao_ruby(&$um_proc)");
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_gv_get("$resultado");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A segunda abordagem explora o fato de que a única função da API de C capaz
 de produzir blocos de código diretamente é 
\family typewriter 
rb_iterate
\family default 
.
 Esta função recebe dois ponteiros de função, um para a função a ser invocada
 e outro para a função que atuará como o bloco de código; chamadas a 
\family typewriter 
yield
\family default 
 dentro da primeira função invocarão a segunda.
 O bloco pode quebrar o fluxo de execução com 
\family typewriter 
rb_iter_break
\family default 
.
 Passando como 
\begin_inset Quotes eld
\end_inset 

função de iteração
\begin_inset Quotes erd
\end_inset 

 para 
\family typewriter 
rb_iterate
\family default 
 uma função 
\emph on 
wrapper
\emph default 
 que simplesmente chama o método Ruby desejado com 
\family typewriter 
rb_funcall
\family default 
, é possível simular uma chamada a 
\family typewriter 
rb_funcall
\family default 
 que recebe uma função\SpecialChar ~
C como bloco de código.
\layout LyX-Code


\size footnotesize 
VALUE chama_uma_funcao_ruby() {
\layout LyX-Code


\size footnotesize 
   ID uma_funcao_ruby = rb_intern("uma_funcao_ruby");
\layout LyX-Code


\size footnotesize 
   return rb_funcall(Qnil, uma_funcao_ruby, 0);
\layout LyX-Code


\size footnotesize 
} 
\layout LyX-Code


\size footnotesize 
...
\layout LyX-Code


\size footnotesize 
\emph on 
/* Os argumentos Qnil indicam que não há parâmetros
\layout LyX-Code


\size footnotesize 
\emph on 
   nem para a função nem para o bloco */
\layout LyX-Code


\size footnotesize 
VALUE resultado = rb_iterate(chama_uma_funcao_ruby, Qnil, um_bloco_C, Qnil);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que nenhum argumento é passado em 
\family typewriter 
rb_funcall
\family default 
 -- a função 
\family typewriter 
rb_iterate
\family default 
 define 
\family typewriter 
um_bloco_C
\family default 
 como sendo o 
\begin_inset Quotes eld
\end_inset 

bloco de código atual
\begin_inset Quotes erd
\end_inset 

 e esta definição é herdada implicitamente por 
\family typewriter 
rb_funcall
\family default 
.
\layout Standard

Para o caso comum de realizar iterações sobre o método 
\family typewriter 
each
\family default 
 de coleções, Ruby oferece uma função 
\emph on 
wrapper
\emph default 
 
\family typewriter 
rb_each
\family default 
.
 Esta função foi projetada para ser passada como primeiro argumento de 
\family typewriter 
rb_iterate
\family default 
.
 Funções C executando como bloco de código podem quebrar o fluxo de execução
 com 
\family typewriter 
rb_iter_break
\family default 
.
 O mecanismo de 
\emph on 
yield
\emph default 
, tanto para código C quanto para chamadas nativas em Ruby, é implementado
 usando as funções C 
\family typewriter 
setjmp
\family default 
 e 
\family typewriter 
longjmp
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

Para o correto tratamento de erros, funções C que realizam chamadas a funções
 Ruby devem ser encapsuladas em uma chamada 
\family typewriter 
rb_protect
\family default 
 ou em uma de suas variantes, 
\family typewriter 
rb_ensure
\family default 
 e 
\family typewriter 
rb_rescue
\family default 
.
 Esta função captura exceções disparadas por código Ruby (ou código C usando
 
\family typewriter 
rb_raise
\family default 
).
 Caso o programa não use 
\family typewriter 
rb_protect
\family default 
, exceções em Ruby resultarão em erros fatais.
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Chamada}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\end_inset 


\layout Standard

De forma similar ao acesso a atributos, na chamada de métodos em Java deve-se
 inicialmente obter um identificador para o método, do tipo 
\family typewriter 
jmethodID
\family default 
.
 Estes identificadores são tipicamente obtidos com a função 
\family typewriter 
GetMethodID
\family default 
, que recebe como parâmetros a classe (instância de 
\family typewriter 
jclass
\family default 
) e duas strings, uma com o nome do método e outra com a assinatura do método.
 A sintaxe que descreve assinaturas de métodos é similar à de descritores
 de campos discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Parâmetros são listados entre parênteses, seguidos do tipo de retorno.
 Por exemplo, 
\family typewriter 
"([Ljava/lang/String;II)V"
\family default 
 indica uma função com parâmetros 
\family typewriter 
String[], int, int
\family default 
 e retorno 
\family typewriter 
void
\family default 
.
 Alternativamente ao uso de 
\family typewriter 
GetMethodID
\family default 
, a partir de Java 1.2 é possível obter um 
\family typewriter 
jmethodID
\family default 
 correspondente a um método aplicando a função 
\family typewriter 
FromReflectedMethod
\family default 
 sobre um objeto Java do tipo 
\family typewriter 
Method
\family default 
 -- isto é, um método reificado através da API de reflexão de Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API para invocar funções
\end_inset 


\layout Standard

Uma vez obtido o 
\family typewriter 
jmethodID
\family default 
, um método pode ser invocado através de alguma das 90 funções da família
 
\family typewriter 
Call
\family default 
*
\family typewriter 
Method
\family default 
*.
 Os nomes das funções seguem a forma
\layout LyX-Code


\size footnotesize 
Call
\family roman 
\emph on 
<tipo><retorno>
\family default 
\emph default 
Method
\family roman 
\emph on 
<argumentos>
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

O 
\emph on 
<tipo>
\emph default 
 pode ser 
\family typewriter 
Static
\family default 
 para funções estáticas, passando na chamada uma 
\family typewriter 
jclass
\family default 
 como parâmetro; 
\family typewriter 
Nonvirtual
\family default 
 para invocar implementações de um método em uma classe específica sobre
 um determinado objeto, passando uma 
\family typewriter 
jclass
\family default 
 e um 
\family typewriter 
jobject
\family default 
 como parâmetros; ou omitido para métodos de instância, passando o 
\family typewriter 
jobject
\family default 
 sobre o qual o método será aplicado.
 O tipo de retorno é indicado em 
\emph on 
<retorno>
\emph default 
: 
\family typewriter 
Void
\family default 
,
\family typewriter 
 Object
\family default 
, 
\family typewriter 
Int
\family default 
, etc.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Os argumentos do método podem ser passados de três formas: como 
\emph on 
varargs
\emph default 
, como um array C de 
\family typewriter 
jvalue
\family default 
s, ou propagando uma 
\family typewriter 
va_list
\family default 
 recebida.
 Por exemplo, na forma mais simples, um método de instância sem retorno
 e sem parâmetros é invocado com 
\family typewriter 
CallVoidMethod
\family default 
.
 Já 
\family typewriter 
CallStaticIntMethodA
\family default 
 chama um método estático que retorna um 
\family typewriter 
jint
\family default 
 com a lista de parâmetros passada em um array de 
\family typewriter 
jvalue
\family default 
s.
 Como Java é uma linguagem estaticamente tipada, não é preciso especificar
 o número ou o tipo dos parâmetros passados nas funções de chamada de métodos.
 Estas informações já estão especificadas nos 
\family typewriter 
jmethodID
\family default 
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: escopo léxico vs.
 dinâmico
\end_inset 


\layout Standard

É importante notar que, ao obter identificadores de métodos e campos fazendo
 a resolução a partir do 
\family typewriter 
jobject
\family default 
 recebido na variável 
\family typewriter 
this
\family default 
 e do nome do método ou campo, com 
\family typewriter 
GetObjectClass
\family default 
 e 
\family typewriter 
GetFieldID
\family default 
, estamos efetivamente resolvendo nomes através de escopo dinâmico.
 Isto implica que, por exemplo, caso um método 
\family typewriter 
Pai.metodo
\family default 
 implementado em C acesse um atributo privado 
\family typewriter 
umAtributo
\family default 
 e uma subclasse 
\family typewriter 
Filho
\family default 
 também defina um atributo privado 
\family typewriter 
umAtributo
\family default 
, a chamada a esse método em uma instância 
\family typewriter 
f
\family default 
 de 
\family typewriter 
Filho
\family default 
 acabaria por acessar 
\family typewriter 
Filho.umAtributo
\family default 
 e não 
\family typewriter 
Pai.umAtributo
\family default 
.
 Este comportamento é diferente do que ocorreria se 
\family typewriter 
Pai.metodo
\family default 
 fosse implementado em Java, onde o 
\emph on 
binding
\emph default 
 de membros privados é definido lexicamente.
 Para garantir à implementação em C de 
\family typewriter 
Pai.metodo
\family default 
 que o atributo 
\family typewriter 
umAtributo
\family default 
 acessado é realmente 
\family typewriter 
Pai.umAtributo
\family default 
, deve-se armazenar no espaço de C o identificador do campo obtido a partir
 da 
\family typewriter 
jclass
\family default 
 de 
\family typewriter 
Pai
\family default 
 -- obtida, por exemplo, em uma função 
\family typewriter 
static native
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros
\end_inset 


\layout Standard

O código C pode verificar a ocorrência de exceções através de 
\family typewriter 
ExceptionCheck
\family default 
 e optar por tratá-la, obtendo uma referência local da exceção com 
\family typewriter 
ExceptionOccurred
\family default 
 e posteriormente zerando-a com 
\family typewriter 
ExceptionClear
\family default 
, ou então mantê-la ativa de modo que seja propagada ao código Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Para realizar o exemplo da função 
\family typewriter 
teste
\family default 
, já que Java não possui funções globais, vamos assumir que teste é um método
 estático de uma classe chamada 
\family typewriter 
Exemplo
\family default 
 e que estamos rodando o código C a seguir em um contexto onde possuímos
 uma referência a um ambiente de execução Java chamado 
\family typewriter 
J
\family default 
 (este ponteiro, do tipo 
\family typewriter 
JNIEnv
\family default 
, será discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Registro}

\end_inset 

).
\layout LyX-Code


\size footnotesize 
jclass exemplo = (*J)->FindClass(J, "Exemplo");
\layout LyX-Code


\size footnotesize 
jmethodID teste = (*J)->GetStaticMethodID(J, exemplo,
\layout LyX-Code


\size footnotesize 
                        "teste", "(Ljava/lang/String;I)I");
\layout LyX-Code


\size footnotesize 
jstring entrada = (*J)->NewStringUTF(J, "entrada");
\layout LyX-Code


\size footnotesize 
long result = (*J)->CallStaticIntMethod(J, exemplo, teste, entrada, (jint)2);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das referências no exemplo
\end_inset 


\layout Standard

Inicialmente, é obtida uma referência à classe 
\family typewriter 
Exemplo
\family default 
, a partir da qual é obtido o identificador do método desejado, baseado
 no seu nome e assinatura.
 Como em Ruby, a string passada como parâmetro deve ser convertida para
 um tipo da máquina virtual.
 Já para o segundo argumento e para o valor de retorno, exploramos o fato
 de que o tipo 
\family typewriter 
jint
\family default 
, correspondente ao tipo Java 
\family typewriter 
int
\family default 
 (inteiro de 32 bits), é compatível com o tipo 
\family typewriter 
long
\family default 
 de C (inteiro de pelo menos 32 bits).
 Todas estas funções da API retornam referências locais, que serão liberadas
 automaticamente ao final da função C onde as chamadas à API foram feitas.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-chamada}

\end_inset 


\layout Standard

Tanto em funções C disparadas por Lua como em chamadas de funções Lua realizadas
 a partir de código C, os parâmetros de entrada e os valores de retorno
 são passados através da pilha virtual apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-dados}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Verificação da ocorrência de erros
\layout Standard

Passando argumentos
\end_inset 


\layout Standard

Para chamar uma função Lua a partir de C, devemos inicalmente empilhar o
 objeto Lua referente a ela: para funções globais, obtendo-a com 
\family typewriter 
lua_getglobal
\family default 
, para funções armazenadas em tabelas, com 
\family typewriter 
lua_gettable
\family default 
.
 A seguir, empilhamos os seus parâmetros e então invocamos 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, indicando quantos valores da pilha devem ser passados como parâmetro.
 A diferença entre as duas funções está no tratamento de erros: 
\family typewriter 
lua_call
\family default 
 propaga os erros sinalizados, usando 
\family typewriter 
longjmp
\family default 
; 
\family typewriter 
lua_pcall
\family default 
 captura os erros, retornando um código de 
\emph on 
status
\emph default 
 e a mensagem de erro na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\layout Standard

Múltiplos valores de retorno
\end_inset 


\layout Standard

No caso de execução sem erros, a pilha conterá os valores de retorno da
 função chamada.
 O número de valores de retorno pode ser explicitamente requisitado na chamada
 de 
\family typewriter 
lua_call
\family default 
 ou 
\family typewriter 
lua_pcall
\family default 
, ou ser definido em tempo de execução, requisitando o valor especial 
\family typewriter 
LUA_MULTRET
\family default 
.
 Se um número de valores de retorno for solicitado e este não for passado
 pela função chamada, o número de valores será ajustado adicionando elementos
 
\family typewriter 
nil
\family default 
 ou descartando valores em excesso.
 Para chamadas com 
\family typewriter 
LUA_MULTRET
\family default 
, todos os valores são empilhados.
 Nesse caso, a única forma de descobrir quantos valores foram retornados
 é comparando o tamanho da pilha antes e depois da chamada.
\layout Standard

A função 
\family typewriter 
lua_cpcall
\family default 
 permite chamar funções C realizando captura de erros de forma similar a
 
\family typewriter 
lua_pcall
\family default 
 sem precisar registrá-las como valores Lua.
 Esta funcionalidade é similar à oferecida por 
\family typewriter 
rb_protect
\family default 
 em Ruby.
 Ruby, todavia, não oferece função análoga a 
\family typewriter 
lua_pcall
\family default 
, sendo às vezes necessário encapsular a chamada de funções Ruby em funções\SpecialChar ~
C
 que obedeçam à assinatura esperada por 
\family typewriter 
rb_protect
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Função vs.
 método
\end_inset 


\layout Standard

Lua não possui distinção entre funções e métodos, mas possui açúcar sintático
 que permite invocar funções armazenadas em tabelas com uma sintaxe de chamada
 de métodos: 
\family typewriter 
t:m(x)
\family default 
 significa 
\family typewriter 
t.m(t,x)
\family default 
.
 Todavia, não há na API de C uma chamada específica para replicar esta abreviaçã
o.
 Para funções armazenadas em tabela, a função deve ser obtida com 
\family typewriter 
lua_gettable
\family default 
 e a tabela deve ser empilhada explicitamente juntamente com os demais parâmetro
s.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

O exemplo da chamada da função 
\family typewriter 
teste
\family default 
 demonstra a disciplina de pilha adotada na API de Lua.
 De forma similar a Java, iremos assumir a existência de um ponteiro 
\family typewriter 
L
\family default 
 do tipo 
\family typewriter 
lua_State
\family default 
, que será explicado mais adiante na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

.
 
\layout LyX-Code


\size footnotesize 
lua_getglobal(L, "teste");           
\emph on 
/* Empilha a função teste */
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "entrada");        
\emph on 
/* Empilha a string "entrada" */
\layout LyX-Code


\size footnotesize 
lua_pushinteger(L, 2);               
\emph on 
/* Empilha o número 2 */
\layout LyX-Code


\size footnotesize 
lua_call(L, 2, 1);                   
\emph on 
/* Chama a função com 2 parâmetros,
\layout LyX-Code


\size footnotesize 
\emph on 
                                        e espera 1 como retorno */
\layout LyX-Code


\size footnotesize 
long result = lua_tointeger(L, -1);  
\emph on 
/* Obtém o resultado no topo da pilha (-1) */
\layout LyX-Code


\size footnotesize 
lua_pop(L, 1);                       
\emph on 
/* Remove-o da pilha */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Controle das refs no exemplo
\end_inset 


\layout Standard

Com 
\family typewriter 
lua_getglobal
\family default 
, é empilhada a função global 
\family typewriter 
teste
\family default 
.
 Em seguida, os dois argumentos de entrada são empilhados.
 A função é então invocada com 
\family typewriter 
lua_call
\family default 
, indicando dois parâmetros de entrada e um de saída.
 O valor de retorno, no topo da pilha (índice\SpecialChar ~

\begin_inset Formula $-1$
\end_inset 

) é convertido para C com 
\family typewriter 
lua_tointeger
\family default 
.
 Esta última função não remove o valor da pilha: para retorná-la ao seu
 estado inicial, precisamos removê-lo explicitamente com 
\family typewriter 
lua_pop
\family default 
.
 Como em nenhum momento a API retorna ponteiros para objetos Lua, não há
 preocupações com coleta de lixo.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-call}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Como obter/referenciar uma função
\layout Standard

Funções da API para invocar funções
\layout Standard

Funções vs.
 métodos
\end_inset 


\layout Standard

A chamada de funções Perl a partir de C se dá através de uma disciplina
 de pilha, como em Lua.
 Parâmetros de entrada são especificados através de operações de empilhamento
 e valores de retorno são obtidos na pilha após a chamada da função.
 As funções 
\family typewriter 
call_sv
\family default 
, 
\family typewriter 
call_pv
\family default 
 e 
\family typewriter 
call_method
\family default 
 variam apenas na forma como a função a ser chamada é especificada: através
 de um 
\family typewriter 
SV
\family default 
, de uma string C ou de uma string C descrevendo o nome de um método de
 algum objeto ou classe inserido na pilha.
 A função 
\family typewriter 
call_argv
\family default 
, como conveniência, recebe como um argumento adicional um array C contendo
 strings C representando parâmetros a serem empilhados.
 Todas retornam o número de valores de retorno disponíveis na pilha.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas da linguagem: contextos Perl
\end_inset 


\layout Standard

As funções 
\family typewriter 
call_
\family default 
* possuem um argumento indicando flags a serem passadas que indicam a forma
 que a função deve ser chamada e como tratar os argumentos e valores de
 retorno.
 
\family typewriter 
G_VOID
\family default 
, 
\family typewriter 
G_SCALAR
\family default 
 e 
\family typewriter 
G_ARRAY
\family default 
 especificam o contexto como a função deve ser chamada.
 Em contextos escalares, por exemplo, somente um escalar é retornado na
 pilha; se a função chamada retornar uma lista, somente o último elemento
 desta estará disponível na pilha.
 
\family typewriter 
G_DISCARD
\family default 
 indica que os valores de retorno devem ser automaticamente descartados;
 
\family typewriter 
G_NOARGS
\family default 
 indica que o array padrão de parâmetros 
\family typewriter 
@_
\family default 
 não deve ser construído
\begin_inset Foot
collapsed true

\layout Standard

Isto tem o efeito colateral de que a função chamada herda o valor de 
\family typewriter 
@_
\family default 
 da função chamadora.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificação da ocorrência de erros.
\end_inset 


\layout Standard

O precedimento para verificação de erros depende do contexto e das flags
 passadas, que afetam como situações de erro são reportadas no valor de
 retorno das funções 
\family typewriter 
call_
\family default 
* e nos valores retornados na pilha.
 A flag 
\family typewriter 
G_EVAL
\family default 
 encapsula a chamada em um bloco 
\family typewriter 
eval
\family default 
, capturando erros.
 Assim, a ocorrência de erros pode ser verificada através da macro 
\family typewriter 
ERRSV
\family default 
, que retorna o 
\family typewriter 
SV
\family default 
 contendo a mensagem de erro.
 Acrescentando a flag 
\family typewriter 
G_KEEPERR
\family default 
, mensagens de erro não sobrescrevem a variável especial 
\family typewriter 
$@
\family default 
, mas são concatenadas a ela, acumulando seqüências de erros em níveis de
 chamada diferentes.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de chamada de função
\end_inset 


\layout Standard

Uma série de macros descrevem um protocolo para a chamada de funções e a
 manipulação de parâmetros de entrada e saída.
 As principais serão explicadas a seguir, na apresentação da versão Perl
 da chamada da função 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
dSP;
\layout LyX-Code


\size footnotesize 
ENTER;
\layout LyX-Code


\size footnotesize 
SAVETMPS;
\layout LyX-Code


\size footnotesize 
PUSHMARK(SP);
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSVpv("entrada", 0)));
\layout LyX-Code


\size footnotesize 
XPUSHs(sv_2mortal(newSViv(2)));
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
call_pv("teste", G_SCALAR);
\layout LyX-Code


\size footnotesize 
SPAGAIN;
\layout LyX-Code


\size footnotesize 
long result = POPl;
\layout LyX-Code


\size footnotesize 
PUTBACK;
\layout LyX-Code


\size footnotesize 
FREETMPS;
\layout LyX-Code


\size footnotesize 
LEAVE;
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Passando argumentos
\layout Standard

Controle de referências no exemplo
\end_inset 


\layout Standard

Inicialmente 
\family typewriter 
dSP
\family default 
 declara uma cópia local do ponteiro da pilha de Perl.
 Em seguida, 
\family typewriter 
ENTER
\family default 
 e 
\family typewriter 
SAVETMPS
\family default 
 criam um escopo para valores mortais.
 
\family typewriter 
PUSHMARK
\family default 
 inicia a contagem de parâmetros a serem passados para a função.
 Estes parâmetros são então empilhados com 
\family typewriter 
XPUSHs
\family default 
.
 Os valores criados com 
\family typewriter 
newSVpv
\family default 
 e 
\family typewriter 
newSViv
\family default 
 são convertidos para valores mortais com 
\family typewriter 
sv_2mortal
\family default 
, para que não tenham que ter sua contagem de referências decrementada explicita
mente após a chamada da função.
 
\family typewriter 
PUTBACK
\family default 
 encerra a contagem de parâmetros.
 É feita então a chamada da função global Perl 
\family typewriter 
teste
\family default 
, em contexto escalar, com 
\family typewriter 
call_pv
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Após o retorno desta função, a memória da pilha de Perl pode ter sido realocada,
 mudando o endereço do ponteiro de pilha obtido inicialmente com 
\family typewriter 
dSP
\family default 
.
 Para certificar-se que o seu valor está correto, deve-se chamar 
\family typewriter 
SPAGAIN
\family default 
 após funções 
\family typewriter 
call_
\family default 
*.
 A função 
\family typewriter 
POPl
\family default 
 desempilha um valor e o converte para 
\family typewriter 
long
\family default 
 (há funções similares para outros tipos, como 
\family typewriter 
POPs
\family default 
 para 
\family typewriter 
SV
\family default 
s e 
\family typewriter 
POPpx
\family default 
 para strings).
 Estas operações desempilham valores atualizando a cópia local do ponteiro
 de pilha.
 Assim, 
\family typewriter 
PUTBACK
\family default 
 deve ser chamado novamente para atualizar o ponteiro global.
 Finalmente, 
\family typewriter 
FREETMPS
\family default 
 e 
\family typewriter 
LEAVE
\family default 
 decrementam a contagem de referências dos valores mortais.
 
\layout Subsection

Comparação
\layout Standard

Em Python, Lua e Perl, funções podem ser acessadas como objetos da linguagem
 e invocadas.
 Em Ruby e Java, a API define tipos especiais usados para referenciar métodos.
 Como na manipulação de dados, Python oferece uma API extensa, com diversas
 funções de conveniência permitindo passar argumentos como tuplas Python,
 objetos Python passados como 
\emph on 
varargs
\emph default 
, valores C a serem convertidos pela função de chamada, etc.
 Java também oferece um grande número de funções para invocação de métodos
 e, devido à tipagem estática da linguagem, os parâmetros de entrada podem
 ser passados como 
\emph on 
varargs
\emph default 
 de forma bastante simples, sem precisar especificar a forma como a conversão
 deles deve ser realizada.
 Ruby também oferece algumas variantes de funções de chamada.
\layout Standard

Lua, em contraste, separa a rotina da chamada da função da passagem dos
 parâmetros, que é feita anteriormente através da pilha.
 Isto é uma solução bastante simples, mas o código resultante é menos claro
 que as chamadas equivalentes em linguagens como Ruby e Python.
 Perl também faz chamadas de função utilizando um modelo de pilha, mas ao
 contrário de Lua o seu uso é demasiadamente complexo, por exigir um protocolo
 de macros que expõem o funcionamento interno do interpretador.
 Outro complicador é o tratamento de valores de retorno, pois estes variam
 de comportamento conforme o contexto Perl em que a função é chamada.
\layout Standard

Em Lua e Python, a ocorrência de erros pode ser verificada com o valor de
 retorno da função.
 De forma similar, Perl permite detectar erros na chamada mais recente verifican
do uma variável especial; em Java, isto é feito chamando uma função da API.
 Somente o tratamento de erros em Ruby é mais convoluto, pois estranhamente
 a API oferece uma função que permite invocar funções C em modo protegido,
 mas não uma equivalente que permita chamar funções Ruby.
 Torna-se necessário escrever uma função 
\emph on 
wrapper
\emph default 
 nestes casos, o que será ilustrado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Section

Registro de funções C
\layout Standard

Para permitir a invocação de funções C a partir de código da linguagem de
 script, a API deve fornecer uma forma de registrar estas funções no ambiente
 de execução.
 Em linguagens de tipagem estática, como Java, para que seja possível chamar
 funções externas usando uma sintaxe igual à de funções nativas, o conjunto
 de funções externas deve ser declarado 
\emph on 
a priori
\emph default 
 de alguma forma.
 Já em linguagens com tipagem dinâmica, como é o caso de Python, Lua, Ruby
 e Perl, as funções podem ser usadas diretamente, bastando que sejam definidas
 em algum momento da execução antes de sua chamada.
 Assim, pode-se declarar as funções externas em tempo de execução através
 de código C usando a API da linguagem de script.
\layout Standard

Também nesta seção, a apresentação de cada linguagem encerrará com o exemplo
 de função C a ser registrada, que assim como nos exemplos da seção anterior,
 recebe um inteiro e uma string e retorna um inteiro.
 Será apresentada também, para cada linguagem, a forma de registrar a função
 como a global
\begin_inset Foot
collapsed false

\layout Standard

Ou no caso de Java, método estático.
\end_inset 

 
\family typewriter 
teste
\family default 
 de modo que ela possa ser invocada diretamente a partir da linguagem ou
 através da API.
\layout Subsection

Python
\begin_inset LatexCommand \label{sub:Python-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

Python não possui um tipo 
\begin_inset Quotes eld
\end_inset 

função
\begin_inset Quotes erd
\end_inset 

 propriamente dito declarável em C.
 Métodos de classes, no entanto, são objetos e possuem um tipo específico,
 que pode ser verificado com a função 
\family typewriter 
PyMethod_Check
\family default 
.
 Tipicamente, métodos são criados passando-se um array de estruturas 
\family typewriter 
PyMethodDef
\family default 
.
 Estas estruturas são compostas do nome da função, o ponteiro da função
 C, um vetor de flags e uma string de documentação.
 As flags são usadas para indicar a convenção adotada para os parâmetros
 de entrada na função C.
 As flags mais comuns são: 
\family typewriter 
METH_NOARGS
\family default 
, usada para funções Python que não recebem parâmetros, indicando que a
 função C deve receber um único ponteiro para 
\family typewriter 
PyObject
\family default 
, que irá conter o 
\family typewriter 
self
\family default 
 do método; 
\family typewriter 
METH_VARARGS
\family default 
, para funções que recebem como segundo parâmetro uma tupla Python que conterá
 um número variável de parâmetros passados de Python para C; e 
\family typewriter 
METH_KEYWORDS
\family default 
, para indicar que a função C recebe ainda como terceiro parâmetro um dicionário
 contendo os argumentos 
\emph on 
keywords
\emph default 
 passados à função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\end_inset 


\layout Standard

De posse destas informações, funções da API que operam sobre arrays de 
\family typewriter 
PyMethodDef
\family default 
 podem criar e associar objetos do tipo método no espaço de Python.
 
\family typewriter 
Py_InitModule
\family default 
, por exemplo, inicializa um módulo com funções de um array de 
\family typewriter 
PyMethodDef
\family default 
.
 Similarmente, os métodos de uma classe implementada em C podem ser dados
 no campo 
\family typewriter 
tp_methods
\family default 
 da estrutura 
\family typewriter 
PyTypeObject
\family default 
 relativa à classe.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C registradas em Python devem retornar um ponteiro para 
\family typewriter 
PyObject
\family default 
, ou 
\family typewriter 
NULL
\family default 
 em caso de erro (opcionalmente declarando uma exceção com 
\family typewriter 
PyErr_SetString
\family default 
 ou 
\family typewriter 
PyErr_SetObject
\family default 
).
 Funções que não retornam valores devem retornar o objeto pré-definido 
\family typewriter 
Py_None
\family default 
, lembrando das questões de contagem de referência de valores retornados
 discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-GC}

\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

O que são funções na linguagem
\end_inset 


\layout Standard

Embora métodos sejam usualmente criados em C usando estruturas 
\family typewriter 
PyMethodDef
\family default 
, é possível ainda criar um objeto do tipo método explicitamente a partir
 de C com a função 
\family typewriter 
PyMethod_New
\family default 
, passando como parâmetro um objeto Python 
\begin_inset Quotes eld
\end_inset 

chamável
\begin_inset Quotes erd
\end_inset 

 e o objeto ou classe a que ele deve se referir.
 Como visto na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Python-Chamada}

\end_inset 

, objetos Python podem ser tornados 
\begin_inset Quotes eld
\end_inset 

chamáveis
\begin_inset Quotes erd
\end_inset 

 implementando um método 
\family typewriter 
__call__
\family default 
 em Python ou associando uma função C ao campo 
\family typewriter 
tp_call
\family default 
 do seu 
\family typewriter 
PyTypeObject
\family default 
 correspondente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo
\end_inset 


\layout Standard

Uma implementação simples de uma função C que pode ser registrada em Python
 como a função global 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
PyObject* teste_py(PyObject* self, PyObject* args) {
\layout LyX-Code


\size footnotesize 
   char* entrada; long n;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Em caso de erro nos argumentos, PyArg_ParseTuple
\layout LyX-Code


\size footnotesize 
\emph on 
      gera uma exceção apropriada automaticamente */
\layout LyX-Code


\size footnotesize 
   if (!PyArg_ParseTuple(args, "sl", &entrada, &n))
\layout LyX-Code


\size footnotesize 
      return NULL;
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return PyInt_FromLong(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

Como os argumentos são recebidos em uma tupla no segundo parâmetro, a assinatura
 de função empregada corresponde à flag 
\family typewriter 
METH_VARARGS
\family default 
.
 Os parâmetros de entrada são convertidos para C e verificados com 
\family typewriter 
PyArg_ParseTuple
\family default 
.
 O valor de retorno é convertido do tipo nativo C para um 
\family typewriter 
PyObject
\family default 
 com 
\family typewriter 
PyInt_FromLong
\family default 
, gerando uma nova referência.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de global
\end_inset 


\layout Standard

A API de Python é projetada primariamente para o desenvolvimento de módulos
 de extensão para a linguagem.
 Embora existam diversas funções para registrar métodos em classes e inicializar
 módulos com listas de funções, não há uma forma direta para registrar funções
 globais na máquina virtual.
 Uma maneira possível é usando a rotina utilitária para lookup de métodos
 
\family typewriter 
Py_FindMethod
\family default 
 e inserindo o método retornado no dicionário do módulo global 
\family typewriter 
__main__
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__main__"));
\layout LyX-Code


\size footnotesize 
static PyMethodDef teste_def[] = {
\layout LyX-Code


\size footnotesize 
   { "teste", (PyCFunction) teste_py, METH_VARARGS, "um teste" },
\layout LyX-Code


\size footnotesize 
   { NULL }
\layout LyX-Code


\size footnotesize 
};
\layout LyX-Code


\size footnotesize 
PyObject* teste_obj = Py_FindMethod(teste_def, NULL, "teste");
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, "teste", teste_obj);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Note que foi passado 
\family typewriter 
NULL
\family default 
 para 
\family typewriter 
Py_FindMethod
\family default 
, indicando que não há um objeto do qual o método faz parte.
 O argumento 
\family typewriter 
self
\family default 
 recebido pela função C 
\family typewriter 
teste_py
\family default 
 será também 
\family typewriter 
NULL
\family default 
 e pode ser ignorado.
 O array 
\family typewriter 
teste_def
\family default 
 foi declarado 
\family typewriter 
static
\family default 
 para garantir que o 
\family typewriter 
PyMethodDef
\family default 
 continuará válido enquanto a função global estiver registrada, pois na
 criação de 
\family typewriter 
teste_obj
\family default 
 um ponteiro para ele é armazenado internamente no objeto criado.
\layout Subsection

Ruby
\begin_inset LatexCommand \label{sub:Ruby-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções
\layout Standard

Convenção para parâmetros de entrada
\end_inset 


\layout Standard

Para que funções C possam ser chamadas a partir de Ruby, elas devem ser
 declaradas como métodos de alguma classe ou módulo, ou ainda como uma função
 global.
 Para isto, passa-se um ponteiro de uma função C e o número de argumentos
 que a função espera para uma das funções apropriadas da API de Ruby: 
\family typewriter 
rb_define_method
\family default 
, 
\family typewriter 
rb_define_module_function
\family default 
, 
\family typewriter 
rb_define_global_function
\family default 
 ou 
\family typewriter 
rb_define_singleton\SpecialChar \-
_method
\family default 
.
 O número de parâmetros passado indica a assinatura esperada para a função\SpecialChar ~
C.
 Ruby suporta explicitamente funções C com até 15 argumentos; como alternativa,
 os valores especiais -1 e -2 indicam, respectivamente, que a função C irá
 receber os parâmetros na forma de um array C de 
\family typewriter 
VALUE
\family default 
s ou na forma de um 
\family typewriter 
VALUE
\family default 
 correspondente a um array Ruby.
\layout Standard

De forma similar à função 
\family typewriter 
PyArg_ParseTuple
\family default 
 discutida na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Python}

\end_inset 

, Ruby possui uma função projetada para simplificar o processamento dos
 valores de entrada em funções\SpecialChar ~
C: 
\family typewriter 
rb_scan_args
\family default 
.
 Esta função pode ser usada quando os parâmetros de entrada são recebidos
 em um array Ruby.
 Como 
\family typewriter 
PyArg_ParseTuple
\family default 
, ela é uma função vararg que recebe uma string de formato indicando o número
 de parâmetros a serem coletados.
 Por outro lado, ela não realiza verificação de tipo dos argumentos.
 A string de formato permite indicar o número mínimo e máximo de parâmetros
 aceitos e se os parâmetros excedentes devem ser coletados em um array Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: blocos
\end_inset 


\layout Standard

Uma vez declarada no espaço de objetos de Ruby, uma função C pode ser chamada
 como qualquer outro método.
 A função C pode verificar se o código Ruby lhe passou um bloco de código
 através da função 
\family typewriter 
rb_block_given_p
\family default 
.
 O bloco pode então ser invocado com 
\family typewriter 
rb_yield
\family default 
, que recebe um 
\family typewriter 
VALUE
\family default 
 como argumento.
 Para passar múltiplos argumentos para 
\family typewriter 
rb_yield
\family default 
, deve-se passar um array Ruby.
 Para obter um 
\family typewriter 
VALUE
\family default 
 do tipo 
\family typewriter 
Proc
\family default 
 produzido a partir do bloco de código recebido é preciso usar 
\family typewriter 
rb_scan_args
\family default 
, que possui funcionalidade similar à do operador 
\family typewriter 
&
\family default 
 em declarações de funções Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Funções C implementado métodos Ruby devem sempre retornar um 
\family typewriter 
VALUE
\family default 
 (
\family typewriter 
Qnil
\family default 
 quando não há retorno).
 Funções que retornam múltiplos valores devem fazê-lo através de um array
 Ruby.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Dando continuidade à série de exemplos, a função global Ruby 
\family typewriter 
teste
\family default 
 pode ser implementada da seguinte forma em C:
\layout LyX-Code


\size footnotesize 
VALUE teste_rb(VALUE self, VALUE val_entrada, VALUE val_n) {
\layout LyX-Code


\size footnotesize 
   char* entrada = StringValuePtr(val_entrada);
\layout LyX-Code


\size footnotesize 
   long n = NUM2INT(val_n);
\layout LyX-Code


\size footnotesize 
   printf("Recebi: %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   return INT2NUM(42);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A conversão dos 
\family typewriter 
VALUE
\family default 
s de entrada é feita com as macros 
\family typewriter 
StringValuePtr
\family default 
 e 
\family typewriter 
NUM2INT
\family default 
.
 Não há código explícito para tratamento de erros na conversão pois estas
 macros disparam exceções que saem da função via 
\family typewriter 
longjmp
\family default 
 caso a conversão não seja possível.
 Para a saída, é produzido um 
\family typewriter 
VALUE
\family default 
 com a macro 
\family typewriter 
INT2NUM
\family default 
.
 O primeiro parâmetro de entrada é necessário segundo a convenção de assinaturas
 de função da API, mas para funções globais ele deve ser ignorado.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de fn global
\end_inset 


\layout Standard

Como Ruby oferece uma função na API para a definição de funções globais,
 o registro de 
\family typewriter 
teste
\family default 
 é bastante simples:
\layout LyX-Code


\size footnotesize 
rb_define_global_function("teste", teste_rb, 2); 
\layout Standard

É indicado o nome da função no espaço de Ruby, a função C correspondente
 e o número de parâmetros que ela espera (não incluindo o parâmetro 
\family typewriter 
self
\family default 
).
\layout Subsection

Java
\begin_inset LatexCommand \label{sub:Java-Registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas: métodos native
\end_inset 


\layout Standard

Métodos declarados em Java que não são implementados na própria linguagem
 devem ser declarados através de um protótipo incluindo o modificador 
\family typewriter 
native
\family default 
.
 Assim, 
\family typewriter 
native
\family default 
 não se refere a uma implementação nativa em Java, mas ao código do método
 ter sido compilado com código nativo do ambiente de execução, em oposição
 a 
\emph on 
bytecodes
\emph default 
 da máquina virtual.
 A implementação do método, usualmente encapsulada em uma biblioteca dinâmica
 C, deve ser carregada antes de sua execução usando a chamada 
\family typewriter 
System.loadLibrary
\family default 
 em Java, usualmente em um bloco 
\family typewriter 
static
\family default 
 da classe correspondente.
 Para cada método 
\family typewriter 
native
\family default 
, uma função C correspondente deve ser definida na biblioteca carregada.
\layout Standard

O utilitário 
\family typewriter 
javah
\family default 
 gera arquivos de cabeçalho C a partir de classes Java, com os protótipos
 de funções C no formato especificado pela JNI.
 Este formato especifica não apenas a assinatura dos parâmetros de entrada
 e tipo de retorno, mas também o nome da função, para que o 
\emph on 
loader
\emph default 
 realize a ligação entre a função C e o método Java na máquina virtual.
 As funções devem se chamar 
\family typewriter 
Java_
\family default 
\emph on 
<nome da classe>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<nome do método>
\emph default 
.
 No caso de sobrecarga de funções, um sufixo é adicionado indicando o tipo
 dos parâmetros de entrada (por exemplo, 
\family typewriter 
Java_Classe_metodo__DI
\family default 
 para a versão de 
\family typewriter 
Classe.metodo
\family default 
 que aceita um 
\family typewriter 
double
\family default 
 e um 
\family typewriter 
int
\family default 
 como parâmetros).
\layout Standard

Os parâmetros de entrada da função são um ponteiro para 
\family typewriter 
JNIEnv
\family default 
, que representa uma thread da JVM, um 
\family typewriter 
jobject
\family default 
 representando o objeto sobre o qual o método é aplicado (ou uma 
\family typewriter 
jclass
\family default 
 para métodos estáticos) e os demais parâmetros da função Java em suas represent
ações C, discutidas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

.
 Como o tipos dos parâmetros passados são definidos estaticamente tanto
 em Java como em C, não é preciso realizar a verificação dos tipos dos dados
 recebidos no código C.
 A assinatura das funções que implementam métodos, especificados nos arquivos
 de cabeçalho gerados pela ferramento 
\family typewriter 
javah
\family default 
, já declaram os tipos corretos.
\layout Standard

O tipo de retorno corresponde ao tipo\SpecialChar ~
C equivalente ao tipo de retorno do
 método Java.
 O valor retornado pode ser uma referência local ou global.
 Além de tratar ou propagar erros como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Java-Chamada}

\end_inset 

, funções C podem também gerar exceções com 
\family typewriter 
Throw
\family default 
 e 
\family typewriter 
ThrowNew
\family default 
 e retornar imediatamente.
 O valor de retorno será ignorado quando a exceção for capturada no código
 Java.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro de função global
\layout Standard

Funções da API para registrar funções (não há)
\end_inset 


\layout Standard

Como o modo de expor à máquina virtual de Java funções implementadas em
 C é diferente do empregado nas linguagens vistas anteriormente, pela forma
 de declarar a função para o espaço de Java, para só então mostrar a implementaç
ão de 
\family typewriter 
teste
\family default 
 em C.
 Na classe em Java, declaramos um método 
\family typewriter 
native
\family default 
:
\layout LyX-Code


\size footnotesize 
public class Exemplo {
\layout LyX-Code


\size footnotesize 
   static native int teste(String entrada, int n);
\layout LyX-Code


\size footnotesize 
\emph on 
   // ...demais membros da classe
\layout LyX-Code


\size footnotesize 
   static {
\layout LyX-Code


\size footnotesize 
      System.loadLibrary("Exemplo");
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

Após compilar esta classe podemos passá-la para o comando 
\family typewriter 
javah
\family default 
, que gerará um arquivo de cabeçalho C.
 Este arquivo conterá o nome e assinatura da função C que a JVM irá procurar
 na biblioteca que será carregada por 
\family typewriter 
System.loadLibrary
\family default 

\begin_inset Foot
collapsed false

\layout Standard

O parâmetro passado no código Java é usado como base na construção de um
 nome dependente de plataforma.
 Em sistemas Unix, por exemplo, o comando 
\family typewriter 
System.loadLibrary("Exemplo")
\family default 
 carrega o arquivo 
\family typewriter 
libExemplo.so
\family default 
.
\end_inset 

.
 Esta biblioteca deve implementar funções relativas aos métodos declarados
 como 
\family typewriter 
native
\family default 
.
\layout Standard

Abaixo, é dada uma implementação em C, usando o cabeçalho gerado por 
\family typewriter 
javah
\family default 
, para o método 
\family typewriter 
teste
\family default 
:
\layout LyX-Code


\size footnotesize 
#include <jni.h>
\layout LyX-Code


\size footnotesize 
#include <stdio.h>
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cabeçalho gerado por javah */
\layout LyX-Code


\size footnotesize 
#include "Exemplo.h" 
\layout LyX-Code


\size footnotesize 
 
\newline 
JNIEXPORT jint JNICALL
\layout LyX-Code


\size footnotesize 
Java_Exemplo_teste(JNIEnv* J, jclass c, jstring obj_entrada, jint n) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = (*J)->GetStringUTFChars(J, obj_entrada, NULL);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   (*J)->ReleaseStringUTFChars(J, obj_entrada, entrada);
\layout LyX-Code


\size footnotesize 
   return 42;
\layout LyX-Code


\size footnotesize 
} 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard


\family typewriter 
JNIEXPORT
\family default 
 e 
\family typewriter 
JNICALL
\family default 
 são macros definidas em 
\family typewriter 
jni.h
\family default 
 para dar maior portabilidade ao código C gerado.
 Como o método foi declarado como 
\family typewriter 
static
\family default 
 em Java, uma referência para a classe é recebida como parâmetro para a
 função.
 Os demais parâmetros correspondem aos parâmetros do método Java, e são
 dados nos tipos equivalentes da JNI.
 Conforme discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Dados-Java}

\end_inset 

, a JNI dá tratamentos diferentes para tipos de referência e tipos imediatos.
 Desta forma, somente o parâmetro 
\family typewriter 
obj_entrada
\family default 
 precisa ser convertido para C; tanto 
\family typewriter 
n
\family default 
 como o valor de retorno podem ser usados diretamente como tipos básicos
 de C.
\layout Standard

A string obtida com 
\family typewriter 
GetStringUTFChars
\family default 
 é convertida para UTF-8 a partir da representação Unicode interna de Java.
 O mesmo ponteiro pode ser retornado pela JVM a diferentes threads que solicitem
 a mesma string.
 Deste modo, o código C deve notificar a sua liberação explicitamente com
 
\family typewriter 
ReleaseStringUTFChars
\family default 
.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valor de retorno
\end_inset 


\layout Standard

Neste exemplo, a função retorna um valor imediato.
 Valores representados com tipos de referência podem ser retornados tanto
 com referências locais como globais.
\layout Subsection

Lua
\begin_inset LatexCommand \label{sub:Lua-Registro}

\end_inset 


\layout Standard

Funções C expostas ao espaço de Lua devem ter o tipo 
\family typewriter 
lua_CFunction
\family default 
, recebendo como único parâmetro um ponteiro para uma variável do tipo 
\family typewriter 
lua_State
\family default 
 e retornando um 
\family typewriter 
int
\family default 
.
 Um 
\family typewriter 
lua_State
\family default 
 encapsula todo o estado da máquina virtual de Lua; múltiplos estados Lua
 podem ser mantidos em paralelo.
 Todas as funções da API 
\emph on 
core
\emph default 
 de Lua recebem um 
\family typewriter 
lua_State
\family default 
 como primeiro parâmetro, exceto 
\family typewriter 
lua_newstate
\family default 
, que cria um 
\family typewriter 
lua_State
\family default 
 novo.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Convenções p/ parâmetros de entrada
\end_inset 


\layout Standard

Ao início da função C, os argumentos passados a ela encontram-se inseridos
 na pilha virtual.
 Como em funções Lua, não há verificação sobre o número de argumentos passados
 para uma função C invocada a partir de Lua ou através da API.
 O código C pode verificar o número de argumentos passados inspecionando
 o tamanho da pilha recebida.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Verificar valores de entrada
\end_inset 


\layout Standard

A biblioteca auxiliar provê ainda funções para verificar de forma mais convenien
te o tipo dos argumentos passados.
 Funções da família 
\family typewriter 
luaL_check
\family default 
* (
\family typewriter 
luaL_checkint
\family default 
, 
\family typewriter 
luaL_check\SpecialChar \-
string
\family default 
, etc.) verificam o tipo de um elemento da pilha e o retornam, sinalizando
 erro caso o tipo do elemento não seja o requisitado.
 As funções 
\family typewriter 
luaL_opt
\family default 
* se comportam de forma similar, permitindo ainda indicar um valor padrão
 caso o elemento esteja ausente ou seja 
\family typewriter 
nil
\family default 
.
 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

Valores de retorno também são passados pela função C de volta para Lua através
 da pilha virtual.
 O valor inteiro retornado da função C indica quantos elementos da pilha
 devem ser retornados à função chamadora.
 Os demais valores da pilha são descartados.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Funções da API p/ registrar funções
\end_inset 


\layout Standard

Uma função C do tipo 
\family typewriter 
lua_CFunction
\family default 
 pode ser passada para o espaço de Lua através da função 
\family typewriter 
lua_pushcfunction
\family default 
.
 Lua possui também algumas funções de conveniência para registrar um conjunto
 de funções C de uma só vez.
 De forma similar ao uso de arrays 
\family typewriter 
PyMethodDef
\family default 
 em Python, a função 
\family typewriter 
luaL_register
\family default 
 registra uma lista de funções, recebendo um array de estruturas 
\family typewriter 
luaL_Reg
\family default 
 contendo nomes e ponteiros de função.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

A função C implementando a função de exemplo 
\family typewriter 
teste
\family default 
 é dada a seguir:
\layout LyX-Code


\size footnotesize 
int teste_lua(lua_State* L) {
\layout LyX-Code


\size footnotesize 
   const char* entrada = luaL_checkstring(L, 1); 
\emph on 
/* Obtém o primeiro parâmetro */
\layout LyX-Code


\size footnotesize 
   long n = luaL_checkinteger(L, 2);             
\emph on 
/* Obtém o segundo parâmetro */
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   lua_pushinteger(L, 42);                       
\emph on 
/* Empilha o valor de retorno */
\layout LyX-Code


\size footnotesize 
   return 1;                             
\emph on 
/* Retorna um valor, do topo da pilha */
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A função tem assinatura idêntica à definição de 
\family typewriter 
lua_CFunction
\family default 
.
 Os parâmetros de entrada são obtidos das posições 1 e 2 da pilha e os seus
 tipos são verificados usando as funções da biblioteca auxiliar 
\family typewriter 
luaL_checkstring
\family default 
 e 
\family typewriter 
luaL_checkinteger
\family default 
.
 Estas funções sinalizam erro em caso de falha na conversão, causando um
 
\family typewriter 
longjmp
\family default 
 como em Ruby.
\layout Standard

A string retornada o tipo da string obtida é do tipo 
\family typewriter 
const char*
\family default 
, pois ela aponta um bloco de memória gerenciado pela máquina virtual.
 Em Lua, no entanto, não é preciso notificar a liberação da string explicitament
e, pois esta permanece válida enquanto o valor estiver na pilha.
 Como as funções 
\family typewriter 
luaL_check
\family default 
* não desempilham os parâmetros e a pilha é esvaziada implicitamente ao
 final da função C, a string C obtida permanecerá válida ao longo da função.
\layout Standard

Ao fim da função 
\family typewriter 
teste_lua
\family default 
, o valor de retorno para Lua é empilhado usando 
\family typewriter 
lua_push\SpecialChar \-
integer
\family default 
.
 O valor de retorno da função em C, 
\family typewriter 
1
\family default 
, indica à máquina virtual que há um único valor de saída a ser obtido da
 pilha e usado como retorno da função em Lua.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de registro
\end_inset 


\layout Standard

A função é registrada em Lua criando um objeto Lua do tipo 
\family typewriter 
function
\family default 
 a partir da função C e armazenando este objeto em uma variável global.
 Isto poderia ser feito com 
\family typewriter 
lua_pushcclosure
\family default 
 e 
\family typewriter 
lua_setglobal
\family default 
, mas o arquivo de cabeçalho 
\family typewriter 
lua.h
\family default 
 possui uma macro que encapsula estas duas chamadas.
 Assim, a função pode ser registrada simplesmente com:
\layout LyX-Code


\size footnotesize 
lua_register(L, "teste", teste_lua);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Usando a função 
\family typewriter 
lua_pushcclosure
\family default 
, é possível associar a uma função C valores Lua que serão acessíveis à
 função sempre que esta for chamada, de forma similar a variáveis locais
 
\family typewriter 
static
\family default 
 C.
 Este recurso provê uma funcionalidade similar às 
\emph on 
closures
\emph default 
 de Lua, porém mais limitado: os valores associados são privados às funções
 C, enquanto em Lua duas 
\emph on 
closures
\emph default 
 definidas num mesmo escopo terão acesso às mesmas variáveis, isto é, alterações
 nos valores em uma afetarão a outra.
 Esta forma restrita, porém, já permite a implementação em C de 
\begin_inset Quotes eld
\end_inset 

funções com estado
\begin_inset Quotes erd
\end_inset 

, como iteradores e geradores.
 Uma vez registrada no espaço de Lua, funções C passam a ser vistos como
 valores do tipo 
\family typewriter 
function
\family default 
, de forma igual a funções Lua.
 De fato, 
\family typewriter 
lua_pushcfunction
\family default 
 é um caso particular de 
\family typewriter 
lua_pushcclosure
\family default 
 onde nenhum valor Lua é associado à função.
\layout Subsection

Perl
\begin_inset LatexCommand \label{sub:Perl-registro}

\end_inset 


\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Questões específicas
\end_inset 


\layout Standard

Como discutido na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

, a interface entre Perl e C foi projetada tendo em mente que a ligação
 entre as funções C e o interpretador Perl é feita através de código gerado
 a partir de uma descrição feita em uma linguagem de mais alto nível, XS.
 Código\SpecialChar ~
XS consiste de declarações de assinaturas de função com uma sintaxe
 especial, indicando regras para conversão dos parâmetros de entrada e saída,
 e código C descrevendo a implementação das funções.
 XS é projetada para o desenvolvimento de extensões Perl incluindo funções
 implementadas em C: o resultado final da compilação do código gerado pelas
 ferramentas\SpecialChar ~
XS (
\family typewriter 
h2xs
\family default 
, 
\family typewriter 
xsubpp
\family default 
) são código C e Perl que juntos descrevem um pacote Perl (um conjunto de
 variáveis e funções armazenados sob um 
\emph on 
namespace
\emph default 
 comum).
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

API para registrar funções (não tem)
\end_inset 


\layout Standard

Existe uma API pública para manipulação de dados Perl no código C, mas esta
 consiste basicamente das estruturas internas da implementação do interpretador
 expostas para uso pelo pré-processador XS, acrescida de macros para maior
 conveniência do programador.
 De fato, Perl não expõe uma API documentada para o registro de funções\SpecialChar ~

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

.
 Assim, não é prático para uma aplicação embutir um interpretador Perl e
 expor a ele um conjunto de funções C usando apenas código C.
 A saída é criar uma extensão Perl usando XS que expõe funções da aplicação
 e importar o pacote resultante no interpretador embutido.
 O emprego desta abordagem foi observada nos plugins para scripting Perl
 de diversas aplicações 
\begin_inset Foot
collapsed false

\layout Standard

Vim (
\begin_inset LatexCommand \url{http://www.vim.org}

\end_inset 

), Gimp (
\begin_inset LatexCommand \url{http://search.cpan.org/search?mode=dist&query=gimp}

\end_inset 

) e Gaim (
\begin_inset LatexCommand \url{http://gaim.sourceforge.net}

\end_inset 

) são algumas aplicações que implementam plugins Perl através de extensões
 XS.
 No plugin de Xchat (
\begin_inset LatexCommand \url{http://www.xchat.org}

\end_inset 

), não há arquivos 
\family typewriter 
.xs
\family default 
, mas os fontes 
\family typewriter 
.c
\family default 
 incluem funções declaradas com a API não documentada e o código Perl equivalent
e ao arquivo 
\family typewriter 
.pm
\family default 
 gerado por 
\family typewriter 
xsubpp
\family default 
 declarado como uma string C avaliada com 
\family typewriter 
eval_pv
\family default 
, dando a entender que o plugin foi implementado como uma extensão usando
 XS e depois convertido para um único arquivo-fonte C.
\end_inset 

.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Exemplo de função
\end_inset 


\layout Standard

O utilitário 
\family typewriter 
h2xs
\family default 
 gera um diretório contendo o esqueleto de um módulo Perl: um script gerador
 de Makefiles, arquivos 
\family typewriter 
.xs
\family default 
 e 
\family typewriter 
.pm
\family default 
 a serem acrescidos de código XS e Perl, além de arquivos auxiliares.
 Retomando o exemplo da função teste, ela seria declarada da seguinte forma
 em XS:
\layout LyX-Code


\size footnotesize 
long teste(entrada, n)
\layout LyX-Code


\size footnotesize 
        char* entrada
\layout LyX-Code


\size footnotesize 
        int n
\layout LyX-Code


\size footnotesize 
        CODE:
\layout LyX-Code


\size footnotesize 
                printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
                RETVAL = 42;
\layout LyX-Code


\size footnotesize 
        OUTPUT:
\layout LyX-Code


\size footnotesize 
                RETVAL 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Parâmetros de entrada
\end_inset 


\layout Standard

O arquivo 
\family typewriter 
.xs
\family default 
 é convertido para 
\family typewriter 
.c
\family default 
 com 
\family typewriter 
xsubpp
\family default 
.
 O código C para a conversão dos parâmetros de entrada e saída é gerado
 automaticamente.
 Em alguns casos, entretanto, precisamos manipular os valores da pilha de
 Perl explicitamente, como descrito na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-Dados}

\end_inset 

.
 Em funções vararg, por exemplo, os argumentos adicionais devem ser acessados
 diretamente na pilha.
 O código para registrar as funções do módulo também é gerado automaticamente.
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

Valores de retorno
\end_inset 


\layout Standard

XS cria uma variável 
\family typewriter 
RETVAL
\family default 
 automaticamente para armazenamento do valor de retorno em código C.
 O conteúdo desta variável é convertido para um valor Perl pelo código C
 gerado.
 Para que funções que retornam arrays possam operar corretamente em contextos
 escalares, deve-se verificar o contexto em que a função é chamada com 
\family typewriter 
GIMME_V
\family default 
 e então retornar um 
\family typewriter 
SV
\family default 
 ou 
\family typewriter 
AV
\family default 
 conforme o caso.
 A função, nestes casos, deve ser declarada com tipo de retorno 
\family typewriter 
SV*
\family default 
, fazendo com que os valores de C devam ser convertidos para 
\family typewriter 
SV
\family default 
s Perl explicitamente.
 A documentação alerta que, para o caso de 
\family typewriter 
AV
\family default 
s, deve-se declarar o valor de retorno como variável mortal
\begin_inset Foot
collapsed false

\layout Standard

Este comportamento é descrito na documentação como 
\emph on 

\begin_inset Quotes eld
\end_inset 

an unfixable bug (fixing it would break lots of existing CPAN modules)
\begin_inset Quotes erd
\end_inset 


\emph default 
 
\begin_inset LatexCommand \cite{roehrich06perlxs}

\end_inset 

.
 
\end_inset 

.
\layout Standard

Uma vez compilada a extensão usando os Makefiles gerados por 
\family typewriter 
h2xs
\family default 
, a extensão pode ser carregada e usada a partir de Perl:
\layout LyX-Code


\size footnotesize 
use Teste;
\layout LyX-Code


\size footnotesize 
$ret = Teste::teste("entrada", 2);
\layout LyX-Code


\size footnotesize 
print $ret .
 "
\backslash 
n";
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Para expor funções de uma aplicação C a um interpretador Perl embutido nela,
 devemos criar uma extensão que encapsula estas funções usando XS, ligar
 a extensão à aplicação e carregá-la.
 A carga é feita passando para o interpretador uma função C contendo chamadas
 
\family typewriter 
newXS
\family default 
 durante a sua inicialização.
 O módulo Perl 
\family typewriter 
ExtUtils::Embed
\family default 
 possui uma rotina 
\family typewriter 
xsinit
\family default 
 para gerar o código C desta função.
 Na prática, gerar o código da função com 
\family typewriter 
xsinit
\family default 
 é a melhor abordagem, já que a inicialização depende de rotinas não documentada
s (o exemplo de função de inicialização incluído na documentação de Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

 está desatualizado).
\layout Subsection

Comparação
\layout Standard

Python e Ruby oferecem ao programador diferentes opções de assinaturas de
 função\SpecialChar ~
C reconhecidas pela API, o que é prático, uma vez que pode-se escolher
 assim diferentes representações em C para os parâmetros de entrada (agregados
 em um array, recebidos um a um, etc.) conforme o seu uso na função.
 Lua oferece apenas uma assinatura de função possível para funções C a serem
 registradas na máquina virtual, mas isto é apropriado para o modelo de
 pilha usado por sua API.
\layout Standard

Em Java, as assinaturas de função são criadas através da ferramenta 
\family typewriter 
javah
\family default 
 -- devido à tipagem estática, os tipos dos parâmetros de entrada passados
 por Java são convertidos automaticamente pela JNI, o que é bastante conveniente
 uma vez que evita operações explícitas de conversão e verificação de tipos
 na função.
 Por terem tipagem dinâmica, as demais linguagens oferecem funções na API
 específicas para realizar estas verificações.
 As assinaturas de função em Perl são criadas apenas através da ferramenta
 XS, mas diferentemente de Java elas não são expostas ao programador.
 Isto traz a inconveniência de termos que pré-processar o código C como
 uma extensão XS mesmo quando estamos embutindo Perl em uma aplicação.
\layout Standard

O registro de funções em Ruby e Lua é simples.
 Em Lua, em particular, trata-se de uma atribuição igual à de qualquer outro
 objeto.
 Já em Python, existem recursos para o registro de funções em lote, usando
 arrays 
\family typewriter 
PyMethodDef
\family default 
 (Lua oferece recurso similar com 
\family typewriter 
luaL_register
\family default 
), mas não há uma forma simples de registrar uma única função.
 Tanto em Java como em Perl o registro de funções é feito de forma implícita,
 e em nenhuma das duas APIs há funções para registrar novas funções C durante
 a execução do programa.
\layout Chapter


\begin_inset LatexCommand \label{cha:Estudo-de-caso:}

\end_inset 

Estudo de caso: LibScript
\layout Standard

No capítulo anterior, foram discutidas as principais questões envolvendo
 interfaces de linguagens para C e a forma como estas questões são tratadas
 pelas linguagens abordadas neste estudo.
 Neste capítulo, realizaremos uma comparação entre as APIs através de um
 exemplo concreto, de modo a colocar implementações em cada uma das linguagens
 lado a lado.
 O exemplo consiste em uma biblioteca genérica para scripting, chamada LibScript
, e uma série de plugins que realizam a interface com as diferentes linguagens
 de script.
\layout Section

LibScript
\layout Standard

LibScript é uma biblioteca projetada para tornar aplicações extensíveis
 através de scripting de uma forma independente de linguagem.
 Ela é baseada em uma arquitetura de 
\emph on 
plugins
\emph default 
, de modo a desacoplar a aplicação dos ambientes de execução providos pelas
 diversas linguagens.
 A biblioteca principal provê uma API para scripting independente de linguagem,
 permitindo a uma aplicação registrar as suas funções e disparar scripts
 que as utilizem.
 Esta biblioteca então invoca o plugin da linguagem apropriada para rodar
 o script (por exemplo, LibScript-Python para código Python).
 Desta forma, o desenvolvedor da aplicação permite ao seu usuário utilizar
 diferentes linguagens para scripting sem adicionar todas elas como dependências
 do programa.
\layout Standard

A biblioteca principal disponibiliza recursos para o registro de funções
 C por parte da aplicação e para a chamada destas funções por parte dos
 plugins (permitindo aos scripts acessar as funções), além de funções para
 a transferência de dados entre as duas partes.
 É possível também invocar funções implementadas nas máquinas virtuais embutidas
 nos plugins, possibilitando assim que scripts escritos em diferentes linguagens
 possam interagir.
\layout Subsection

Arquitetura de LibScript
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura1.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Visão-geral}

\end_inset 

Visão geral da arquitetura de LibScript
\end_inset 


\layout Standard

LibScript é composta de uma biblioteca dinâmica principal, 
\family typewriter 
libscript
\family default 
, e 
\emph on 
plugins
\emph default 
 para diferentes linguagens (Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Visão-geral}

\end_inset 

).
 A biblioteca principal é ligada a uma aplicação, e expõe a ela uma API
 de scripting independente de linguagem, que permite executar arquivos,
 strings de código e invocar funções.
 Esta biblioteca é uma fina camada que encaminha estas operações para os
 plugins, que são bibliotecas dinâmicas auxiliares, carregadas em tempo
 de execução pela biblioteca principal.
 Estes plugins embutem os ambientes de execução das linguagens de script.
\layout Standard

A aplicação pode registrar funções C na biblioteca principal (ilustrado
 pela função 
\family typewriter 
c_fun
\family default 
 na figura) e solicitar a ela que execute scripts que registram funções
 nas diferentes linguagens.
 Todavia, a aplicação não interage diretamente com os plugins.
 Quando a biblioteca principal recebe código a ser executado em uma determinada
 linguagem, ela carrega o plugin adeqüado (caso este ainda não esteja carregado)
 e encaminha o código.
 O plugin irá executar o script em sua máquina virtual, o que pode registrar
 nela novas funções (ilustrado pelas funções 
\family typewriter 
py_fun
\family default 
, 
\family typewriter 
r_fun
\family default 
, 
\family typewriter 
l_fun
\family default 
 e 
\family typewriter 
pl_fun
\family default 
 na figura).
\layout Standard

A biblioteca principal decide qual plugin carregar através de um identificador
 que especifica qual a linguagem do código a ser executado.
 Este identificador pode ser obtido a partir da extensão de arquivo de um
 script carregado, da linha de identificação 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 no início do script
\begin_inset Foot
collapsed true

\layout Standard

A linha 
\begin_inset Quotes eld
\end_inset 


\family typewriter 
#!
\family default 

\begin_inset Quotes erd
\end_inset 

 é usada apenas para detectar a linguagem em que o script é escrito.
 Por exemplo, uma linha 
\family typewriter 
#!/usr/bin/perl -w
\family default 
 indicará a carga do plugin 
\family typewriter 
libscript-perl
\family default 
, mas o interpretador Perl em 
\family typewriter 
/usr/bin
\family default 
 não é usado e nem a flag 
\family typewriter 
-w
\family default 
 passada é considerada.
\end_inset 

 ou mesmo passado explicitamente pela aplicação.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard
\align center 

\begin_inset Graphics
	filename figura2.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{cap:Ambientes-virtuais}

\end_inset 

Ambientes virtuais em LibScript
\end_inset 


\layout Standard

Funções são registradas em LibScript em um 
\emph on 
ambiente virtual
\emph default 
.
 A aplicação pode criar um ou mais ambientes na biblioteca principal, identifica
ndo-os com um nome.
 Um ambiente virtual ganha em cada plugin uma estrutura de dados específica
 da linguagem (classe, módulo, etc.) que o representará.
 No exemplo da Figura\SpecialChar ~

\begin_inset LatexCommand \ref{cap:Ambientes-virtuais}

\end_inset 

 temos dois ambientes virtuais criados pela aplicação na biblioteca principal,
 
\family typewriter 
X
\family default 
 e 
\family typewriter 
Y
\family default 
.
 Em cada um destes ambientes, a aplicação registrou uma função C com o nome
 
\family typewriter 
c_fun
\family default 
 (que podem ou não corresponder à mesma função C).
 Scripts foram executados nestes ambientes, o que causou a carga dos plugins.
 No exemplo, estes scripts registraram algumas funções (
\family typewriter 
X.py_fn
\family default 
, 
\family typewriter 
Y.py_fn
\family default 
, 
\family typewriter 
X#r_fun
\family default 
, etc.).
\layout Standard

À parte da função para criação de ambientes virtuais, todas as demais funções
 da API de LibScript recebem como parâmetro um ambiente virtual sobre a
 qual elas devem operar.
 Isto indica em qual estrutura de C devem ser armazenadas mensagens de erro
 e valores de retorno.
 No caso de linguagens que permitem múltiplos estados de execução independentes,
 como Lua e Perl, isto indica também em qual estado o script deve executar.
\layout Standard

Quando um script declara uma função no ambiente virtual, esta função passa
 a ser acessível através da API de LibScript.
 Por exemplo, no plugin Lua, o ambiente virtual é representado por uma tabela
 com o nome do ambiente; uma vez que um método Ruby\SpecialChar ~

\family typewriter 
r
\family default 
 é declarado na classe 
\family typewriter 
X
\family default 
, esta função passa a poder ser invocada por C (através da API de LibScript)
 ou pelos outros plugins.
 Assim, por exemplo, embora na tabela Lua que implementa o ambiente virtual
 
\family typewriter 
X
\family default 
 só conste a função 
\family typewriter 
l_fun
\family default 
, scripts Lua podem invocar as demais funções através do ambiente virtual,
 como 
\family typewriter 
X.c_fun
\family default 
 e 
\family typewriter 
X.r_fun
\family default 
.
 Estas chamadas serão tratadas pela biblioteca principal e resolvidas por
 ela, no caso de funções C como 
\family typewriter 
X.c_fun
\family default 
, ou repassadas para o plugin apropriado, como no caso de 
\family typewriter 
X.r_fun
\family default 
, realizando a chamada no plugin Ruby e passando os valores de retorno para
 o plugin Lua.
 A biblioteca principal localiza a função a ser executada consultando os
 plugins, conforme será explicado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:A-API-de-plugins}

\end_inset 

.
\layout Standard

Na implementação dos plugins, utilizamos recursos oferecidos pelas linguagens
 para tratar acessos a elementos inexistentes nas estruturas, capturando
 estes acessos e repassando-os para a biblioteca principal.
 Estes recursos serão discutidos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

.
\layout Subsection


\begin_inset LatexCommand \label{sec:A-Camada-Independente}

\end_inset 

A API da biblioteca principal
\layout Standard

A API oferecida por LibScript isola a aplicação das diferentes APIs oferecidas
 pelas linguagens de script.
 Não se trata apenas de adicionar uma camada de indireção entre as chamadas,
 o que seria apropriado apenas para os recursos que são comuns a todas elas,
 como inicialização e chamadas de função.
 A questão principal aí são os vários recursos particulares a cada linguagem.
 Uma abordagem pouco prática seria definir a API como a união dos conjuntos
 de recursos de todas as linguagens a ser suportadas (oferecer recursos
 de manipulação de seqüências para mapear este recurso de Python, recursos
 de manipulação de tabelas para Lua, e assim por diante).
 Este caminho traria vários problemas: a API seria complexa e provavelmente
 precisaria ser estendida a cada nova linguagem introduzida; mesmo para
 mapeamentos que aparentemente poderiam ser reaproveitados (por exemplo,
 mapear 
\emph on 
hashes
\emph default 
 de Python e tabelas de Lua para uma mesma API de 
\emph on 
arrays
\emph default 
 associativos) há o problema de sutis variações de semântica entre as implementa
ções dos recursos nas diferentes linguagens.
 Além disso, bindings de aplicações poderiam oferecer funcionalidades disponívei
s apenas para uma linguagem, indo contra a proposta de independência de
 linguagem de LibScript.
\layout Standard

Outra abordagem é, ao invés de expor a API da linguagem à aplicação, expor
 apenas uma API de funções da aplicação para a linguagem e manter as estruturas
 de dados e recursos desta restrito ao domínio que será invocado.
 A aplicação interage com a máquina virtual enviando strings de código a
 ser executado e obtém resultados de volta quando o script passa parâmetros
 ao chamar funções da aplicação.
 Esta abordagem é proposta em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas02ltn004}

\end_inset 

 e utiliza o que, por exemplo, Python chama de 
\begin_inset Quotes eld
\end_inset 

very high level layer
\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum06extpy,vanrossum06ref}

\end_inset 

.
 Oferecer uma primitiva para a execução de uma string de código é algo básico
 em linguagens voltadas a script -- 
\family typewriter 
luaL_loadstring
\family default 
 em Lua, 
\family typewriter 
PyRun_SimpleString
\family default 
 em Python, 
\family typewriter 
rb_eval_string
\family default 
 em Ruby , 
\family typewriter 
perl_eval_sv
\family default 
 em Perl\SpecialChar ~

\begin_inset LatexCommand \cite{maceachern06perlembed}

\end_inset 

.
\layout Standard


\begin_inset Float figure
wide false
collapsed false

\layout Standard


\begin_inset Graphics
	filename figura3.eps
	width 100col%
	keepAspectRatio

\end_inset 


\layout Caption


\begin_inset LatexCommand \label{fig:API-para-execução}

\end_inset 

API para execução de código em LibScript
\end_inset 


\layout Standard

LibScript adota esta abordagem mais minimalista para sua API: não são oferecidas
 operações específicas para manipulação de estruturas de dados, apenas para
 a 
\emph on 
execução de strings
\emph default 
 -- 
\family typewriter 
script_run
\family default 
 (e a função de conveniência 
\family typewriter 
script_run_file
\family default 
, que lê um arquivo e o envia para 
\family typewriter 
script_run
\family default 
) -- e 
\emph on 
chamadas de função
\emph default 
 com tipos básicos (números e strings) -- 
\family typewriter 
script_call
\family default 
.
 Operações sobre dados mais complexos de tipos específicos de cada linguagem,
 quando necessárias, podem ser encapsuladas em funções implementadas nas
 linguagens de script.
 Pode-se ainda referenciar objetos da linguagem a partir de C armazenando-as
 em estruturas na linguagem de script e retornando a C índices numéricos
 destas estruturas, servindo como 
\emph on 
handles
\emph default 
 de alto nível para os objetos.
\layout Standard

A Figura\SpecialChar ~

\begin_inset LatexCommand \ref{fig:API-para-execução}

\end_inset 

 ilustra a interação entre a aplicação, a biblioteca principal e os plugins
 em relação a estas duas operações fundamentais, simbolizadas pelas funções
 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_call
\family default 
.
 Para a execução de strings, a biblioteca principal recebe da aplicação
 a entrada e repassa o código a ser executado para o plugin apropriado.
 Em 
\family typewriter 
script_run
\family default 
, são passadas duas strings, uma identificando a linguagem e outra contendo
 o código; em 
\family typewriter 
script_run_file
\family default 
, um nome de arquivo
\begin_inset Foot
collapsed false

\layout Standard

Para código executado com 
\family typewriter 
script_run_file
\family default 
, a linguagem é automaticamente detectada como discutido na seção anterior.
\end_inset 

.
 O exemplo a seguir declara um ambiente virtual, registra uma função C chamada
 
\family typewriter 
hello
\family default 
 e a invoca a partir de código Lua:
\layout LyX-Code


\size footnotesize 
script_env* env = script_init("exemplo");
\layout LyX-Code


\size footnotesize 
script_new_function(env, hello, "hello");
\layout LyX-Code


\size footnotesize 
script_run(env, "lua", "exemplo.hello()");
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O ambiente virtual é declarado com a função 
\family typewriter 
script_init
\family default 
, que recebe o nome que identificará o ambiente e retorna um identificador
 do tipo 
\family typewriter 
script_env
\family default 
, um ponteiro opaco que representa um ambiente virtual.
 A função C é registrada usando a função 
\family typewriter 
script_new_\SpecialChar \-
function
\family default 
, que recebe como parâmetros o ambiente, a função a ser registrada e o nome
 que a função terá no ambiente virtual.
 No código Lua, a função é acessada como um elemento 
\family typewriter 
hello
\family default 
 (nome registrado da função) da tabela 
\family typewriter 
exemplo
\family default 
 (nome do ambiente virtual).
\layout Standard

Para a chamada de funções, a aplicação deve passar os parâmetros de entrada
 (a forma será discutida mais adiante), e chamar 
\family typewriter 
script_call
\family default 
, indicando o nome de uma função registrada no ambiente virtual.
 A mesma função 
\family typewriter 
script_call
\family default 
 é usada pelos plugins quando eles desejam invocar funções do ambiente virtual
 registradas em C ou implementadas por outros plugins.
\layout Standard

Por este motivo, procuramos usar uma API para transferência de dados genérica,
 a ser usada tanto na entrada como na saída de dados, tanto na comunicação
 entre a aplicação e a biblioteca principal como entre a biblioteca principal
 e os plugins.
 Optamos por uma abordagem similar às empregadas em Lua (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-chamada}

\end_inset 

) e Perl (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

) para o envio de dados na passagem de parâmetros e obtenção de valores
 de retorno, usando um buffer interno como área de transferência.
 Diferentemente destas linguagens, entretanto, passamos índices para os
 parâmetros explicitamente ao invés de empregar uma disciplina de pilha.
 As funções 
\family typewriter 
script_
\family default 
{
\family typewriter 
get
\family default 
,
\family typewriter 
put
\family default 
}_{
\family typewriter 
string
\family default 
,
\family typewriter 
int
\family default 
,
\family typewriter 
double
\family default 
,
\family typewriter 
bool
\family default 
} são usadas na entrada e saída de valores.
 As funções 
\family typewriter 
script_put_
\family default 
* armazenam valores no buffer interno e 
\family typewriter 
script_get_
\family default 
* os removem.
 Uma chamada a uma função teste passando uma string e um inteiro como parâmetros
 e obtendo um inteiro como resultado é realizada da seguinte forma:
\layout LyX-Code


\size footnotesize 
script_put_string(env, 0, "entrada"); /* índice 0: "entrada" */
\layout LyX-Code


\size footnotesize 
script_put_int(env, 1, 2);            /* índice 1: 2 */
\layout LyX-Code


\size footnotesize 
script_call(env, "teste");
\layout LyX-Code


\size footnotesize 
resultado = script_get_int(env, 0);   /* retorna índice 0 */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Chamadas de função são disponibilizadas como uma operação primitiva pois
 elas permitem um grau mínimo de interoperabilidade de forma independente
 de linguagem.
 Dois objetivos são atingidos desta forma.
 O primeiro é que assim programas C embutindo LibScript podem acessar a
 funcionalidade de scripts carregados sem precisar incluir no seu código
 strings de texto em alguma linguagem específica, por exemplo, inserindo
 em seu código uma chamada a uma função de 
\emph on 
callback
\emph default 
 a ser definida via script.
 Note que no exemplo acima, não é especificada a linguagem em que a função
 
\family typewriter 
teste 
\family default 
é implementada.
 Se a chamada fosse feita via execução de string de código, isto atrelaria
 a aplicação a pelo menos uma linguagem de script.
 Usando 
\family typewriter 
script_run_file
\family default 
 e 
\family typewriter 
script_call
\family default 
, pode-se implementar uma aplicação extensível sem especificar explicitamente
 a linguagem de script a ser usada.
 O segundo objetivo é permitir que os próprios plugins possam invocar funções
 definidas em outros plugins.
 De qualquer forma, necessariamente teríamos que prover aos plugins uma
 função de chamada, para que eles pudessem invocar as funções C registradas
 em LibScript.
 Tornar a função de chamada genérica o suficiente para que possa invocar
 também funções implementadas nos próprios plugins não torna, então, a API
 da biblioteca principal mais complexa.
\layout Standard

O buffer de LibScript foi projetado para ser usado apenas como uma área
 de transferência temporária entre a biblioteca principal e os plugins,
 e não como uma facilidade geral para armazenamento e manipulação de dados.
 Assim, a sua API é voltada para a inserção e remoção seqüencial de elementos.
 Por exemplo, a inserção de um elemento na posição 0 automaticamente zera
 o buffer, evitando em muitos casos a necessidade de usar a função 
\family typewriter 
script_reset_buffer
\family default 
, que realiza tal operação explicitamente.
\layout Standard

Funções C registradas com 
\family typewriter 
script_new_function
\family default 
 devem receber o ambiente virtual como parâmetro e retornar um código de
 erro.
 As funções 
\family typewriter 
script_get_
\family default 
* e 
\family typewriter 
script_put_
\family default 
* são usadas para receber parâmetros e retornar valores ao implementar funções
 que podem ser chamadas via LibScript, da mesma forma que são usadas para
 passar parâmetros e obter valores de retorno ao realizar chamadas com 
\family typewriter 
script_call
\family default 
.
\layout LyX-Code


\size footnotesize 
script_err teste_lua(script_env* env) {
\layout LyX-Code


\size footnotesize 
   char* entrada = script_get_string(env, 0);  
\emph on 
/* Entrada, índice 0: string */
\layout LyX-Code


\size footnotesize 
   int n = script_get_int(env, 1);             
\emph on 
/* Entrada, índice 1: inteiro */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Sai da função com erro se algum script_get_* falhou */
\layout LyX-Code


\size footnotesize 
   SCRIPT_CHECK_INPUTS(env);
\layout LyX-Code


\size footnotesize 
   printf("Recebi %s e %ld 
\backslash 
n", entrada, n);
\layout LyX-Code


\size footnotesize 
   free(entrada);
\layout LyX-Code


\size footnotesize 
   script_put_int(env, 0, 42);                 
\emph on 
/* Retorno, índice 0: inteiro */
\layout LyX-Code


\size footnotesize 
   return SCRIPT_OK;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript as strings retornadas por 
\family typewriter 
script_get_string
\family default 
 pertencem à função chamadora, sendo responsabilidade dela desalocar a memória,
 diferentemente do que ocorre nas funções similares das APIs das linguagens
 discutidas neste trabalho.
 Tal decisão foi tomada devido ao caráter temporário do buffer de LibScript:
 retornar ao chamador um ponteiro para uma string cuja validade seria restrita
 até a próxima chamada da API seria algo pouco intuitivo, e na prática forçaria
 freqüentemente o programador a fazer uma cópia da string.
\layout Subsection

A API de plugins
\begin_inset LatexCommand \label{sub:A-API-de-plugins}

\end_inset 


\layout Standard

Um plugin que embute uma linguagem de script deve implementar quatro operações:
 
\family typewriter 
init
\family default 
, 
\family typewriter 
run
\family default 
, 
\family typewriter 
call
\family default 
 e 
\family typewriter 
done
\family default 
.
 A biblioteca principal espera que a biblioteca dinâmica que implementa
 o plugin de uma linguagem exporte quatro funções, com nomes do tipo
\family typewriter 
 script_plugin_
\family default 
\emph on 
<operação>
\family typewriter 
\emph default 
_
\family default 
\emph on 
<linguagem>
\emph default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 é responsável pela inicialização de um plugin, e é chamada pela função
 
\family typewriter 
script_init
\family default 
 da biblioteca principal.
 Na inicialização de um plugin, a biblioteca principal passa à função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 um ponteiro 
\family typewriter 
script_env
\family default 
 e recebe um 
\family typewriter 
script_plugin_state
\family default 
, que é um tipo opaco que é sempre passado de volta ao plugin nas demais
 chamadas.
 Cada plugin define a sua representação interna para 
\family typewriter 
script_plugin_state
\family default 
.
 Tipicamente, o estado da máquina virtual e o ponteiro para o ambiente LibScript
 devem ser armazenados de modo a ser posteriormente acessíveis a partir
 deste handle.
 Na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

 discutiremos como cada plugin representa o ambiente e o seu estado interno
 em 
\family typewriter 
script_plugin_state
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
 é invocada por 
\family typewriter 
script_run
\family default 
.
 Ela recebe uma string contendo código da linguagem de script, executa este
 código na máquina virtual e retorna um valor de status indicando sucesso
 ou a ocorrência de erros de compilação ou execução.
 No caso de erros, os plugins devem capturar exceções disparadas pela máquina
 virtual e retornar a constante 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
.
 Caso seja possível obter da linguagem uma mensagem de erro, esta pode ser
 propagada usando a função 
\family typewriter 
script_set_error_message
\family default 
 da biblioteca principal.
 A mensagem armazenada por ela poderá ser posteriormente consultada pela
 aplicação com a função 
\family typewriter 
script_error_message
\family default 
.
\layout Standard

A função 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 é usada por 
\family typewriter 
script_call
\family default 
, e é responsável por realizar chamadas a funções implementadas na linguagem
 embutida pelo plugin.
 Se a função foi definida no plugin, isto é, se uma função com o nome solicitado
 foi registrada na estrutura de dados que descreve o ambiente na máquina
 virtual, ela será executada, e o sucesso ou falha da execução será reportado
 de forma igual a 
\family typewriter 
script_plugin_run_
\family default 
\emph on 
<linguagem>
\emph default 
.
 Caso a função solicitada não tenha sido definida na máquina virtual, 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
\SpecialChar \-
<linguagem>
\emph default 
 deve retornar a constante 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
 Parâmetros de entrada e valores de retorno são passados através do buffer
 de parâmetros, usando as mesmas funções 
\family typewriter 
script_get_*
\family default 
 e 
\family typewriter 
script_put_*
\family default 
 da biblioteca principal que são usadas para a passagem de dados entre a
 aplicação e a biblioteca principal.
\layout Standard

A implementação da função 
\family typewriter 
script_call
\family default 
 na biblioteca principal faz uso deste comportamento dos plugins para invocar
 funções de modo independente de linguagem.
 Inicialmente, ela tenta encontrar uma função solicitada na lista de funções
 C registradas.
 Caso não haja uma função C no ambiente virtual com este nome, 
\family typewriter 
script_call
\family default 
 tenta localizar a função nos plugins carregados, chamando a função com
 
\family typewriter 
script_plugin_call_
\family default 
\emph on 
<linguagem>
\emph default 
 em cada plugin, e tentando o próximo a cada vez que recebe 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
.
\layout Standard

Finalmente, a função 
\family typewriter 
script_plugin_done_
\family default 
\emph on 
<linguagem>
\emph default 
 é chamada por 
\family typewriter 
script_done
\family default 
 quando um ambiente virtual é encerrado.
 Dependendo da representação interna usada no plugin, a finalização de um
 estado pode ou não implicar na finalização da máquina virtual.
 Preferencialmente, esta função deve remover a estrutura que descreve o
 ambiente virtual, mas, como veremos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

, isto nem sempre é possível.
\layout Section

Implementação dos plugins
\begin_inset LatexCommand \label{sec:Implementação-dos-plugins}

\end_inset 


\layout Standard

Nesta seção discutiremos os principais aspectos envolvidos na implementação
 dos plugins desenvolvidos neste estudo de caso.
 Implementamos plugins para as linguagens Python, Ruby, Lua e Perl.
 Apresentaremos aqui como é feita a representação dos estados virtuais em
 cada plugin (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

), questões envolvendo o encerramento de estados (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Encerramento-de-estados}

\end_inset 

), passagem de parâmetros entre a biblioteca principal e os plugins (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

), como a chamada de funções a partir de scripts é tratada pelos plugins
 (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Resolução-de-funções}

\end_inset 

) e a captura de erros (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

).
\layout Subsection

Representação de estados
\begin_inset LatexCommand \label{sub:Representação-de-estados}

\end_inset 


\layout Standard

O design de LibScript permite que plugins mantenham múltiplos estados de
 execução independentes.
 Idealmente estes estados seriam totalmente isolados entre si, como por
 exemplo diferentes instâncias da máquina virtual, oferecendo maior segurança
 ao ambiente de execução dos scripts.
 Todavia, as linguagens oferecem diferentes graus de isolamento possível
 entre estados independentes.
 Lua e Perl permitem múltiplas instâncias isoladas do ambiente de execução
 de forma simples, uma vez que as chamadas à API incluem um identificador
 de estado
\begin_inset Foot
collapsed false

\layout Standard

O recurso de múltiplos estados independentes é opcional em Perl, selecionado
 durante a compilação da biblioteca do interpretador.
\end_inset 

.
 Já linguagens que mantêm estado de forma estática, como Python e Ruby,
 não permitem trabalhar com múltiplos estados isolados facilmente
\begin_inset Foot
collapsed false

\layout Standard

O modelo de threads de Python oferece uma forma de alternar entre estados
 na máquina virtual obtendo objetos 
\family typewriter 
PyThreadState
\family default 
 através da chamada 
\family typewriter 
Py_NewInterpreter
\family default 
, mas isto pode causar problemas quando módulos de extensão escritos em
 C utilizam variáveis globais estáticas ou quando módulos manipulam o seu
 próprio dicionário, que é compartilhado entre estados.
 A documentação diz, desde 1999, que 
\begin_inset Quotes eld
\end_inset 


\emph on 
This is a hard-to-fix bug that will be addressed in a future release.
\emph default 

\begin_inset Quotes erd
\end_inset 

\SpecialChar ~

\begin_inset LatexCommand \cite{vanrossum99api,vanrossum06api}

\end_inset 


\end_inset 

.
 Nas linguagens que não permitem múltiplas instâncias da máquina virtual,
 podemos definir apenas espaços de nomes separados para os ambientes virtuais
 LibScript, que compartilham um único estado global de execução dentro do
 plugin.
 À representação de um estado de execução relativo a um ambiente virtual
 LibScript dentro de um plugin damos o nome de 
\emph on 
estado virtual
\emph default 
, que pode ou não corresponder a um estado de execução isolado.
\layout Standard

Como comentado na seção anterior, a função 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
 retorna à biblioteca principal um 
\family typewriter 
script_plugin_state
\family default 
, que é a representação opaca do seu estado virtual.
 O conteúdo desta representação varia de linguagem para linguagem, mas o
 princípio básico é que dois dados devem estar disponíveis a partir deste
 valor: uma referência para o ambiente virtual LibScript, recebido como
 parâmetro para 
\family typewriter 
script_plugin_init_
\family default 
\emph on 
<linguagem>
\emph default 
, para que o plugin possa fazer chamadas à biblioteca principal, e um identifica
dor que permita ao plugin acessar a estrutura de dados que representa na
 linguagem o espaço de nome de funções acessíveis via LibScript.
 No plugin Lua, esta estrutura é uma tabela; em Python, um módulo; em Ruby,
 uma classe; e em Perl, um pacote.
\layout Standard

Em LibScript-Lua, estados são implementados como 
\family typewriter 
lua_State
\family default 
s (Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Lua-Registro}

\end_inset 

).
 Desta forma, scripts executados em um ambiente são plenamente isolados
 dos demais ambientes.
 Por exemplo, a alteração do valor de uma variável global em um ambiente
 não afeta os demais.
 De fato, o 
\family typewriter 
script_plugin_state
\family default 
 retornado pelo plugin Lua é simplesmente o 
\family typewriter 
lua_State
\family default 
 convertido via cast.
 O ponteiro para o ambiente LibScript é armazenado em Lua no registro, da
 seguinte forma:
\layout LyX-Code


\size footnotesize 
lua_pushstring(L, "LibScript.env"); 
\emph on 
  /* Empilha o índice */
\layout LyX-Code


\size footnotesize 
lua_pushlightuserdata(L, env);        
\emph on 
/* Empilha o ambiente LibScript */
\layout LyX-Code


\size footnotesize 
lua_settable(L, LUA_REGISTRYINDEX);   
\emph on 
/* registro["LibScript.env"] = env */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O plugin cria neste 
\family typewriter 
lua_State
\family default 
 uma tabela que representará o ambiente virtual para scripts Lua.
 Esta tabela é armazenada no 
\family typewriter 
lua_State
\family default 
 como uma variável global com o nome do ambiente virtual.
\layout Standard

Em LibScript-Perl os estados são isolados como em Lua.
 Cada estado criado inicializa uma nova instância de 
\family typewriter 
PerlInterpreter
\family default 
.
 Neste interpretador, é criado um pacote que será a representação do ambiente
 visível a partir de código Perl.
 O tipo 
\family typewriter 
script_plugin_state
\family default 
, então, é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PerlInterpreter
\family default 
*.
\layout Standard

Como discutido na seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-registro}

\end_inset 

, a implementação de funções C exportadas para um interpretador Perl é feita
 escrevendo um módulo de extensão usando o pré-processador XS, e a forma
 de obter comunicação no sentido Perl
\begin_inset Formula $\rightarrow$
\end_inset 

C em uma máquina virtual embutida é ligando um módulo de extensão juntamente
 com a máquina virtual.
 Assim, parte do plugin LibScript-Perl é implementado como um módulo XS,
 exposto na máquina virtual embutida como o pacote Perl 
\family typewriter 
LibScript
\family default 
.
 Durante a inicialização de um estado virtual, o ponteiro para o ambiente
 virtual LibScript é armazenado neste pacote, na variável 
\family typewriter 
$LibScript::env
\family default 
.
 O pacote que representa o ambiente virtual é criado pela função 
\family typewriter 
script_plugin_init_perl
\family default 
, executando a string de código 
\family typewriter 
"package 
\family default 
\emph on 
<ambiente>
\family typewriter 
\emph default 
;"
\family default 
 com a função 
\family typewriter 
Perl_eval_pv
\family default 
.
\layout Standard

Como Python não dispõe de facilidades para disparar múltiplas máquinas virtuais
 plenamente isoladas, o plugin Python implementa estados virtuais apenas
 como módulos separados, compartilhando um mesmo estado global.
 Durante a inicialização de um estado, é criado um módulo Python com o nome
 do ambiente.
 O seguinte trecho da função 
\family typewriter 
script_plugin_init_python
\family default 
 exibe a seqüência onde o módulo é criado e importado:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém o nome do ambiente */
\layout LyX-Code


\size footnotesize 
char* namespace = script_namespace(env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Cria o módulo.
 O primeiro parâmetro é o nome do módulo,
\layout LyX-Code


\size footnotesize 
\emph on 
   o segundo a lista de métodos do módulo, que será inicialmente vazio.
 */
\layout LyX-Code


\size footnotesize 
PyObject* module = Py_InitModule3(namespace, NULL);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Obtém dicionário de globais */
\layout LyX-Code


\size footnotesize 
PyObject* globals = PyModule_GetDict(PyImport_AddModule("__builtin__"));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Atribui o módulo à variável global com o seu nome.
 */
\layout LyX-Code


\size footnotesize 
PyDict_SetItemString(globals, namespace, module);
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

O tipo 
\family typewriter 
script_plugin_state
\family default 
 é um 
\emph on 
typedef
\emph default 
 para 
\family typewriter 
PyObject*
\family default 
.
 O objeto retornado pela função de inicialização é o dicionário de elementos
 do módulo, obtido com 
\family typewriter 
PyModule_GetDict\SpecialChar \-
(module)
\family default 
.
 Neste dicionário, armazenamos o ponteiro do ambiente virtual como o atributo
 privado 
\family typewriter 
__env
\family default 
.
\layout Standard

De forma similar, em Ruby estados virtuais são implementados como classes
 que compartilham um mesmo estado global, já que Ruby também não permite
 múltiplos ambientes de execução isolados.
 Na função de inicialização 
\family typewriter 
script_plugin_init_ruby
\family default 
, uma classe com o nome do ambiente virtual é criada usando a função 
\family typewriter 
rb_define_class
\family default 
.
 O ponteiro do ambiente virtual é armazenado em uma constante da classe
 como um número.
 O 
\family typewriter 
VALUE
\family default 
 referente à classe é retornado como o 
\family typewriter 
script_plugin_state
\family default 
.
\layout LyX-Code


\size footnotesize 
VALUE state;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (inicialização do interpretador omitida) ...
 */
\layout LyX-Code


\size footnotesize 
\emph on 
/* class_name é o nome do ambiente virtual,
\layout LyX-Code


\size footnotesize 
\emph on 
   com a inicial convertida para maiúsculas,
\layout LyX-Code


\size footnotesize 
\emph on 
   respeitando a convenção de nomes de classe Ruby */
\layout LyX-Code


\size footnotesize 
state = rb_define_class(class_name, rb_cObject);
\layout LyX-Code


\size footnotesize 
/* Isto assume que void* cabe em um long */
\layout LyX-Code


\size footnotesize 
rb_const_set(state, rb_intern("@@LibScriptEnv"), INT2NUM((long)env));  
  
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
return (script_plugin_state) state;
\layout Subsection

Encerramento de estados
\begin_inset LatexCommand \label{sub:Encerramento-de-estados}

\end_inset 


\layout Standard

Como Lua e Perl representam estados de forma independente, o encerramento
 de um estado nestes plugins é simples: a estrutura da linguagem que encapsula
 o ambiente completo de execução é encerrada.
 A implementação da função de finalização no plugin Lua é a seguinte:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_lua(script_plugin_state state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Em Lua, um state é um lua_State */
\layout LyX-Code


\size footnotesize 
   lua_State* L = (lua_State*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Encerra o estado.
 Não afeta outros ambientes.
 */
\layout LyX-Code


\size footnotesize 
   lua_close(L);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em Perl, o processo, embora um tanto mais elaborado, é essencialmente similar:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_perl(script_perl_state* state) {
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas macros assumem que o ponteiro do interpretador
\layout LyX-Code


\size footnotesize 
\emph on 
      se chama my_perl.
 */
\layout LyX-Code


\size footnotesize 
   PerlInterpreter* my_perl = (PerlInterpreter*) state;
\layout LyX-Code


\size footnotesize 
   
\emph on 
/* Algumas operações operam sobre o 
\begin_inset Quotes eld
\end_inset 

estado atual
\begin_inset Quotes erd
\end_inset 

,
\layout LyX-Code


\size footnotesize 
\emph on 
      então a macro PERL_SET_CONTEXT deve ser usada para
\layout LyX-Code


\size footnotesize 
\emph on 
      alternar o interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PERL_SET_CONTEXT(my_perl);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Esta flag deve ser ativada para que a limpeza do
\layout LyX-Code


\size footnotesize 
\emph on 
      ambiente seja completa, o que é necessário quando
\layout LyX-Code


\size footnotesize 
\emph on 
      pode haver mais de um interpretador ativo */
\layout LyX-Code


\size footnotesize 
   PL_perl_destruct_level = 1;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Encerramento do interpretador */
\layout LyX-Code


\size footnotesize 
   perl_destruct(my_perl);
\layout LyX-Code


\size footnotesize 
   perl_free(my_perl);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

\end_inset 


\layout Standard

Em Python e Ruby, o plugin precisa manter o controle do número de estados
 ativos para desalocar a máquina virtual somente quando este chegar a zero.
 Além disso, tanto em Ruby como em Python não há recursos nas APIs (ou nas
 linguagens, de fato) para remover, respectivamente, classes ou módulos.
 Em Ruby, poderíamos atribuir 
\family typewriter 
nil
\family default 
 à constante que representa a classe que descreve o ambiente virtual, mas
 depois disso não é possível definir uma nova classe em seu lugar: tanto
 
\family typewriter 
rb_define_class
\family default 
 via C como 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 via Ruby geram um erro indicando que o valor já foi definido com outro
 tipo.
 Como Ruby possui classes abertas, uma construção 
\family typewriter 
class 
\family default 
\emph on 
<Nome>
\emph default 
 para um 
\emph on 
<Nome>
\emph default 
 já existente é entendida como a continuação da descrição da classe, e não
 como a redefinição de 
\emph on 
<Nome>
\emph default 
.
 Python, por sua vez, não disponibiliza recursos na API para a descarga
 de módulos, mas permite atribuir 
\family typewriter 
None
\family default 
 à global referente ao módulo.
 O módulo pode ser importado novamente, mas a mesma instância dele, armazenada
 internamente por Python, será retornada.
 A seguinte sessão interativa de linha de comando permite observar este
 comportamento, que ocorre tanto diretamente em Python como via a API de
 C:
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo = "hello"
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello'
\layout LyX-Code


\size footnotesize 
>>> sys = None
\layout LyX-Code


\size footnotesize 
>>> import sys
\layout LyX-Code


\size footnotesize 
>>> sys.foo
\layout LyX-Code


\size footnotesize 
'hello' 
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, as estruturas de dados referentes aos estados LibScript não são encerrado
s nos plugins Python e Ruby.
 Esta é a implementação da rotina de encerramento no plugin Ruby:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_ruby(script_ruby_state state) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Decrementa o contador de estados, uma variável global 
\emph default 
static
\emph on 
 do plugin.
 */
\layout LyX-Code


\size footnotesize 
   script_ruby_state_count--;
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Finaliza o interpretador se este for o último estado.
 */
\layout LyX-Code


\size footnotesize 
   if (script_ruby_state_count == 0)
\layout LyX-Code


\size footnotesize 
      ruby_finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Standard

A implementação no plugin Python é basicamente igual:
\layout LyX-Code


\size footnotesize 
void script_plugin_done_python(script_python_state state) {
\layout LyX-Code


\size footnotesize 
   script_python_state_count--;
\layout LyX-Code


\size footnotesize 
   if (script_python_state_count == 0)
\layout LyX-Code


\size footnotesize 
      Py_Finalize();
\layout LyX-Code


\size footnotesize 
}
\layout Subsection

Passagem de parâmetros
\begin_inset LatexCommand \label{sub:Passagem-de-parâmetros}

\end_inset 


\layout Standard

A transferência de dados entre a biblioteca principal e os plugins é concentrada
 em duas operações: uma para passar o conteúdo do buffer de parâmetros de
 LibScript para o espaço de dados da máquina virtual e outra para realizar
 a operação inversa.
 A primeira é usada na passagem de parâmetros de entrada quando funções
 da linguagem de script são chamadas por C e para a obtenção dos valores
 de retorno quando a linguagem de script faz chamadas que são tratadas C.
 A segunda operação, de forma complementar, é usada para os valores de retorno
 quando C chama a linguagem de script e para os parâmetros de entrada quando
 uma chamada feita pela linguagem de script é tratada por código C.
\layout Standard

Na implementação do plugin LibScript-Lua, a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 converte o conteúdo da pilha de Lua para o buffer de parâmetros de LibScript.
 A função do plugin responsável por invocar funções Lua a partir de C, 
\family typewriter 
script_plugin_call_lua
\family default 
, usa a função 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 para armazenar no buffer LibScript os valores de retorno da função Lua
 invocada, já que estes são retornados na pilha virtual.
 Quando o código Lua chama funções implementadas em C ou em outro plugin,
 
\family typewriter 
script_lua_stack_to_buffer
\family default 
 é usada para converter os parâmetros de entrada da função, também recebidos
 na pilha virtual.
 A seguir, vemos a implementação desta função:
\layout LyX-Code


\size footnotesize 
static void script_lua_stack_to_buffer(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int nargs; int i; 
\layout LyX-Code


\size footnotesize 
   nargs = lua_gettop(L);    
\emph on 
/* Número de elementos na pilha de Lua */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env); 
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 1; i <= nargs; i++) {
\layout LyX-Code


\size footnotesize 
      
\emph on 
/* Verifica o tipo Lua do elemento na posição i da pilha */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, converte o elemento e o armazena no buffer */
\layout LyX-Code


\size footnotesize 
      switch(lua_type(L, i)) { 
\layout LyX-Code


\size footnotesize 
      case LUA_TNUMBER:
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, lua_tonumber(L, i)); break; 
\layout LyX-Code


\size footnotesize 
      case LUA_TSTRING:
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i-1, lua_tostring(L, i)); break;
\layout LyX-Code


\size footnotesize 
      case LUA_TBOOLEAN:
\layout LyX-Code


\size footnotesize 
         script_put_bool(env, i-1, lua_toboolean(L, i)); break;
\layout LyX-Code


\size footnotesize 
      default:
\layout LyX-Code


\size footnotesize 
\emph on 
         /* Tipos não tratados são substituídos por zero.
 */
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i-1, 0);
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assumimos em LibScript strings no formato de C: a função 
\family typewriter 
script_put_string
\family default 
 copia a string passada até o primeiro 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Assim, ao obter strings de linguagens que permitem conteúdo arbitrário,
 estas serão truncadas caso contenham 
\family typewriter 
'
\backslash 
0'
\family default 
.
 Por isso, no plugin Lua usamos diretamente a função 
\family typewriter 
lua_tostring
\family default 
, e não a função mais geral 
\family typewriter 
lua_tolstring
\family default 
 (que retorna também o tamanho do buffer).
\layout Standard

Os valores de tipos desconhecidos são substituídos pelo valor zero, o que
 mantém a posição dos demais valores na lista de argumentos.
 Optamos por não sinalizar erro nesta situação para evitar aqui a geração
 de exceções, o que complicaria a exposição.
 A captura e propagação de erros serão vistas na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Captura-de-erros}

\end_inset 

.
\layout Standard

A segunda função de transferência de dados de LibScript-Lua, 
\family typewriter 
script_lua_buffer_to_stack
\family default 
, obtém os valores do buffer LibScript e os insere na pilha virtual de Lua.
 Esta função é usada para passar os parâmetros de entrada para Lua em 
\family typewriter 
script_plugin_call_lua
\family default 
 e para passar para Lua os valores obtidos pelo retorno da função 
\family typewriter 
script_call
\family default 
, que é invocada internamente pelo plugin quando Lua invoca uma função C.
\layout LyX-Code


\size footnotesize 
static int script_lua_buffer_to_stack(script_env* env, lua_State *L) {
\layout LyX-Code


\size footnotesize 
   int i; char* s;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env); 
\emph on 
/* Número de elementos no buffer */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Verifica o tipo do elemento na posição i do buffer */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* e para cada tipo, o obtém e o insere na pilha de Lua */
\layout LyX-Code


\size footnotesize 
      type = script_get_type(env, i);
\layout LyX-Code


\size footnotesize 
      switch (type) {
\layout LyX-Code


\size footnotesize 
      case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
         lua_pushnumber(L, script_get_double(env, i)); break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
         s = script_get_string(env, i); 
\emph on 
/* A string pertence ao chamador.
 */
\layout LyX-Code


\size footnotesize 
         lua_pushstring(L, s);
\layout LyX-Code


\size footnotesize 
         free(s); 
\emph on 
/* Libera a string, já que Lua armazena sua própria cópia.
 */
\layout LyX-Code


\size footnotesize 
         break;
\layout LyX-Code


\size footnotesize 
      case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
         lua_pushboolean(L, script_get_bool(env, i)); break;
\layout LyX-Code


\size footnotesize 
      }
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return len;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Em LibScript-Python, não foi possível concentrar as operações de transferência
 de dados em apenas duas funções.
 Cada operação teve que ser dividida em duas partes.
 A conversão de dados recebidos de Python para o buffer de LibScript foi
 divida nas funções 
\family typewriter 
script_python_put_object
\family default 
 e 
\family typewriter 
script_python_tuple_to_buffer
\family default 
.
 A primeira função converte um único valor Python e o insere na posição
 solicitada no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_put_object(script_env* env, int i, PyObject* o)
 {
\layout LyX-Code


\size footnotesize 
   if (PyString_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, PyString_AS_STRING(o));
\layout LyX-Code


\size footnotesize 
   else if (PyInt_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, PyInt_AS_LONG(o));
\layout LyX-Code


\size footnotesize 
   else if (PyLong_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyLong_AsDouble(o));
\layout LyX-Code


\size footnotesize 
   else if (PyFloat_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, PyFloat_AS_DOUBLE(o));
\layout LyX-Code


\size footnotesize 
   else if (PyBool_Check(o))
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, o == Py_True ? 1 : 0);
\layout LyX-Code


\size footnotesize 
   else
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

É importante notar que os tipos Python 
\family typewriter 
PyInt
\family default 
 e 
\family typewriter 
PyLong
\family default 
 não correspondem aos tipos C 
\family typewriter 
int
\family default 
 e 
\family typewriter 
long
\family default 
: 
\family typewriter 
PyInt
\family default 
 é o tipo inteiro correspondente ao tamanho da palavra da máquina (análogo
 a 
\family typewriter 
int
\family default 
), mas 
\family typewriter 
PyLong
\family default 
 é um inteiro de precisão arbitrária.
 Em LibScript, representamos 
\family typewriter 
PyLong
\family default 
s como 
\family typewriter 
double
\family default 
s.
 A API de LibScript oferece a função 
\family typewriter 
script_put_int
\family default 
 como conveniência, mas internamente, como ocorre por exemplo em Lua, todos
 os números são armazenados como 
\family typewriter 
double
\family default 
s.
\layout Standard

A segunda função, 
\family typewriter 
script_python_tuple_to_buffer
\family default 
, insere os elementos de uma tupla no buffer:
\layout LyX-Code


\size footnotesize 
static void script_python_tuple_to_buffer(script_env* env, PyObject* tuple)
 {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = PyTuple_GET_SIZE(tuple); 
\emph on 
/* Número de elementos da tupla */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);          
\emph on 
/* Esvazia o buffer LibScript */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = PyTuple_GET_ITEM(tuple, i); 
\emph on 
/* Obtém elemento da tupla */
\layout LyX-Code


\size footnotesize 
      script_python_put_object(env, i, o);      
\emph on 
/* Insere-o no buffer.
 */
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A operação inversa, de transferência de dados do buffer LibScript para Python,
 também é implementada em duas funções, uma tratando objetos individualmente
 e outra tratando tuplas.
 A função 
\family typewriter 
script_get_object
\family default 
 converte um elemento do buffer para um 
\family typewriter 
PyObject
\family default 
 equivalente:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_get_object(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   PyObject* ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return PyFloat_FromDouble(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      PyObject* ret = PyString_FromString(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return PyBool_FromLong(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

A função 
\family typewriter 
script_python_buffer_to_tuple
\family default 
 gera uma tupla contendo todos os elementos do buffer LibScript:
\layout LyX-Code


\size footnotesize 
static PyObject* script_python_buffer_to_tuple(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   PyObject* ret = PyTuple_New(len);
\layout LyX-Code


\size footnotesize 
   for(i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      PyObject* o = script_python_get_object(env, i);
\layout LyX-Code


\size footnotesize 
      PyTuple_SetItem(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim, estes dois pares de funções realizam funções equivalentes às que
 
\family typewriter 
script_lua_\SpecialChar \-
stack_to_buffer
\family default 
 e 
\family typewriter 
script_lua_buffer_to_stack
\family default 
 exercem no plugin Lua.
 Elas foram separadas em duas partes em função do modelo de retorno de valores
 em funções Python: no caso de múltiplos valores de retorno, eles são retornados
 como uma tupla; para valores simples, eles são passados diretamente.
 Isto é evidenciado no seguinte trecho da função 
\family typewriter 
script_plugin_call_python
\family default 
:
\layout LyX-Code


\size footnotesize 
PyObject *ret, *args;
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
args = script_python_buffer_to_tuple(env);  
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
ret = PyEval_CallObject(func, args); 
\emph on 
       /* Chama uma função Python */
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 */
\layout LyX-Code


\size footnotesize 
if (ret == Py_None)                         
\emph on 
/* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);                
\emph on 
/* Apenas zere o buffer LibScript */
\layout LyX-Code


\size footnotesize 
else if (PyTuple_Check(ret))                
\emph on 
/* Se retornou uma tupla */
\layout LyX-Code


\size footnotesize 
   script_python_tuple_to_buffer(env, ret); 
\emph on 
/* Insira seus elementos no buffer */
\layout LyX-Code


\size footnotesize 
else                                        
\emph on 
/* Se retornou outro tipo de objeto */
\layout LyX-Code


\size footnotesize 
   script_python_put_object(env, 0, ret);   
\emph on 
/* Insira-o como único elemento */
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

No tratador de chamadas a funções externas do plugin, a comunicação no sentido
 inverso emprega uma lógica similar:
\layout LyX-Code


\size footnotesize 
script_python_tuple_to_buffer(env, args);    
\emph on 
/* Obtém o parâmetros de entrada */
\layout LyX-Code


\size footnotesize 
err = script_call(env, fn_name);             
\emph on 
/* Chama um função via LibScript */
\layout LyX-Code


\size footnotesize 
/* ...
 */
\layout LyX-Code


\size footnotesize 
switch(script_buffer_len(env)) {
\layout LyX-Code


\size footnotesize 
case 0:                                      
\emph on 
 /* Se a função não retornou valor */
\layout LyX-Code


\size footnotesize 
   Py_RETURN_NONE;                           
\emph on 
 /* Retorne o valor Python 'None' */
\layout LyX-Code


\size footnotesize 
case 1:                                      
\emph on 
 /* Se retornou um único valor */
\layout LyX-Code


\size footnotesize 
   return script_python_get_object(env, 0);  
\emph on 
 /* Converta e retorne-o */
\layout LyX-Code


\size footnotesize 
default:                                      
\emph on 
/* Se retornou mais de um valor */
\layout LyX-Code


\size footnotesize 
   return script_python_buffer_to_tuple(env); 
\emph on 
/* Retorne-os em uma tupla */
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Assim como em Python, funções em Ruby retornam múltiplos valores encapsulando-os
 em um tipo agregado.
 Desta forma, as operações de transferências de dados de LibScript-Ruby
 também são divididas em pares de funções, uma convertendo um valor do buffer,
 e outra operando sobre um array Ruby.
 A função análoga a 
\family typewriter 
script_python_put_object
\family default 
 é 
\family typewriter 
script_ruby_put_value
\family default 
:
\layout LyX-Code


\size footnotesize 
static void script_ruby_put_value(script_env* env, int i, VALUE arg) {
\layout LyX-Code


\size footnotesize 
   switch (TYPE(arg)) {
\layout LyX-Code


\size footnotesize 
   case T_FLOAT:
\layout LyX-Code


\size footnotesize 
   case T_FIXNUM:
\layout LyX-Code


\size footnotesize 
   case T_BIGNUM:
\layout LyX-Code


\size footnotesize 
      script_put_double(env, i, NUM2DBL(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_STRING:
\layout LyX-Code


\size footnotesize 
      script_put_string(env, i, StringValuePtr(arg)); break;
\layout LyX-Code


\size footnotesize 
   case T_TRUE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 1); break;
\layout LyX-Code


\size footnotesize 
   case T_FALSE:
\layout LyX-Code


\size footnotesize 
      script_put_bool(env, i, 0); break;
\layout LyX-Code


\size footnotesize 
   default:
\layout LyX-Code


\size footnotesize 
      script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Aqui, alguns problemas da API de Ruby são aparentes.
 Além da inconsistência na nomenclatura das funções de conversão de objetos,
 o significado do valor retornado pela macro 
\family typewriter 
TYPE
\family default 
 só pode ser compreendido através da representação interna de 
\family typewriter 
VALUE
\family default 
s na implementação de Ruby, e não através da hierarquia de tipos dos objetos
 da linguagem.
 As classes que têm tratamento especial na estrutura interna de 
\family typewriter 
VALUE
\family default 
s possuem constantes associadas a si, como 
\family typewriter 
T_FLOAT
\family default 
 e 
\family typewriter 
T_STRING
\family default 
; as demais são identificados apenas como 
\family typewriter 
T_OBJECT
\family default 
s.
 O uso de 
\family typewriter 
T_TRUE
\family default 
 e 
\family typewriter 
T_FALSE
\family default 
 pode dar a entender que alguns valores específicos também retornam resultados
 especiais para 
\family typewriter 
TYPE
\family default 
.
 De fato, estes valores são definidos como 
\family typewriter 
VALUE
\family default 
s que não correspondem a índices da heap de objetos de Ruby e são tratados
 de forma especial na implementação.
 Do ponto de vista de código Ruby, entretanto, esta classificação dos valores
 
\family typewriter 
true
\family default 
 e 
\family typewriter 
false
\family default 
 em tipos separados na API C é justificada definindo-os como 
\emph on 
singletons
\emph default 
 das classes 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
, abordagem provavelmente influenciada por Smalltalk.
 Porém, diferentemente de Smalltalk, onde 
\family typewriter 
True
\family default 
 e 
\family typewriter 
False
\family default 
 são subclasses de 
\family typewriter 
Boolean
\family default 
, em Ruby 
\family typewriter 
TrueClass
\family default 
 e 
\family typewriter 
FalseClass
\family default 
 são subclasses diretas de 
\family typewriter 
Object
\family default 
.
 Isto traz a inconveniência de que verificar se um tipo é um valor booleano
 incorre sempre em dois testes.
\layout Standard

Assim como LibScript-Python tem uma função para armazenar no buffer os elementos
 de uma tupla, LibScript-Ruby possui uma função para armazenar os elementos
 de um array:
\layout LyX-Code


\size footnotesize 
static void script_ruby_array_to_buffer(script_env* env, VALUE array) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = RARRAY(array)->len;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = rb_ary_entry(array, i);
\layout LyX-Code


\size footnotesize 
      script_ruby_put_value(env, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard

Ruby não possui uma função na API C para retornar o tamanho de um array;
 ao invés disso, a estrutura interna do 
\family typewriter 
VALUE
\family default 
 é exposta através da macro 
\family typewriter 
RARRAY
\family default 
 (que apenas encapsula um cast).
 
\layout Standard

As operações para conversão de valores do buffer LibScript para Ruby também
 são similares às implementadas no plugin Python.
 Novamente, onde em Python há uma função para manipulação de tuplas, temos
 em Ruby uma função que opera sobre arrays:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_get_value(script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   VALUE ret; char* s;
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE:
\layout LyX-Code


\size footnotesize 
      return rb_float_new(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING:
\layout LyX-Code


\size footnotesize 
      s = script_get_string(env, i);
\layout LyX-Code


\size footnotesize 
      ret = rb_str_new2(s);
\layout LyX-Code


\size footnotesize 
      free(s);
\layout LyX-Code


\size footnotesize 
      return ret;
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL:
\layout LyX-Code


\size footnotesize 
      return script_get_bool(env, i) ? Qtrue : Qfalse;
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
 
\newline 
static VALUE script_ruby_buffer_to_array(script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   VALUE ret = rb_ary_new2(len);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      VALUE o = script_ruby_get_value(env, i);
\layout LyX-Code


\size footnotesize 
      rb_ary_store(ret, i, o);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return ret;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

De forma similar ao plugin Python, a implementação da chamada de funções
 Ruby a partir de LibScript usa a função 
\family typewriter 
script_ruby_buffer_to_array
\family default 
 para converter os parâmetros de entrada e as funções 
\family typewriter 
script_ruby_put_value
\family default 
 ou 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 para converter o valor de retorno, dependendo se a função retornou um ou
 mais valores (ou mais precisamente, se a função retornou ou não um array).
 Em chamadas de funções LibScript a partir de Ruby, os parâmetros de entrada
 são convertidos com 
\family typewriter 
script_ruby_array_to_buffer
\family default 
 e os valores de retorno com 
\family typewriter 
script_ruby_get_value
\family default 
 ou 
\family typewriter 
script_ruby_buffer_to_array
\family default 
.
\layout Standard

No plugin Perl, temos três funções: a transferência de dados da pilha para
 o buffer LibScript pôde ser implementada em uma única função como em Lua,
 mas a transferência no sentido oposto teve que ser dividida em duas funções,
 como em Python e Ruby.
 Esta assimetria vem do fato de que o tratamento de valores de retorno é
 encapsulado pelo pré-processador XS através da variável especial 
\family typewriter 
RETVAL
\family default 
; assim, nesta situação não podemos manipular a pilha diretamente, mas apenas
 passar 
\family typewriter 
SV
\family default 
s como valores de saída.
 
\layout Standard

A transferência de dados da pilha de Perl para o buffer LibScript é razoavelment
e simples:
\layout LyX-Code


\size footnotesize 
void script_perl_stack_to_buffer(pTHX_ int ax, script_env* env,
\layout LyX-Code


\size footnotesize 
                                 int count, int offset) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < count; i++) {
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Obtém um ponteiro para o SV */
\layout LyX-Code


\size footnotesize 
      SV* o = ST(offset+i);
\layout LyX-Code


\size footnotesize 
      if (SvIOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, SvIV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvNOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_double(env, i, SvNV(o));
\layout LyX-Code


\size footnotesize 
      else if (SvPOK(o))
\layout LyX-Code


\size footnotesize 
         script_put_string(env, i, SvPV_nolen(o));
\layout LyX-Code


\size footnotesize 
      else
\layout LyX-Code


\size footnotesize 
         script_put_int(env, i, 0);
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Os parâmetros de entrada desta função merecem comentário.
 Inicialmente, temos a macro 
\family typewriter 
pTHX_
\family default 
.
 Esta macro foi adicionada à API quando Perl passou a permitir múltiplos
 interpretadores simultâneos por processo: as funções da API foram transformadas
 em macros que encapsulam a passagem deste primeiro parâmetro.
 Por exemplo, a função 
\family typewriter 
eval_sv
\family default 
 pode ser chamada como 
\family typewriter 
Perl_eval_sv
\family default 
, passando a macro 
\family typewriter 
aTHX_
\family default 
 como parâmetro inicial.
 De maneira geral o uso destas macros fica implícito, mas ao escrever funções
 que usam a API de Perl torna-se necessário usar a macro 
\family typewriter 
pTHX_
\family default 
 na declaração
\begin_inset Foot
collapsed true

\layout Standard

A macro 
\family typewriter 
pTHX_
\family default 
 é usada sem a vírgula separando-a do argumento seguinte.
 Quando ela é o único argumento, deve-se usar 
\family typewriter 
pTHX
\family default 
.
\end_inset 

, para propagar a informação de estado do interpretador através de chamadas
 de função, e 
\family typewriter 
aTHX_
\family default 
 nas chamadas.
\layout Standard

Outro sintoma de que a API de Perl foi projetada mais para uso interno do
 pré-processador XS do que para manipulação direta transparece no segundo
 argumento, 
\family typewriter 
ax
\family default 
.
 Algumas macros assumem a existência deste valor, que não é propagado via
 
\family typewriter 
pTHX_
\family default 
, mas é declarado implicitamente quando funções são encapsuladas via XS.
 A API parece assumir que uma função XS não irá invocar outra função C que
 também use a API.
 Tivemos então que propagar esta variável (que é citada na documentação,
 mas apenas como 
\emph on 
"the 'ax' variable"\SpecialChar ~

\emph default 

\begin_inset LatexCommand \cite{okamoto06perlapi}

\end_inset 

, sem explicações do seu propósito).
\layout Standard

Os outros dois parâmetros, 
\family typewriter 
count
\family default 
 e 
\family typewriter 
offset
\family default 
, são necessários devido às diferentes formas que as informações que eles
 representam são obtidas nos dois contextos onde esta função é usada.
 Nos outros plugins, podemos obter a quantidade de elementos de entrada
 de forma uniforme (consultando o número de elementos da tupla em Python,
 por exemplo).
 Em Perl, nas duas situações onde a função é chamada, o número de elementos
 a serem lidos da pilha deve ser obtido de formas diferentes, e por isso
 o passamos como parâmetro 
\family typewriter 
count
\family default 
.
 Na rotina chamadora de funções LibScript, implementada no arquivo XS, o
 tamanho da pilha é obtido através de uma variável especial, 
\family typewriter 
items
\family default 
.
 Já na chamada de funções Perl, o valor de 
\family typewriter 
count
\family default 
 é obtido como retorno da função que realiza a invocação, 
\family typewriter 
Perl_call_pv
\family default 
.
 
\layout Standard

A posição inicial da pilha a partir da qual devemos obter os elementos (
\family typewriter 
offset
\family default 
) também varia.
 Dentro da função XS, os parâmetros de entrada começam a partir da posição
 2, pois LibScript passa o ponteiro do ambiente e o nome da função nos dois
 primeiros argumentos.
 Na chamada de funções Perl, o valor de 
\family typewriter 
offset
\family default 
 é zero pois, como visto no protocolo de chamada de funções Perl discutido
 na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

, a base da pilha é ajustada após a chamada da função pela macro 
\family typewriter 
SPAGAIN
\family default 
.
 
\layout Standard

A conversão de valores do buffer LibScript para a pilha de Perl é dada em
 duas funções, uma que gera um único SV e outra que empilha todos os elementos:
\layout LyX-Code


\size footnotesize 
SV* script_perl_get_sv(pTHX_ script_env* env, int i) {
\layout LyX-Code


\size footnotesize 
   switch (script_get_type(env, i)) {
\layout LyX-Code


\size footnotesize 
   case SCRIPT_DOUBLE: return newSVnv(script_get_double(env, i));
\layout LyX-Code


\size footnotesize 
\emph on 
   /* 0 indica que o tamanho da string deve ser calculado por Perl.
 */
\layout LyX-Code


\size footnotesize 
   case SCRIPT_STRING: return newSVpv(script_get_string(env, i), 0);
\layout LyX-Code


\size footnotesize 
   case SCRIPT_BOOL: return newSViv(script_get_bool(env, i));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
}
\layout LyX-Code


\size footnotesize 
  
\newline 
SV** script_perl_buffer_to_stack(pTHX_ SV** sp, script_env* env) {
\layout LyX-Code


\size footnotesize 
   int i;
\layout LyX-Code


\size footnotesize 
   int len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++) {
\layout LyX-Code


\size footnotesize 
      XPUSHs(sv_2mortal(script_perl_get_sv(aTHX_ env, i)));
\layout LyX-Code


\size footnotesize 
   }
\layout LyX-Code


\size footnotesize 
   return sp;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Novamente, uma variável criada internamente por Perl teve que ser propagada
 explicitamente: 
\family typewriter 
sp
\family default 
, o 
\emph on 
stack pointer
\emph default 
.
 Esta variável é referenciada internamente pela macro 
\family typewriter 
xPUSHs
\family default 
.
 Além disso, como 
\family typewriter 
XPUSHs
\family default 
 pode redimensionar a pilha, precisamos retornar o valor atualizado de 
\family typewriter 
sp
\family default 
 de volta para o chamador.
 No mais, a geração de 
\family typewriter 
SV
\family default 
s, o registro destes como variáveis mortais e o seu empilhamento ocorre
 da forma usual, já apresentada na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Perl-call}

\end_inset 

.
\layout Standard

Assim como nos demais plugins, a passagem de parâmetros de entrada em LibScript-
Perl, tanto para a chamada de funções Perl como de funções via LibScript,
 é feita chamando a função de conversão que opera sobre o buffer como um
 todo: na chamada de funções Perl usamos 
\family typewriter 
script_perl_buffer_to_stack
\family default 
 e na de funções via LibScript, 
\family typewriter 
script_perl_stack_to_buffer
\family default 
.
 Para tratar os valores de retorno de funções Perl, pudemos utilizar diretamente
 a função 
\family typewriter 
script_perl_stack_to_buffer
\family default 
, de forma similar à realizada em LibScript-Lua.
 Para o retorno de funções chamadas via LibScript, porém, precisamos lidar
 com a variável especial 
\family typewriter 
RETVAL
\family default 
 de XS e com os diferentes contextos de chamada de Perl.
 O trecho abaixo ilustra o tratamento de valores de retorno neste caso:
\layout LyX-Code


\size footnotesize 
err = script_call(env, function_name);
\layout LyX-Code


\size footnotesize 
\emph on 
/* ...
 (tratamento de erro omitido) ...
 */
\layout LyX-Code


\size footnotesize 
switch (GIMME_V) {
\layout LyX-Code


\size footnotesize 
case G_SCALAR:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retorna o primeiro item do buffer */
\layout LyX-Code


\size footnotesize 
   RETVAL = script_perl_get_sv(aTHX_ env, 0);
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_ARRAY:
\layout LyX-Code


\size footnotesize 
   len = script_buffer_len(env);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Cria um array */
\layout LyX-Code


\size footnotesize 
   RETVAL = (SV*)newAV();
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Arrays retornados devem ser marcados como mortais */
\layout LyX-Code


\size footnotesize 
   sv_2mortal((SV*)RETVAL);
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Insere o conteúdo do buffer no array */
\layout LyX-Code


\size footnotesize 
   for (i = 0; i < len; i++)
\layout LyX-Code


\size footnotesize 
      av_push((AV*)RETVAL, script_perl_get_sv(aTHX_ env, i));
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
case G_VOID:
\layout LyX-Code


\size footnotesize 
\emph on 
   /* O valor de retorno é descartado em contextos void.
 */
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Retornamos então a constante Perl undef.
 */
\layout LyX-Code


\size footnotesize 
   RETVAL = &PL_sv_undef;
\layout LyX-Code


\size footnotesize 
   break;
\layout LyX-Code


\size footnotesize 
}
\layout Subsection


\begin_inset LatexCommand \label{sub:Resolução-de-funções}

\end_inset 

Chamada de funções
\layout Standard

Nos plugins de LibScript, funções implementadas externamente (em C ou outros
 plugins) são localizadas somente no momento em que elas são chamadas.
 O objetivo aqui, além de otimizar o tempo de inicialização e consumo de
 memória no ambiente de execução da linguagem de script (ao evitar a declaração
 de funções que não serão utilizadas), é permitir a localização de funções
 declaradas após a inicialização do ambiente.
 Para permitir esta resolução de funções de forma dinâmica, é preciso capturar
 o acesso a elementos inexistentes na estrutura que descreve o ambiente
 virtual no plugin e encaminhar a chamada à biblioteca principal via 
\family typewriter 
script_call
\family default 
.
 Ao comparar as abordagens empregadas em cada plugin para obter tal comportament
o, podemos avaliar alguns recursos de meta-programação oferecidos por cada
 linguagem e a sua disponibilidade através das suas APIs.
\layout Standard

Como vimos na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Representação-de-estados}

\end_inset 

, em Lua, durante a inicialização do plugin, é criada uma tabela armazenada
 em uma variável global com o nome do ambiente.
 Funções são inseridas dinamicamente nesta tabela através da metatabela
 associada a ela logo após a sua criação em 
\family typewriter 
script_plugin_init_lua
\family default 
.
 O campo 
\family typewriter 
__index
\family default 
 da metatabela aponta para uma função\SpecialChar ~
C interna ao plugin, 
\family typewriter 
script_lua_
\family default 
\SpecialChar \-

\family typewriter 
make_caller
\family default 
, que é então invocada sempre que um elemento inexistente for solicitado
 na tabela.
 A função 
\family typewriter 
script_lua_make_caller
\family default 
 cria uma 
\emph on 
closure
\emph default 
\SpecialChar ~
C, que consiste de outra função\SpecialChar ~
C interna ao plugin (
\family typewriter 
script_lua_caller
\family default 
) e o nome da função solicitada.
 Esta closure é associada à entrada da tabela do ambiente.
 Assim, chamadas a funções implementadas externamente serão resolvidas por
 
\family typewriter 
script_lua_caller
\family default 
, que as passará adiante para 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Python, ao chamar uma função no módulo do ambiente virtual, o
 
\emph on 
callback
\emph default 
 
\family typewriter 
__getattro
\family default 
 do módulo, definido como a função interna 
\family typewriter 
script_python_get
\family default 
, é chamado.
 Esta função procura uma entrada no dicionário do módulo e, caso não a encontre,
 cria um objeto do tipo 
\family typewriter 
script_python_object
\family default 
, e o retorna como resultado de 
\family typewriter 
__getattro
\family default 
.
 Este tipo de dado é declarado no plugin como uma classe Python, cujas instância
s contêm um ponteiro para o ambiente virtual e uma string C com o nome da
 função que eles representam.
 Estes objetos possuem o seu 
\emph on 
callback
\emph default 
 
\family typewriter 
__call
\family default 
 definido como 
\family typewriter 
script_python_caller
\family default 
, uma função que, assim como 
\family typewriter 
script_lua_caller
\family default 
, converte os parâmetros recebidos para o buffer de LibScript, invoca 
\family typewriter 
script_call
\family default 
 e converte os valores de retorno de volta a Python.
 Assim, objetos deste tipo são 
\emph on 
functors
\emph default 
, e se comportam de forma similar à 
\emph on 
closure
\emph default 
 definida no plugin Lua.
\layout Standard

A resolução de funções sob demanda em Ruby é implementada utilizando o método
 
\family typewriter 
method_missing
\family default 
, que é um fallback definido pela linguagem, chamado sempre que um método
 inexistente é invocado em uma classe.
 Diferentemente de 
\family typewriter 
__getattro
\family default 
 em Python e 
\family typewriter 
__index
\family default 
 em Lua, que são tratadores de acesso a atributos e portanto precisam retornar
 um objeto que é chamado em um passo seguinte, o método 
\family typewriter 
method_missing
\family default 
 trata chamadas diretamente.
 Assim, ao ser invocado, 
\family typewriter 
method_missing
\family default 
 recebe o nome do método solicitado e os parâmetros passados e os encaminha
 para a função 
\family typewriter 
script_call
\family default 
.
\layout Standard

No plugin Perl, como em Lua e Python, também há uma função C responsável
 por realizar a conversão de parâmetros e valores de retorno a invocação
 de 
\family typewriter 
script_call
\family default 
.
 Esta função, 
\family typewriter 
script_perl_caller
\family default 
, para que possa ser exposta ao interpretador Perl, é implementada em um
 módulo XS.
 Uma vez carregado o módulo, a função é visível em Perl como a função 
\family typewriter 
LibScript::caller
\family default 
.
 A resolução dinâmica de funções do pacote Perl que representa o ambiente
 virtual é feita usando a função 
\family typewriter 
AUTOLOAD
\family default 
 de Perl, que se comporta como 
\family typewriter 
method_missing
\family default 
 em Ruby, capturando chamadas a funções inexistentes.
 Na função de inicialização do plugin, código Perl é executado para carregar
 o módulo de extensão, inicializar o pacote do ambiente e inserir nele uma
 função 
\family typewriter 
AUTOLOAD
\family default 
 que chamará 
\family typewriter 
LibScript::caller
\family default 
:
\layout LyX-Code


\size footnotesize 
snprintf(code, LEN_CODE,
\layout LyX-Code


\size footnotesize 
   "bootstrap LibScript;"   
\emph on 
/* Inicializa o módulo de extensão */
\layout LyX-Code


\size footnotesize 
   "package %s;" 
\emph on 
           /* Declara o pacote do ambiente */
\layout LyX-Code


\size footnotesize 
   "$LibScript::env = %p;"  
\emph on 
/* Armazena o ponteiro do ambiente em Perl */
\layout LyX-Code


\size footnotesize 
   "sub AUTOLOAD {"
\layout LyX-Code


\size footnotesize 
      "our $AUTOLOAD;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Extrai o nome do método do nome qualificado 
\begin_inset Quotes eld
\end_inset 

pacote::método
\begin_inset Quotes erd
\end_inset 

 */
\layout LyX-Code


\size footnotesize 
      "$AUTOLOAD =~ s/[^:]*:://;"
\layout LyX-Code


\size footnotesize 
\emph on 
      /* Invoca caller passando o endereço do ambiente, */
\layout LyX-Code


\size footnotesize 
\emph on 
      /* o nome do método, e o array de argumentos */
\layout LyX-Code


\size footnotesize 
\emph on 
      
\emph default 
"LibScript::caller(%p, $AUTOLOAD, @_);"  
\layout LyX-Code


\size footnotesize 
   "}",
\layout LyX-Code


\size footnotesize 
   state->package, env, env);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Avalia a string de código;
\layout LyX-Code


\size footnotesize 
\emph on 
   TRUE indica que erros devem ser sinalizados.
 */
\layout LyX-Code


\size footnotesize 
Perl_eval_pv(my_perl, code, TRUE);
\layout Subsection

Captura de erros
\begin_inset LatexCommand \label{sub:Captura-de-erros}

\end_inset 


\layout Standard

Os plugins devem capturar a ocorrência de erros na execução de strings de
 código e em chamadas de função.
 Em Lua, ambas as operações são realizadas usando a função 
\family typewriter 
lua_pcall
\family default 
, cujo valor de retorno indica a ocorrência de erros.
 No caso de erros, a mensagem de erro é obtida no topo da pilha virtual
 de Lua e propagada para a biblioteca principal usando 
\family typewriter 
script_set_error_message
\family default 
.
 No caso da execução de strings de código, erros de compilação são detectados
 através do valor de retorno da função 
\family typewriter 
luaL_loadstring
\family default 
, que carrega o código a ser executado por 
\family typewriter 
lua_pcall
\family default 
.
\layout Standard

Em Python, a ocorrência de erros é sinalizada pelo valor de retorno das
 funções de execução de strings, 
\family typewriter 
PyRun_SimpleString
\family default 
, e de chamada de funções, 
\family typewriter 
PyEval_CallObject
\family default 
.
 No caso de erros, chamamos a função 
\family typewriter 
PyErr_Occurred
\family default 
, que retorna um objeto Python representando a exceção.
 A mensagem de erro é obtida convertendo este objeto para uma string Python
 usando 
\family typewriter 
PyObject_Str
\family default 
, e finalmente para uma string C com 
\family typewriter 
PyString_AS_STRING
\family default 
.
\layout Standard

Em Perl, erros são sinalizados na variável especial 
\family typewriter 
$@
\family default 
, cujo conteúdo pode ser verificado através da API de C com a macro 
\family typewriter 
ERRSV
\family default 
.
 O teste para ocorrência de erros é 
\family typewriter 
SvTRUE(ERRSV)
\family default 
, e a mensagem de erro pode ser obtida convertendo esta variável para uma
 string C com a macro 
\family typewriter 
SvPV
\family default 
.
\layout Standard

Ruby disponibiliza uma função para execução de strings de código, 
\family typewriter 
rb_eval_string
\family default 
, e uma versão desta que captura erros e sinaliza a sua ocorrência através
 do valor de retorno, 
\family typewriter 
rb_eval_string_protect
\family default 
.
 Entretanto, para chamadas de método, não há uma versão protegida da função
 
\family typewriter 
rb_funcall
\family default 
.
 A função disponibilizada pela API para proteger chamadas, 
\family typewriter 
rb_protect
\family default 
, não recebe como parâmetro um método Ruby, mas sim uma função\SpecialChar ~
C.
 Para chamar métodos Ruby de forma protegida, precisamos escrever uma função
 C que encapsula a chamada:
\layout LyX-Code


\size footnotesize 
static VALUE script_ruby_pcall(VALUE args) {
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai nome do método do array de argumentos */
\layout LyX-Code


\size footnotesize 
   ID fn_id = SYM2ID(rb_ary_pop(args)); 
\layout LyX-Code


\size footnotesize 
\emph on 
   /* Extrai a classe do array de argumentos */
\layout LyX-Code


\size footnotesize 
   VALUE klass = rb_ary_pop(args);
\layout LyX-Code


\size footnotesize 
   return rb_apply(klass, fn_id, args);
\layout LyX-Code


\size footnotesize 
}
\layout Standard

e então invocá-la usando 
\family typewriter 
rb_protect
\family default 
:
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere a classe no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, klass);
\layout LyX-Code


\size footnotesize 
\emph on 
/* Insere o nome do método no array de argumentos */
\layout LyX-Code


\size footnotesize 
rb_ary_push(args, ID2SYM(rb_intern(fn)));
\layout LyX-Code


\size footnotesize 
\emph on 
/* Chama a função wrapper */
\layout LyX-Code


\size footnotesize 
ret = rb_protect(script_ruby_pcall, args, &error); 
\layout LyX-Code


\size footnotesize 
if (error) {
\layout LyX-Code


\size footnotesize 
   script_reset_buffer(env);
\layout LyX-Code


\size footnotesize 
   script_set_error_message(env, StringValuePtr(ruby_errinfo));
\layout LyX-Code


\size footnotesize 
   ruby_errinfo = Qnil;
\layout LyX-Code


\size footnotesize 
   return SCRIPT_ERRLANGRUN;
\layout LyX-Code


\size footnotesize 
}
\layout Standard


\begin_inset Note
collapsed true

\layout Standard

(parágrafo)
\end_inset 


\layout Standard

Como a função 
\family typewriter 
rb_protect
\family default 
 passa apenas um 
\family typewriter 
VALUE
\family default 
 para a função C, precisamos armazenar a classe, o identificador do método
 e os parâmetros de entrada do método Ruby a ser invocado em um array Ruby.
 A ocorrência de erros é sinalizada em uma variável passada no terceiro
 parâmetro de 
\family typewriter 
rb_protect
\family default 
, e a mensagem de erro é obtida no 
\family typewriter 
VALUE
\family default 
 global 
\family typewriter 
ruby_errinfo
\family default 
.
\layout Section

Conclusões
\layout Standard

O estudo de caso apresentado aqui ilustrou, através da implementação dos
 plugins, o processo de embutir quatro linguagens de script realizando interface
 com uma mesma API C.
 Diversos aspectos da interação entre C e as linguagens de script foram
 abordados, contemplando inicialização e encerramento do ambiente de execução,
 passagem de dados e chamadas de função nos dois sentidos e a sinalização
 de erros.
 A partir disto, podemos fazer algumas observações sobre a adequabilidade
 destas linguagens como ambientes embutidos em aplicações.
\layout Standard

Em muitas aplicações é importante que haja isolamento entre os scripts executado
s, como por exemplo, em scripts de diferentes clientes rodando em um servidor
 web.
 Como vimos, Lua e Perl permitem disparar múltiplos ambientes de execução,
 o que garante isolamento.
 Já Python e Ruby permitem apenas um estado, reduzindo sua aplicabilidade
 para cenários onde os scripts devem executar isolados uns dos outros
\begin_inset Foot
collapsed true

\layout Standard

Em Python é possível alternar a tabela de globais durante a execução de
 diferentes threads, o que oferece uma alternativa, um tanto mais trabalhosa,
 para obter isolamento.
 Ainda assim, o estado global compartilhado por módulos de extensão é o
 mesmo.
 
\end_inset 

.
 Estas duas linguagens trazem ainda outro problema: em alguns casos não
 é possível trazer o seu espaço de dados de volta ao estado original durante
 a execução de uma aplicação.
 Em Python, módulos importados não podem ser descarregados.
 Em Ruby, uma classe não pode ser redefinida (somente estendida) e 
\family typewriter 
ID
\family default 
s não são coletados.
\layout Standard

Na implementação do plugin de Perl fica evidente que a sua API não foi projetada
 visando embutir o interpretador em aplicações.
 Além de exigir o desenvolvimento de um módulo de extensão para que o código
 Perl possa ter acesso a funções C, observamos aqui que a sua API é incompleta
 no que diz respeito ao seu uso como linguagem embutida.
 Muitas macros foram desenvolvidas assumindo que seriam sempre invocadas
 a partir de código escrito em arquivos XS, ou mesmo por código gerado pelo
 pré-processador XS.
 Isto é confirmado pela necessidade de passar parâmetros adicionais não-document
ados para que as macros funcionem, como pôde ser observado na Seção\SpecialChar ~

\begin_inset LatexCommand \ref{sub:Passagem-de-parâmetros}

\end_inset 

.
\layout Standard

Lua, por sua vez, mostrou-se apropriada como linguagem embutida, não compartilha
ndo das limitações aqui descritas sobre as outras linguagens.
 Além disso, ela possui uma API simples, que trata as construções da linguagem
 de forma completa e ortogonal, o que se deve tanto ao foco da implementação
 de Lua como linguagem embutida, quanto ao projeto minimalista da linguagem
 em si.
 Mesmo em exemplos pequenos como os apresentados aqui, que exercitam apenas
 uma parte pequena das APIs, podemos observar que aspectos onde as linguagens
 definem tratamentos especiais ou possuem menor uniformidade transparecem
 nas APIs para C.
 Tanto em Python como em Ruby, funções que retornam múltiplos valores geram
 conversões implícitas para tipos agregados (listas e arrays).
 De forma similar, múltiplos retornos são representados em Perl através
 de contextos do tipo array.
 Nos seus respectivos plugins LibScript, estas características tiveram que
 ser tratadas de forma especial.
 No plugin Lua, em contraste, o tratamento para um valor único de retorno
 é igual ao de valores múltiplos, assim como ocorre na linguagem.
 
\layout Chapter


\begin_inset LatexCommand \label{cha:Considerações-Finais}

\end_inset 

Conclusões
\layout Standard

A escolha de uma linguagem de script depende de uma série de fatores, varios
 deles relativos à linguagem em si, outros relativos à sua implementação.
 Quando lidamos com cenários de desenvolvimento multi-linguagem, um aspecto
 que não deve ser negligenciado é o projeto das interfaces entre as linguagens.
 Seja estendendo a linguagem de script através de código C, ou tornando
 uma aplicação C extensível através de uma linguagem de script, a API oferecida
 pela linguagem tem um papel fundamental, muitas vezes influenciando o projeto
 da aplicação.
\layout Standard

Este trabalho traçou um panorama dos problemas gerais enfrentados na interação
 entre código C e o ambiente de execução de uma linguagem de script.
 Apresentamos as formas como as APIs de cinco linguagens tratam estes problemas,
 apontando pontos positivos e negativos das diferentes abordagens utilizadas.
 Realizamos uma comparação prática do uso destas APIs através de um estudo
 de caso onde as linguagens de script foram embutidas em bibliotecas C exportand
o uma mesma interface.
 A implementação consiste de uma biblioteca genérica para scripting, chamada
 LibScript, e uma série de plugins que realizam a interface com as diferentes
 linguagens.
 Pudemos assim observar como elas tratam aspectos importantes relativos
 a linguagens embutidas, como a passagem de dados, chamadas de funções entre
 as duas linguagens, tratamento de erros e o isolamento dos ambientes de
 execução em aplicações.
\layout Standard

Embora os mesmos problemas gerais, como transferência de dados, registro
 e chamada de funções, sejam comuns aos diferentes cenários de uso de uma
 API de linguagem de script, aplicações embutindo uma máquina virtual tendem
 a demandar mais da API do que bibliotecas implementando módulos de extensão.
 Este ponto é ilustrado pelas dificuldades impostas pela API de Python tanto
 no acesso a variáveis como no registro de funções globais; e principalmente
 pela complexidade da API de chamada de funções de Perl.
\layout Standard

O fato de que a API de Python dificulta o uso de variáveis e funções globais,
 favorecendo o uso de módulos, pode ser justificado como uma forma de promover
 um modelo de programação mais estruturada.
 Isto é interessante para o uso da API no desenvolvimento de módulos de
 extensão, uma vez que o uso de variáveis e funções globais é extremamente
 prejudicial nestes casos, já que poluiria o espaço de nomes das aplicações
 Python.
 Já para o caso onde a linguagem é embutida para prover suporte à execução
 de scripts em uma aplicação C, a ausência de uma forma conveniente para
 definir funções globais no espaço de nomes dos scripts é questionável.
\layout Standard

A abordagem empregada por Perl, usando um pré-processador com o objetivo
 de gerar automaticamente o código para a conversão de dados na passagem
 de parâmetros e valores de retorno, se mostrou inadequada para o cenário
 envolvendo interpretadores embutidos.
 Embora o uso do pré-processador simplifique os casos simples de declaração
 de funções C, a falta de uma API bem definida para tratar a transferência
 de dados entre o interpretador Perl e o código C se faz perceber nos casos
 mais elaborados.
 Duas destas situações se fizeram presentes no estudo de caso: o recebimento
 de parâmetros 
\emph on 
varargs
\emph default 
 e a passagem de valores de retorno tratando múltiplos contextos de execução.
 Ambas exigiram manipulações de estruturas e construções de mais baixo nível,
 que o pré-processador tem por objetivo ocultar.
\layout Standard

Observações interessantes resultaram da comparação da API de Java com a
 das demais quatro linguagens de script, uma vez que, embora possua diversas
 características em comum com estas linguagens, Java não seja considerada
 uma linguagem de script.
 Enquanto a tipagem estática reduz bastante a necessidade de conversões
 de dados explícitas no código C para tipos primitivos da linguagem, na
 prática a verificação de tipos para objetos e a ligação de campos e métodos
 acontece de forma dinâmica, já que estes têm que ser realizados em tempo
 de execução pela JNI.
 Assim, no contexto da interação de uma máquina virtual com código C, as
 vantagens trazidas pela tipagem estática são reduzidas.
 Além disso, a resolução dinâmica de campos e métodos faz com que a manipulação
 de objetos via C tenha diferenças sutis de comportamento em relação ao
 que ocorre em código Java, o que pode ser uma fonte de erros do programador.
\layout Standard

Ao comparar as APIs, consideramos apenas as suas interfaces, fazendo uma
 análise qualitativa da usabilidade de cada uma da perspectiva do programador
 C, e não uma análise quantitativa das suas implementações.
 O custo de desempenho adicionado pelo código que realiza a ligação entre
 duas linguagens, por exemplo, não pode ser desprezado.
 Muitas decisões de projeto de uma API são influenciadas por requisitos
 da implementação como restrições de portabilidade ou desempenho.
 Por exemplo, o tratamento automático de controle de escopo de 
\family typewriter 
VALUE
\family default 
s em Ruby, varrendo a pilha de C, traz grande conveniência para o programador,
 mas reduz a portabilidade da implementação.
\layout Standard

Merece comentário também a disparidade entre as linguagens no que concerne
 à disponibilidade de documentação.
 Java, Python e Lua possuem extensa documentação, tanto para a linguagem
 como para as suas APIs para C.
 Para estas linguagens, pudemos basear largamente nosso estudo e a implementação
 dos exemplos para o estudo de caso na documentação fornecida.
 A documentação de Ruby relativa à sua API de C é mais escassa; em\SpecialChar ~

\begin_inset LatexCommand \cite{thomas04ruby}

\end_inset 

 é coberta apenas parte da API pública.
 Precisamos fazer uso de funções não documentadas para tarefas fundamentais
 como liberar referências globais registradas via C.
 Durante o desenvolvimento do plugin Ruby no estudo de caso, consultamos
 freqüentemente o código-fonte de Ruby para compreender os aspectos que
 não são cobertos pela documentação do comportamento das suas funções públicas.
 A documentação da API de C de Perl também é incompleta, espalhada através
 de diversas 
\emph on 
man pages
\emph default 
 incluídas na sua distribuição e em certos casos desatualizada.
 Para compreender os diversos protocolos envolvidos no uso prático da API
 de Perl, precisamos recorrer ao código-fonte de aplicações que fazem uso
 dela.
\layout Standard

O equilíbrio entre simplicidade e conveniência é outro tema recorrente ao
 compararmos as APIs.
 A extensa API de Python, contendo 656 funções públicas, contrasta com as
 113 funções expostas pela API de Lua (79 na API 
\emph on 
core
\emph default 
, 34 na API auxiliar).
 Em diversas situações, funções na API de Python abreviam duas, três ou
 até mais chamadas, como no caso de funções poderosas como 
\family typewriter 
Py_BuildValue
\family default 
 e 
\family typewriter 
PyObject_CallFunction
\family default 
, tornando o código C sucinto e legível.
 A abordagem defendida por Lua é a de uma API minimalista, oferecendo mecanismos
 sobre os quais funcionalidades mais elaboradas possam ser construídas.
 De fato, em\SpecialChar ~

\begin_inset LatexCommand \cite{ierusalimschy06pil2}

\end_inset 

 é apresentada uma função C equivalente a 
\family typewriter 
PyObject_CallFunction
\family default 
 usando a API de Lua.
\layout Standard

Ruby exporta 530 funções em seu cabeçalho e Perl 1209, mas como apenas uma
 pequena fração destas é documentada, torna-se difícil avaliar o tamanho
 da 
\begin_inset Quotes eld
\end_inset 

API pública
\begin_inset Quotes erd
\end_inset 

 destas linguagens e quantas destas são apenas funções para uso interno
 expostas nos seus cabeçalhos
\begin_inset Foot
collapsed true

\layout Standard

Algumas funções são marcadas como sendo de uso interno, mas a maioria não
 possui qualquer indicação.
\end_inset 

.
 Isto mostra também que a documentação não é relevante apenas enquanto material
 de apoio para o desenvolvimento, mas também indica o quão bem definida
 é uma API.
\layout Standard

A API de Java é bem documentada como a de Python e Lua, mas o número de
 funções exportadas não é um bom parâmetro para comparações com as demais
 APIs porque, em função dos tipos estaticamente definidos, muitas funções
 possuem uma variante para cada tipo primitivo.
 Java exporta sua API como uma estrutura contendo ponteiros para função;
 228 funções ao todo são exportadas nesta estrutura.
\layout Standard

Outro aspecto que pôde ser observado neste trabalho é que a consistência
 da API depende largamente da consistência da linguagem que ela expõe.
 Construções onde a linguagem tem pouca ortogonalidade, como o tratamento
 de blocos em Ruby ou as diferenças nos tratamentos de valores escalares
 e arrays em Perl, acabam por aumentar a complexidade da API da linguagem
 e demandam tratamento específico por parte do programador no código C.
\layout Standard

Como possibilidades de trabalhos futuros, este trabalho pode ser estendido
 através do estudo de outros aspectos de APIs de linguagens de script.
 Um foco possível é o impacto de desempenho de diferentes projetos de API
 em aplicações multi-linguagem.
 Outro é a relação entre o projeto de uma máquina virtual e o de sua respectiva
 API.
 Além disso, outra perspectiva de trabalho é a continuação do desenvolvimento
 da biblioteca LibScript.
 Possibilidades incluem adicionar novos plugins, revisar a sua API e exercitá-la
 embutindo a biblioteca em aplicações reais.
 LibScript e os quatro plugins implementados são software livre e estão
 disponíveis para download em\SpecialChar ~

\begin_inset LatexCommand \url{http://libscript.sourceforge.net}

\end_inset 

.
\layout Standard


\begin_inset LatexCommand \BibTeX[plain]{dissert}

\end_inset 


\layout Chapter
\start_of_appendix 

\begin_inset LatexCommand \label{cha:API-de-LibScript}

\end_inset 

API de LibScript
\layout Section

Inicialização e Término
\layout Itemize


\family typewriter 
script_env* script_init(const char* namespace)
\family default 

\newline 
Inicializa LibScript e retorna um ponteiro para o ambiente virtual.
 O parâmetro 
\family typewriter 
namespace
\family default 
 indica o nome a ser usado nas estruturas a serem criadas no espaço de nomes
 das máquinas virtuais para representar o ambiente virtual.
\layout Itemize


\family typewriter 
void script_done(script_env* env)
\family default 

\newline 
Encerra o ambiente virtual.
\layout Section

Registro de Funções
\layout Itemize


\family typewriter 
typedef script_err (*script_fn)(script_env*)
\family default 

\newline 
Tipo das funções C a serem registradas no ambiente virtual.
 Ao expor uma API existente para LibScript, a função tipicamente será uma
 função 
\emph on 
wrapper
\emph default 
 que carrega os parâmetros de entrada do ambiente, chama uma função do programa
 e envia os parâmetros de saída de volta ao ambiente.
\layout Itemize


\family typewriter 
script_err script_new_function(script_env* env, script_fn fn, const char*
 name)
\family default 

\newline 
Registra uma função no ambiente virtual.
\layout Section

Buffer de parâmetros
\layout Itemize


\family typewriter 
double script_get_double(script_env* env, int index)
\newline 
int script_get_int(script_env* env, int index)
\newline 
int script_get_bool(script_env* env, int index)
\newline 
const char* script_get_string(script_env* env, int index)
\family default 

\newline 
Obtêm dados do buffer.
 Estas funções devem ser chamadas ao início das funções 
\emph on 
wrapper
\emph default 
.
 Para cada parâmetro de entrada, uma chamada deve ser realizada.
 Ao fim, pode-se invocar a macro 
\family typewriter 
SCRIPT_CHECK_INPUTS(env)
\family default 
, que encerra a função retornando um código de erro caso alguma leitura
 com alguma destas funções não tenha encontrado um dado do tipo esperado
 (A API não realiza conversões automáticas entre strings e números).
 Em 
\family typewriter 
script_get_string
\family default 
, a string retornada pertence ao chamador, que passa a ser responsável por
 desalocá-la.
\layout Itemize


\family typewriter 
script_type script_get_type(script_env* env, int index)
\newline 
int script_buffer_len(script_env* env)
\newline 

\family default 
Estas funções permitem escrever funções em C que realizam verificação de
 tipo e número de parâmetros em tempo de execução.
 A função 
\family typewriter 
script_get_type
\family default 
 obtém o tipo do elemento do buffer solicitado e 
\family typewriter 
script_buffer_len
\family default 
 retorna o número de parâmetros no buffer.
\layout Itemize


\family typewriter 
void script_put_double(script_env* env, int index, double value)
\newline 
void script_put_int(script_env* env, int index, int value)
\newline 
void script_put_bool(script_env* env, int index, int value)
\newline 
void script_put_string(script_env* env, int index, const char* value)
\newline 

\family default 
Inserem dados no buffer.
 Ao final de uma função, os valores de retorno devem ser passados com chamadas
 a estas funções e um código de erro 
\family typewriter 
SCRIPT_OK
\family default 
 como retorno da função C.
\layout Itemize


\family typewriter 
void script_reset_buffer(script_env* env)
\family default 

\newline 
Esvazia o buffer.
\layout Section

Executando Código
\layout Itemize


\family typewriter 
script_err script_run(script_env* env, const char* language, const char*
 code)
\family default 

\newline 
Executa uma string de código em uma dada linguagem.
 Se necessário, o plugin apropriado é carregado e inicializado.
\layout Itemize


\family typewriter 
script_err script_run_file(script_env* env, const char* filename)
\family default 

\newline 
Função de conveniência; carrega o texto de um arquivo e o executa com 
\family typewriter 
script_run
\family default 
.
 A linguagem é detectada a partir da extensão do arquivo.
\layout Itemize


\family typewriter 
script_err script_call(script_env* env, const char* fn)
\family default 

\newline 
Requisita a execução de uma função em algum dos plugins cadastrados.
 Os parâmetros de entrada devem ser passados anteriormente com chamadas
 às funções 
\family typewriter 
script_put_*
\family default 
; valores de retorno podem ser obtidos com 
\family typewriter 
script_get_*
\family default 
.
 Inicialmente, a tabela de funções C do ambiente virtual é consultada.
 Não havendo uma função definida em C, os plugins são consultados na seqüência
 em que foram inicializados implicitamente via 
\family typewriter 
script_run
\family default 
 ou 
\family typewriter 
script_run_file
\family default 
: funções registradas na representação do ambiente virtual definido para
 a LibScript na máquina virtual da linguagem (isto é, no nome criado com
 
\family typewriter 
script_init
\family default 
) são acessíveis via 
\family typewriter 
script_call
\family default 
.
\layout Itemize


\family typewriter 
script_err script_error(script_env* env)
\newline 
const char* script_error_message(script_env* env)
\newline 
void script_set_error_message(script_env* env, const char* message)
\newline 

\family default 
Obtém o código e a mensagem de erro mais recentes do ambiente.
 Após uma chamada a script_error, o código de erro é zerado de volta para
 
\family typewriter 
SCRIPT_OK
\family default 
.
 A mensagem de erro, por sua vez, não é zerada.
 A função 
\family typewriter 
script_set_error_message
\family default 
 define um novo valor para a mensagem de erro do ambiente.
 Permite ao plugin propagar à aplicação as mensagens de erro da máquina
 virtual.
\layout Itemize


\family typewriter 
const char* script_get_namespace(script_env* env)
\family default 

\newline 
Retorna o nome do namespace registrado com 
\family typewriter 
script_init
\family default 
.
\layout Section

API Exportada por Plugins
\layout Standard

As chamadas aos plugins que implementam interfaces com as várias máquinas
 virtuais são realizadas internamente pela biblioteca principal, que espera
 encontrar as seguintes funções:
\layout Itemize


\family typewriter 
script_plugin_state script_plugin_init_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_env* env)
\family default 

\newline 
Responsável por inicializar o plugin.
 Durante a inicialização, o espaço de nomes do ambiente virtual deve ser
 exposto à máquina virtual de alguma forma apropriada para a linguagem (como
 uma tabela em Lua, ou um módulo em Python, ou ainda uma classe em Ruby).
 A rotina de inicialização pode retornar um handle que será passado de volta
 a ele nas chamadas subseqüentes.
 O estado da máquina virtual e o ponteiro para o ambiente LibScript devem
 ser armazenados de modo a ser posteriormente acessíveis a partir deste
 handle.
\layout Itemize


\family typewriter 
script_err script_plugin_run_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* text)
\family default 

\newline 
Envia código para execução na máquina virtual.
 Esta função é utilizada internamente por 
\family typewriter 
script_run
\family default 
 e 
\family typewriter 
script_run_file
\family default 
.
 Deve retornar 
\family typewriter 
SCRIPT_OK
\family default 
 em caso de sucesso, 
\family typewriter 
SCRIPT_ERRLANGCOMP
\family default 
 para erros de compilação ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 para erros de execução, preferencialmente definindo uma mensagem de erro
 com 
\family typewriter 
script_set_error_message
\family default 
.
\layout Itemize


\family typewriter 
script_err script_plugin_call_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st, char* fn)
\family default 

\newline 
Realiza a chamada de uma função que tenha sido definida nativamente no espaço
 de nomes do ambiente na máquina virtual do plugin.
 Ao chamar uma função no espaço de nomes, seja em C através de 
\family typewriter 
script_call
\family default 
 ou executando código em algum dos plugins, LibScript irá utilizar esta
 função para tentar executar a função no contexto do plugin.
 Se a função não foi definida no plugin, o valor 
\family typewriter 
SCRIPT_ERRFNUNDEF
\family default 
 deve ser retornado.
 Caso contrário, ela deve ser executada, com parâmetros de entrada obtidos
 através de 
\family typewriter 
script_get_*
\family default 
 e valores de retorno enviados com 
\family typewriter 
script_put_*
\family default 
, e os valores 
\family typewriter 
SCRIPT_OK
\family default 
 ou 
\family typewriter 
SCRIPT_ERRLANGRUN
\family default 
 devem ser retornados, conforme apropriado.
 
\layout Itemize


\family typewriter 
void script_plugin_done_
\family default 
\emph on 
linguagem
\family typewriter 
\emph default 
(script_plugin_state st)
\family default 

\newline 
Responsável pelo encerramento do ambiente.
\the_end
